{"config":{"lang":["en","zh"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"STM32 MCU EDGE INTELLIGENCE NODE","text":"<p>This project dedicates to the development of a MCU edge intelligence node based on STM32. If you are interested in this project, please star it and stay tuned.</p> <p></p>"},{"location":"ABOUT/about/","title":"STM32 MCU EDGE INTELLIGENCE NODE","text":"<p>This project dedicates to the development of a MCU edge intelligence node based on STM32. If you are interested in this project, please star it and stay tuned.</p> <p></p>"},{"location":"ARCHITECTURE/architecture/","title":"ARCHITECTURE","text":""},{"location":"ARCHITECTURE/architecture/#hardware-architecture","title":"HARDWARE ARCHITECTURE","text":"<p>MAIN CONTROL + PERCEPTION + COMMUNICATION + INTERFACING</p>"},{"location":"ARCHITECTURE/architecture/#main-control","title":"MAIN CONTROL","text":"<ul> <li>STM32H743IIT6 (ARM Cortex-M7 480MHz)</li> <li>RAM 1MB</li> <li>FLASH 2MB</li> <li>SDRAM 32MB</li> <li>QSPI FLASH 8MB (TO BE DEVELOPED)</li> <li>TF CARD 32GB</li> </ul>"},{"location":"ARCHITECTURE/architecture/#perception","title":"PERCEPTION","text":"<ul> <li>IMU<ul> <li>MPU6050</li> </ul> </li> <li>ACC<ul> <li>ADXL362</li> <li>ADXL355</li> </ul> </li> <li>T&amp;H<ul> <li>DHT11</li> </ul> </li> </ul>"},{"location":"ARCHITECTURE/architecture/#communication","title":"COMMUNICATION","text":"<ul> <li>WIFI<ul> <li>ESP8266</li> </ul> </li> <li>BLUETOOTH<ul> <li>HC-05</li> </ul> </li> <li>CELLULAR<ul> <li>SIM7600G-H</li> </ul> </li> </ul>"},{"location":"ARCHITECTURE/architecture/#interfacing","title":"INTERFACING","text":"<ul> <li>OLED<ul> <li>CH1116</li> </ul> </li> </ul>"},{"location":"ARCHITECTURE/architecture/#software-architecture","title":"SOFTWARE ARCHITECTURE","text":"<p>PHYSICAL LAYER -&gt; DRIVER LAYER -&gt; MIDWARE LAYER -&gt; APPLICATION LAYER</p>"},{"location":"ARCHITECTURE/architecture/#dev-toolchain","title":"DEV TOOLCHAIN","text":"<p>INITIALIZATION: STM32CUBEMX</p> <p>PROGRAMMING: KEIL5/STM32CUBEIDE/VSCODE</p>"},{"location":"ARCHITECTURE/architecture/#dev-reference-links","title":"DEV REFERENCE LINKS","text":"<ul> <li> <p> KEYSKING TUTORIALS\ud83c\udfaf\u2705\ud83c\udfc6</p> <p>Upside: Simple, intuitive, animated explanation, highly recommended for beginners.</p> <p>Downside: Chinese only. The contents are too few to cover all aspects of STM32 development, can only be used for basic learning. The uploader is constantly updating the content, so it is recommended to subscribe to the channel.</p> <p>  Portal </p> </li> </ul> <ul> <li> <p> YUANYE IOT STM32\ud83c\udfc6</p> <p>Upside: This is a video tutorial series using CUBEMX for beginners. </p> <p>Downside: Chinese only. Currently, there are few tutorials online that use CUBEMX completely, and this series is a good choice.</p> <p>  Portal </p> </li> </ul> <ul> <li> <p> STM32 FULL STACK\ud83c\udfaf\ud83c\udfc6</p> <p>Upside: Well-rounded, comprehensive, and detailed tutorial.</p> <p>Downside: Chinese only. </p> <p>  Portal </p> </li> <li> <p> STM32 Z\u5c0f\u65cb\ud83c\udfaf\ud83c\udfc6</p> <p>  Portal </p> </li> <li> <p> STM32CubeMX+STM32F4 Series Tutorial\ud83c\udfaf\ud83c\udfc6</p> <p>  Portal </p> </li> <li> <p> STM32CubeMX Auto Configuration\ud83c\udfaf\ud83c\udfc6</p> <p>  Portal </p> </li> <li> <p> STM32CubeMX Tutorial\ud83c\udfaf\ud83c\udfc6</p> <p>  Portal </p> </li> <li> <p> PERIPHERAL DEVELOPMENT\ud83c\udfaf\ud83c\udfc6</p> <p>COMMON PERIPHERALS</p> <p>  Portal </p> </li> </ul>"},{"location":"COMMUNICATION/communication/","title":"COMMUNICATION","text":"<p>This section focuses on the communication system of the MCU, covering the following topics:</p> <ul> <li>WIFI</li> <li>Bluetooth</li> <li>4G</li> </ul>"},{"location":"COMMUNICATION/WIFI/esp8266/","title":"ESP8266 TEST","text":""},{"location":"COMMUNICATION/WIFI/esp8266/#the-module-esp_01s","title":"THE MODULE - ESP_01S","text":"<p>Ai-Thinker ESP_01S</p> <p> </p> <p> </p> <p> </p> <p>Note</p> <p>ESP_01S actually can be taken as a stand alone MCU, but in our case, we will use it as a WiFi module. Therefore, before we integrate it with our STM32, we need to flash it with the AT firmware and fully test its functions that will be used in our project. ESP_01S should be flashed with AT firmware first, and then it can be controlled by AT commands through UART. In this chapter, for simplicity, the AT command will be sent from a PC to the ESP_01S through a USB to UART adapter. For next step, the ESP_01S will be connected to the STM32 through UART, and the STM32 will send AT commands to the ESP_01S to control it.</p>"},{"location":"COMMUNICATION/WIFI/esp8266/#step1-firmware-flashing","title":"STEP1: FIRMWARE FLASHING","text":"<p>Before flashing, we need to setup the hardware and software environment.</p>"},{"location":"COMMUNICATION/WIFI/esp8266/#hardware-setup","title":"Hardware Setup","text":"<p>Prepare your ESP_01S module, USB to TTL adapter, and connect them as shown below:</p> <p></p> ESP_01S USB to TTL NOTES VCC 3.3V if not working, don't use VCC from the USB-TTL adapter, use external power supply GND GND TX RX RX TX CH_PD \uff08EN\uff09 3.3V Optional RST 3.3V Optional GPIO0 GND ensure this is connected to GND when flashing GPIO2 3.3V Optional <p>Tip</p> <p>For VCC, I use external power supply, because the VCC from the USB-TTL adapter is not stable and the ESP_01S may not work properly.</p>"},{"location":"COMMUNICATION/WIFI/esp8266/#software-setup","title":"Software Setup","text":"<ol> <li>Download the AT firmware from the official website.</li> <li>Download the Flash Download Tools from the official website.</li> </ol>"},{"location":"COMMUNICATION/WIFI/esp8266/#flashing","title":"FLASHING","text":"<p>Pick a row in the flash tool, and select the corresponding bin file. Before flashing, we need to erase the flash first. After erasing, we can start flashing.</p> <p> </p> <p>Tip</p> <p>Carefully check the COM port number and the baud rate before you start erasing and flashing. Ensure the configuration is consistent with the picture above.</p> <p> </p> <p>Tip</p> <p>If your flash tool is stuck at the \"SYNC\" stage, it means it needs a trigger. Two ways to do so: </p> <ol> <li> <p>Swiftly connect the RST to the GND then disconnect it; </p> </li> <li> <p>Swiftly disconnect VCC and reconnect it.</p> </li> </ol> <p>After erasing the flash, click the \"STOP\" button, then we can start flashing the AT firmware by clicking the \"START\" button. If you have issues like in the erasing stage, you can try the trigger methods mentioned above.</p> <p>So far, we have finished the firmware flashing for the ESP_01S module. Before we proceed to the next step, you need to remove the wire on IO0 and reconnect the USB-TTL adapter to the computer.</p>"},{"location":"COMMUNICATION/WIFI/esp8266/#step2-test","title":"STEP2: TEST","text":""},{"location":"COMMUNICATION/WIFI/esp8266/#hardware-esp_01s-usb-to-ttl-pc","title":"HARDWARE - ESP_01S - USB to TTL - PC","text":"<p>Connect the ESP_01S to the USB to TTL adapter, and then connect the USB to TTL adapter to the PC.</p> <p>For ESP_01S and USB-TTL wiring, refer to the table below:</p> ESP_01S USB to TTL NOTES VCC 3.3V if the VCC on USB-TTL adapter is not working, use external power supply GND GND TX RX RX TX"},{"location":"COMMUNICATION/WIFI/esp8266/#software-ai-thinker-serial-tool","title":"SOFTWARE - Ai-Thinker Serial Tool","text":"<p>Download the Ai-Thinker Serial Tool from the official website.</p>"},{"location":"COMMUNICATION/WIFI/esp8266/#test-at-commands","title":"TEST AT COMMANDS","text":"<pre><code>AT         // Module test\nAT+CWMODE=1 // 1. Station mode 2. AP (Access Point) mode 3. Both modes\nAT+CWLAP    // List available Wi-Fi networks\nAT+CWJAP=\"mywifiname\",\"mypassword\" // Connect to Wi-Fi\nAT+CIFSR    // Query IP address\nAT+CIPSTA?  // Display network status, including IP, gateway, and subnet mask\nAT+CIPSTART=\"TCP\",\"9.214.19.225\",8000 // Connect to TCP server, ensure the server is working, replace the IP address with your server IP address\nAT+CIPSEND=4 // Send 4 bytes to the server\n</code></pre> <p>TEST RESULTS:</p> <pre><code>AT\n\n\nOK\n\nAT+CWMODE=1\n\n\n\nOK\n\nAT+CWLAP\n\n\n+CWLAP:(5,\"eduroam\",-68,\"a8:9d:2\n1:3c:12:b2\",1,32767,0)\n+CWLAP:(\n5,\"NTUSECURE\",-70,\"a8:9d:21:3c:12:b1\",1,32767,0)\n+CWLAP:(0,\"NTU\nGUEST\",-68,\"a8:9d:21:3c:12:b3\",1,32767,0)\n+CWLAP:(4,\"CSW@CEE\",-\n26,\"28:6c:07:d1:ca:db\",1,18,0)\n\n+CWLAP:(4,\"miwifi-csw@cee\",-26,\"2a:6c:07:d1:ca:db\",1,18,0)\n+CWL\nAP:(0,\"NTUGUEST\",-77,\"a8:9d:21:25:fc:f3\",6,32767,0)\n+CWLAP:(5,\"\neduroam\",-77,\"74:a2:e6:a7:ce:32\",6,32767,0)\n+CWLAP:(5,\"NTUSECURE\",-77,\"74:a2:e6:a7:ce:31\",6,327\n67,0)\n+CWLAP:(4,\"BiliBili School\",-62,\"c0:c9:e3:e4:c3:83\",6,13,\n0)\n+CWLAP:(5,\"NTUSECURE\",-77,\"a8:9d:21:25:fc:f1\",6,32767,0)\n+C\nWLAP:(4,\"360WiFi-YM\",-50,\"70:af:6a:bb:48:81\",6,-6,0)\n+CWLAP:(5,\"eduroam\",-71,\"a8:9d:21:1d:fc:42\",11,32767,0)\n+CWLAP:(5,\"NTUSEC\nURE\",-70,\"a8:9d:21:1d:fc:41\",11,32767,0)\n+CWLAP:(0,\"NTUGUEST\",-\n69,\"a8:9d:21:1d:fc:43\",11,32767,0)\n\nOK\n\nAT+CWJAP_DEF=\"CSW@CEE\",\"********\"\n\n\nWIFI CONNECTED\n\nWIFI GOT IP\n\n\nOK\n\nAT+CIFSR\n\n+CIFSR:STAIP,\"192.168\n.31.193\"\n+CIFSR:STAMAC,\"48:3f:da:68:3d:22\"\n\nOK\n\nAT+CIPSTA?\n\n+CIPSTA:ip:\"192.168\n.31.193\"\n+CIPSTA:gateway:\"192.168.31.1\"\n+CIPSTA:netmask:\"255.255.255.0\"\n\nOK\n\nAT+CIPSTART=\"TCP\",\"9.214.19.225\"\n,8000\n\n\nCONNECT\n\nOK\n\nAT+CIPSEND=4\n\n\nOK\n&gt; \no\n\nbusy s...\n\nRecv 4 bytes\n\n\nSEND OK\n\n+IPD,327:HTTP/1.1 400 Bad Requ\nest\nServer: nginx/1.18.0 (Ubuntu)\nDate: Sat, 24 Aug 2024 09:56:18 GMT\nContent-Type: text/html\nContent-Length: 166\nConnection: close\n\n&lt;html&gt;\n&lt;head&gt;&lt;title\n&gt;400 Bad Request&lt;/title&gt;&lt;/head&gt;\n&lt;body&gt;\n&lt;center&gt;&lt;h1&gt;400 Bad Request&lt;/h1&gt;&lt;/center&gt;\n&lt;hr&gt;&lt;center&gt;nginx/1.18.0 (Ubuntu)&lt;/center&gt;\n\n&lt;/body&gt;\n&lt;/html&gt;\nCLOSED\n\nAT\n\n\nOK\n</code></pre> <p>Info</p> <p>Actually, there are MQTT version firmwares for ESP8266, which can be used for MQTT communication. But in this project, we will use the basic AT firmware for ESP_01S, and the MQTT communication will be implemented on the STM32 side.</p>"},{"location":"COMMUNICATION/WIFI/stm32-esp8266/","title":"STM32-ESP8266","text":"<p>In the previous section, we directly used the serial port to communicate with the ESP8266 module and tested the AT command. In this section, we will use STM32 to control the ESP8266 module to achieve more functions.</p>"},{"location":"COMMUNICATION/WIFI/stm32-esp8266/#driver-reference","title":"Driver Reference","text":"<ul> <li> <p> STM32 + ESP8266</p> <p>  Portal </p> </li> <li> <p> STM32-ESP8266-MQTT</p> <p>  Portal </p> </li> </ul>"},{"location":"COMMUNICATION/WIFI/stm32-esp8266/#hands-on","title":"HANDS-ON","text":""},{"location":"COMMUNICATION/WIFI/stm32-esp8266/#hardware-setup","title":"HARDWARE SETUP","text":"<p>Follow the table below to connect the ESP8266 module to the MCU.</p> ESP8266 PIN MCU PIN VCC 3.3V (or external VCC) GND GND (or external GND) RX PA2 TX PA3 <p></p>"},{"location":"COMMUNICATION/WIFI/stm32-esp8266/#software-setup","title":"SOFTWARE SETUP","text":"<p>CUBEMX configuration:</p> <ol> <li>Enable the USART2 peripheral\uff0c keep default settings.</li> </ol> <p></p> <ol> <li>Enable NVIC configuration for USART2.</li> </ol> <p></p> <ol> <li>Enable DMA for USART2 RX.</li> </ol> <p></p>"},{"location":"COMMUNICATION/WIFI/stm32-esp8266/#driver-transplantation","title":"DRIVER TRANSPLANTATION","text":"<p>Refer to the links above for driver transplantation.</p>"},{"location":"COMMUNICATION/WIFI/wifi/","title":"WIFI","text":""},{"location":"COMMUNICATION/WIFI/wifi/#wifi-introduction","title":"WIFI INTRODUCTION","text":"<p>WIFI is a wireless communication technology that uses radio frequency signals to transmit data. It is widely used in various fields such as smart home, industrial control, and Internet of Things.</p>"},{"location":"COMMUNICATION/WIFI/wifi/#wifi-module-esp8266-and-esp_01s","title":"WIFI MODULE - ESP8266 and ESP_01S","text":""},{"location":"COMMUNICATION/WIFI/wifi/#introduction-of-esp8266","title":"Introduction of ESP8266","text":"<p>ESP8266 is a highly integrated chip designed for the needs of a new connected world, produced by Espressif. It offers a complete and self-contained Wi-Fi networking solution, allowing it to either host the application or to offload all Wi-Fi networking functions from another application processor.</p>"},{"location":"COMMUNICATION/WIFI/wifi/#introduction-of-esp_01s","title":"Introduction of ESP_01S","text":"<p>Ai-Thinker ESP_01S is a low-power, cost-effective embedded Wi-Fi module, which is based on the ESP8266 chip from Espressif. </p> <p></p> <p></p> <p></p>"},{"location":"COMMUNICATION/WIFI/wifi/#integration-framework","title":"INTEGRATION FRAMEWORK","text":"<ol> <li>ESP8266 TEST</li> <li>STM32 - UART - ESP8266 CONNECTION</li> <li>STM32 + MQTT - UART - ESP8266 - CLOUD CONNECTION</li> </ol>"},{"location":"COMPUTATION/computation/","title":"COMPUTATION","text":"<p>This section is dedicated for onboard computation and intelligence. Covering the following topics:</p> <ul> <li>Digital Signal Processing (DSP)</li> <li>Neural Networks (NN)</li> </ul> <p>For more information, please refer to the respective subsections.</p>"},{"location":"COMPUTATION/CMSIS-DSP/cmsis-dsp/","title":"CMSIS-DSP FOR DIGITAL SIGNAL PROCESSING","text":"<p>In this section, let's talk about how to incorporate the CMSIS-DSP library to facilitate onboard digital signal processing. Note that, though it is named as \"DSP\", it is not limited to digital signal processing. It also includes functions for matrix operations, statistics, and so on.</p>"},{"location":"COMPUTATION/CMSIS-DSP/cmsis-dsp/#preparation","title":"PREPARATION","text":"<p>As our project is generated by STM32CubeMX, the CMSIS-DSP library is already included in the project. If you are not using STM32CubeMX, you can download the library from the official website of ARM.</p>"},{"location":"COMPUTATION/CMSIS-DSP/cmsis-dsp/#incorporate-the-library","title":"INCORPORATE THE LIBRARY","text":"<p>There are two forms for the library, source codes and compiled libraries. You can choose either one according to your preference. Here we will use the compiled library for simplicity.</p> <p>In Keil, open 'Manage Project Items', add a branch with a customized name, and then click add file and navigate to the library folder. Select the library file and click 'Add'. (Refer to the picture below)</p> <p></p>"},{"location":"COMPUTATION/CMSIS-DSP/cmsis-dsp/#include-the-header-file","title":"INCLUDE THE HEADER FILE","text":"<p>Similar to the above procedures, the header files are located in the 'Include' folder. Add the folder to the project and include the header file in the source code.</p>"},{"location":"COMPUTATION/CMSIS-DSP/cmsis-dsp/#update-the-include-path","title":"UPDATE THE INCLUDE PATH","text":"<p>Open the 'Options for Target' and add the path of the 'Include' folder to the 'Include Paths' in 'C/C++' tab.</p>"},{"location":"COMPUTATION/CMSIS-DSP/cmsis-dsp/#end","title":"END","text":"<p>Now, the CMSIS-DSP library is successfully incorporated into the project. You can use the functions provided by the library in your project.</p>"},{"location":"COMPUTATION/CMSIS-NN/cmsis-nn/","title":"CMSIS-NN FOR NEURAL NETWORKS","text":"<p>This section we introduce the CMSIS-NN library for onboard NN.</p> <p>Tip</p> <p>Personally, I think X-CUBE-AI is more user-friendly than CMSIS-NN. You can simply import your model and generate the code.</p>"},{"location":"COMPUTATION/CMSIS-NN/cmsis-nn/#preparation","title":"PREPARATION","text":"<p>As we are using STM32CubeMX to generate the project, the CMSIS-NN library is already included in the project. If you are not using STM32CubeMX, you can download the library from the official website of ARM. Note that the CMSIS-NN library comes along with CUBEMX is a bit behind the latest version. You can download the latest version from the official website. But there may be compatibility issues.</p>"},{"location":"COMPUTATION/CMSIS-NN/cmsis-nn/#incorporate-the-source-code","title":"INCORPORATE THE SOURCE CODE","text":"<p>There is no compiled library for CMSIS-NN. You need to incorporate the source code into your project.</p> <p>In Keil, open 'Manage Project Items', add a branch with a customized name, and then click add file and navigate to the NN source code folder. Select the source files and click 'Add'. (Refer to the picture below)</p> <p></p>"},{"location":"COMPUTATION/CMSIS-NN/cmsis-nn/#include-the-header-file","title":"INCLUDE THE HEADER FILE","text":"<p>Similar to the above procedures, the header files are located in the 'Include' folder. Add the folder to the project and include the header file in the source code.</p>"},{"location":"COMPUTATION/CMSIS-NN/cmsis-nn/#update-the-include-path","title":"UPDATE THE INCLUDE PATH","text":"<p>Open the 'Options for Target' and add the path of the 'Include' folder to the 'Include Paths' in 'C/C++' tab.</p> <p></p>"},{"location":"COMPUTATION/CMSIS-NN/cmsis-nn/#end","title":"END","text":"<p>Now, the CMSIS-NN library is successfully incorporated into the project. You can use the functions provided by the library in your project.</p>"},{"location":"INTERFACING/interfacing/","title":"INTERFACING","text":"<p>This section is dedicated to interfacing with the MCU. Currently, it covers the following topic(s):</p> <ul> <li>OLED Display</li> <li>RGB LED</li> <li>Buzzer</li> </ul> <p>Please refer to the respective sub-sections for more information.</p> <p></p>"},{"location":"INTERFACING/BUTTON/button/","title":"BUTTON","text":""},{"location":"INTERFACING/BUTTON/button/#introduction-to-button","title":"INTRODUCTION TO BUTTON","text":"<p>Button is a simple component that is used to control the flow of the program. It is used to start, stop, or reset the program. It is a simple switch that is pressed to make or break the connection. The button is a simple component that is used to control the flow of the program. It is used to start, stop, or reset the program. It is a simple switch that is pressed to make or break the connection.</p>"},{"location":"INTERFACING/BUTTON/button/#key-interrupt-control","title":"KEY &amp; INTERRUPT CONTROL","text":"<ul> <li> <p> KEY &amp; INTERRUPT CONTROL</p> <p>keysking</p> <p>  Portal </p> </li> </ul>"},{"location":"INTERFACING/BUTTON/button/#button-hardware-and-wiring","title":"BUTTON HARDWARE AND WIRING","text":"BUTTON PIN MCU PIN VCC 3.3V (or external VCC) GND GND (or external GND) IO PA11"},{"location":"INTERFACING/BUTTON/button/#software","title":"SOFTWARE","text":"<p>falling edge interrupt - button pressed</p> <p></p> <p>In case HAL_Delay is included in the handling function, the priority of the interrupt should be set to a lower value than the priority of the SysTick interrupt. This is because the SysTick interrupt is used to generate the delay in the HAL_Delay function. If the priority of the button interrupt is higher than the SysTick interrupt, the button interrupt will preempt the SysTick interrupt, causing the delay to be inaccurate.</p>"},{"location":"INTERFACING/BUTTON/button/#source-code","title":"SOURCE CODE","text":""},{"location":"INTERFACING/BUTTON/button/#buttonh","title":"button.h","text":"<pre><code>/**\n * @file button.h\n * @author SHUAIWEN CUI (SHUAIWEN001 AT e DOT ntu DOT edu DOT sg)\n * @brief This file is for button control.\n * @version 1.0\n * @date 2024-09-24\n *\n * @copyright Copyright (c) 2024\n *\n */\n\n#ifndef _BUTTON_H_\n#define _BUTTON_H_\n\n#include \"setup.h\" // Include the setup file to get the configuration parameters\n#include \"stm32h7xx_hal.h\" // HAL library file declaration, replace it with the corresponding file according to the actual situation\n#include \"main.h\" // IO definition and initialization function are in the main.c file, must be referenced\n\n/**\n  * @brief  EXTI line detection callback.\n  * @param  GPIO_Pin: Specifies the port pin connected to corresponding EXTI line.\n  * @retval None\n  */\nvoid HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin);\n\n#endif /* _BUTTON_H_ */\n</code></pre>"},{"location":"INTERFACING/BUTTON/button/#buttonc","title":"button.c","text":"<pre><code>/**\n * @file button.c\n * @author SHUAIWEN CUI (SHUAIWEN001 AT e DOT ntu DOT edu DOT sg)\n * @brief This file is for button control.\n * @version 1.0\n * @date 2024-09-24\n *\n * @copyright Copyright (c) 2024\n *\n */\n\n#include \"button.h\"\n\n/**\n * @brief  EXTI line detection callback.\n * @param  GPIO_Pin: Specifies the port pin connected to corresponding EXTI line.\n * @retval None\n */\nvoid HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)\n{\n    HAL_Delay(10); // Debounce time\n    if (HAL_GPIO_ReadPin(BUTTON_GPIO_Port, BUTTON_Pin) == GPIO_PIN_RESET)\n    {\n        if (GPIO_Pin == BUTTON_Pin)\n        {\n            /* app code */\n            LED_RGB(1, 0, 1);\n            Buzzer_Beep(200);\n            LED_RGB(0, 0, 0);\n        }\n    }\n}\n</code></pre>"},{"location":"INTERFACING/BUTTON/button/#summary","title":"SUMMARY","text":"<p>Here, we use the button for user input, and the button is used in an interruption mode. Instead of using interruption handling function, we use the callback function to allow for longer processing time. As can be seen, the button trigger the interruption handling function and then the callback function, which overwrite the weak function defined in the HAL library.</p>"},{"location":"INTERFACING/BUZZER/buzzer/","title":"BUZZER","text":""},{"location":"INTERFACING/BUZZER/buzzer/#introduction-to-buzzer","title":"INTRODUCTION TO BUZZER","text":"<p>A buzzer is an audio signaling device, which may be mechanical, electromechanical, or piezoelectric. Typical uses of buzzers and beepers include alarm devices, timers, and confirmation of user input such as a mouse click or keystroke. </p>"},{"location":"INTERFACING/BUZZER/buzzer/#hardware-and-wiring","title":"HARDWARE AND WIRING","text":"BUZZER PIN MCU PIN VCC 3.3V (or external VCC) GND GND (or external GND) IO PA12"},{"location":"INTERFACING/BUZZER/buzzer/#source-code","title":"SOURCE CODE","text":""},{"location":"INTERFACING/BUZZER/buzzer/#buzzerh","title":"buzzer.h","text":"<pre><code>/**\n * @file buzzer.h\n * @author SHUAIWEN CUI (SHUAIWEN001 AT e DOT ntu DOT edu DOT sg)\n * @brief This file is for buzzer control function declaration.\n * @version 1.0\n * @date 2024-09-22\n *\n * @copyright Copyright (c) 2024\n *\n */\n\n#ifndef _BUZZER_H_\n#define _BUZZER_H_\n\n#include \"stm32h7xx_hal.h\" // HAL library file declaration, replace it with the corresponding file according to the actual situation\n#include \"main.h\" // IO definition and initialization function are in the main.c file, must be referenced\n\n/**\n * @name Buzzer_On\n * @brief Turn on the buzzer\n */\nvoid Buzzer_On(void);\n\n/**\n * @name Buzzer_Off\n * @brief Turn off the buzzer\n */\nvoid Buzzer_Off(void);\n\n/**\n * @name Buzzer_Toggle\n * @brief Toggle the buzzer\n */\nvoid Buzzer_Toggle(void);\n\n/**\n * @name Buzzer_Beep\n * @brief Make the buzzer beep for a specified duration\n */\nvoid Buzzer_Beep(uint32_t duration_ms);\n\n#endif /* _BUZZER_H_ */\n</code></pre>"},{"location":"INTERFACING/BUZZER/buzzer/#buzzerc","title":"buzzer.c","text":"<pre><code>/**\n * @file buzzer.h\n * @author SHUAIWEN CUI (SHUAIWEN001 AT e DOT ntu DOT edu DOT sg)\n * @brief This file is for buzzer control function declaration.\n * @version 1.0\n * @date 2024-09-22\n *\n * @copyright Copyright (c) 2024\n *\n */\n\n#include \"buzzer.h\"\n\n/**\n * @name Buzzer_On\n * @brief Turn on the buzzer\n */\nvoid Buzzer_On(void)\n{\n    HAL_GPIO_WritePin(BUZZER_GPIO_Port, BUZZER_Pin, GPIO_PIN_SET);\n}\n\n/**\n * @name Buzzer_Off\n * @brief Turn off the buzzer\n */\nvoid Buzzer_Off(void)\n{\n    HAL_GPIO_WritePin(BUZZER_GPIO_Port, BUZZER_Pin, GPIO_PIN_RESET);\n}\n\n/**\n * @name Buzzer_Toggle\n * @brief Toggle the buzzer\n */\nvoid Buzzer_Toggle(void)\n{\n    HAL_GPIO_TogglePin(BUZZER_GPIO_Port, BUZZER_Pin);\n}\n\n/**\n * @name Buzzer_Beep\n * @brief Make the buzzer beep for a specified duration\n */\nvoid Buzzer_Beep(uint32_t duration_ms)\n{\n    Buzzer_On();\n    HAL_Delay(duration_ms); // Delay for the specified duration\n    Buzzer_Off();\n}\n</code></pre>"},{"location":"INTERFACING/OLED/oled/","title":"OLED","text":""},{"location":"INTERFACING/OLED/oled/#oled-introduction","title":"OLED INTRODUCTION","text":"<p>OLED (Organic Light Emitting Diode) is a type of display technology that uses organic compounds to produce light. It is a self-emissive display, which means that it does not require a backlight to function. OLED displays are known for their high contrast ratio, wide viewing angles, and fast response times. They are commonly used in smartphones, tablets, and other portable devices.</p>"},{"location":"INTERFACING/OLED/oled/#oled-module","title":"OLED MODULE","text":"<ul> <li>OLED CONTROL - CH1116</li> <li>OLED SIZE - 1.3 INCH</li> <li>OLED RESOLUTION - 128x64</li> </ul> <ul> <li> <p> product link on Taobao</p> <p>Product link on Taobao</p> <p>  Purchase Link </p> </li> </ul>"},{"location":"INTERFACING/OLED/oled/#driver-reference","title":"DRIVER REFERENCE","text":"<ul> <li>KEYSKING DRIVER</li> </ul> <ul> <li> <p> BAUD DANCE</p> <p>BAUD DANCE</p> <p>  Portal </p> </li> </ul> <p>Info</p> <p>The drivers from KEYSKING and BAUD DANCE are recommended for this OLED module, tested OK.</p> <p></p>"},{"location":"INTERFACING/OLED/oled/#hands-on","title":"HANDS-ON","text":""},{"location":"INTERFACING/OLED/oled/#hardware-setup","title":"HARDWARE SETUP","text":"<p>Follow the table below to connect the OLED module to the MCU.</p> OLED PIN MCU PIN VCC 3.3V (or external VCC) GND GND (or external GND) SCL PB6 SDA PB7 <p></p>"},{"location":"INTERFACING/OLED/oled/#software-setup","title":"SOFTWARE SETUP","text":"<p>STM32CUBEMX\uff1a enbable I2C1 and set the SCL and SDA pins to PB6 and PB7 respectively.</p>"},{"location":"INTERFACING/OLED/oled/#transplant-the-driver-from-keysking-and-call-in-the-main-function","title":"TRANSPLANT THE DRIVER FROM KEYSKING AND CALL IN THE MAIN FUNCTION","text":"<p>Refer to the link above.</p>"},{"location":"INTERFACING/OLED/oled/#add-source-file-to-include-path-and-project-structure","title":"Add Source File to Include Path and Project Structure","text":"<p>Include Path:</p> <p></p> <p>Project Structure:</p> <p></p> <p>Tip</p> <p>A good way to use OLED is to draw on the GRAM and update the canvas using the data in the GRAM.</p>"},{"location":"INTERFACING/OLED/oled/#source-code","title":"Source Code","text":""},{"location":"INTERFACING/OLED/oled/#fonth","title":"\"font.h\"","text":"<pre><code>/**\n * @file font.h\n * @brief font library\n *\n * @attention\n * please use this fond library with Baud Dance OLED driver\n * English font is included\n * Chinese font can be generated using Baud Dance LED Font Assistant (https://led.baud-dance.com)\n * Image data can be generated using the Baud Dance LED Font Assistant (https://led.baud-dance.com)\n */\n#ifndef _FONT_H_\n#define _FONT_H_\n#include \"stdint.h\"\n#include \"string.h\"\n\ntypedef struct ASCIIFont {\n  uint8_t h;\n  uint8_t w;\n  uint8_t *chars;\n} ASCIIFont;\n\nextern const ASCIIFont afont8x6;\nextern const ASCIIFont afont12x6;\nextern const ASCIIFont afont16x8;\nextern const ASCIIFont afont24x12;\n\n/**\n * @brief Font structure\n * @note  The first 4 bytes of the font library store the UTF-8 encoding, the remaining bytes store the font data\n * @note  Font data can be generated using the Baud Dance LED Font Assistant (https://led.baud-dance.com)\n */\ntypedef struct Font {\n  uint8_t h;              // Font height\n  uint8_t w;              // Font width\n  const uint8_t *chars;   // Font library: the first 4 bytes store the UTF-8 encoding, the remaining bytes store the font data\n  uint8_t len;            // Length of the font library, change to uint16_t if it exceeds 256\n  const ASCIIFont *ascii; // Default ASCII font, used when the corresponding character is not found in the font library and ASCII characters need to be displayed\n} Font;\n\nextern const Font font16x16;\n\n/**\n * @brief Image structure\n * @note  Image data can be generated using the Baud Dance LED Font Assistant (https://led.baud-dance.com)\n */\ntypedef struct Image {\n  uint8_t w;           // Image width\n  uint8_t h;           // Image height\n  const uint8_t *data; // Image data\n} Image;\n\nextern const Image bilibiliImg;\n\nextern const Image copilotImg;\n\n\n#endif /* _FONT_H_ */\n</code></pre>"},{"location":"INTERFACING/OLED/oled/#fontc","title":"\"font.c\"","text":"<pre><code>/**\n * @file font.c\n * @brief font library\n *\n * @attention\n * please use this fond library with Baud Dance OLED driver\n * English font is included\n * Chinese font can be generated using Baud Dance LED Font Assistant (https://led.baud-dance.com)\n * Image data can be generated using the Baud Dance LED Font Assistant (https://led.baud-dance.com)\n */\n// clang-format off\n#include \"font.h\"\n\n// 8*6 ASCII\nconst unsigned char ascii_8x6[][6] = {\n    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // space\n    {0x00, 0x00, 0x00, 0x2f, 0x00, 0x00}, // !\n    {0x00, 0x00, 0x07, 0x00, 0x07, 0x00}, // \"\n    {0x00, 0x14, 0x7f, 0x14, 0x7f, 0x14}, // #\n    {0x00, 0x24, 0x2a, 0x7f, 0x2a, 0x12}, // $\n    {0x00, 0x62, 0x64, 0x08, 0x13, 0x23}, // %\n    {0x00, 0x36, 0x49, 0x55, 0x22, 0x50}, // &amp;\n    {0x00, 0x00, 0x05, 0x03, 0x00, 0x00}, // '\n    {0x00, 0x00, 0x1c, 0x22, 0x41, 0x00}, // (\n    {0x00, 0x00, 0x41, 0x22, 0x1c, 0x00}, // )\n    {0x00, 0x14, 0x08, 0x3E, 0x08, 0x14}, // *\n    {0x00, 0x08, 0x08, 0x3E, 0x08, 0x08}, // +\n    {0x00, 0x00, 0x00, 0xA0, 0x60, 0x00}, // ,\n    {0x00, 0x08, 0x08, 0x08, 0x08, 0x08}, // -\n    {0x00, 0x00, 0x60, 0x60, 0x00, 0x00}, // .\n    {0x00, 0x20, 0x10, 0x08, 0x04, 0x02}, // /\n    {0x00, 0x3E, 0x51, 0x49, 0x45, 0x3E}, // 0\n    {0x00, 0x00, 0x42, 0x7F, 0x40, 0x00}, // 1\n    {0x00, 0x42, 0x61, 0x51, 0x49, 0x46}, // 2\n    {0x00, 0x21, 0x41, 0x45, 0x4B, 0x31}, // 3\n    {0x00, 0x18, 0x14, 0x12, 0x7F, 0x10}, // 4\n    {0x00, 0x27, 0x45, 0x45, 0x45, 0x39}, // 5\n    {0x00, 0x3C, 0x4A, 0x49, 0x49, 0x30}, // 6\n    {0x00, 0x01, 0x71, 0x09, 0x05, 0x03}, // 7\n    {0x00, 0x36, 0x49, 0x49, 0x49, 0x36}, // 8\n    {0x00, 0x06, 0x49, 0x49, 0x29, 0x1E}, // 9\n    {0x00, 0x00, 0x36, 0x36, 0x00, 0x00}, // :\n    {0x00, 0x00, 0x56, 0x36, 0x00, 0x00}, // ;\n    {0x00, 0x08, 0x14, 0x22, 0x41, 0x00}, // &lt;\n    {0x00, 0x14, 0x14, 0x14, 0x14, 0x14}, // =\n    {0x00, 0x00, 0x41, 0x22, 0x14, 0x08}, // &gt;\n    {0x00, 0x02, 0x01, 0x51, 0x09, 0x06}, // ?\n    {0x00, 0x32, 0x49, 0x59, 0x51, 0x3E}, // @\n    {0x00, 0x7C, 0x12, 0x11, 0x12, 0x7C}, // A\n    {0x00, 0x7F, 0x49, 0x49, 0x49, 0x36}, // B\n    {0x00, 0x3E, 0x41, 0x41, 0x41, 0x22}, // C\n    {0x00, 0x7F, 0x41, 0x41, 0x22, 0x1C}, // D\n    {0x00, 0x7F, 0x49, 0x49, 0x49, 0x41}, // E\n    {0x00, 0x7F, 0x09, 0x09, 0x09, 0x01}, // F\n    {0x00, 0x3E, 0x41, 0x49, 0x49, 0x7A}, // G\n    {0x00, 0x7F, 0x08, 0x08, 0x08, 0x7F}, // H\n    {0x00, 0x00, 0x41, 0x7F, 0x41, 0x00}, // I\n    {0x00, 0x20, 0x40, 0x41, 0x3F, 0x01}, // J\n    {0x00, 0x7F, 0x08, 0x14, 0x22, 0x41}, // K\n    {0x00, 0x7F, 0x40, 0x40, 0x40, 0x40}, // L\n    {0x00, 0x7F, 0x02, 0x0C, 0x02, 0x7F}, // M\n    {0x00, 0x7F, 0x04, 0x08, 0x10, 0x7F}, // N\n    {0x00, 0x3E, 0x41, 0x41, 0x41, 0x3E}, // O\n    {0x00, 0x7F, 0x09, 0x09, 0x09, 0x06}, // P\n    {0x00, 0x3E, 0x41, 0x51, 0x21, 0x5E}, // Q\n    {0x00, 0x7F, 0x09, 0x19, 0x29, 0x46}, // R\n    {0x00, 0x46, 0x49, 0x49, 0x49, 0x31}, // S\n    {0x00, 0x01, 0x01, 0x7F, 0x01, 0x01}, // T\n    {0x00, 0x3F, 0x40, 0x40, 0x40, 0x3F}, // U\n    {0x00, 0x1F, 0x20, 0x40, 0x20, 0x1F}, // V\n    {0x00, 0x3F, 0x40, 0x38, 0x40, 0x3F}, // W\n    {0x00, 0x63, 0x14, 0x08, 0x14, 0x63}, // X\n    {0x00, 0x07, 0x08, 0x70, 0x08, 0x07}, // Y\n    {0x00, 0x61, 0x51, 0x49, 0x45, 0x43}, // Z\n    {0x00, 0x00, 0x7F, 0x41, 0x41, 0x00}, // [\n    {0x00, 0x55, 0x2A, 0x55, 0x2A, 0x55}, // 55\n    {0x00, 0x00, 0x41, 0x41, 0x7F, 0x00}, // ]\n    {0x00, 0x04, 0x02, 0x01, 0x02, 0x04}, // ^\n    {0x00, 0x40, 0x40, 0x40, 0x40, 0x40}, // _\n    {0x00, 0x00, 0x01, 0x02, 0x04, 0x00}, // '\n    {0x00, 0x20, 0x54, 0x54, 0x54, 0x78}, // a\n    {0x00, 0x7F, 0x48, 0x44, 0x44, 0x38}, // b\n    {0x00, 0x38, 0x44, 0x44, 0x44, 0x20}, // c\n    {0x00, 0x38, 0x44, 0x44, 0x48, 0x7F}, // d\n    {0x00, 0x38, 0x54, 0x54, 0x54, 0x18}, // e\n    {0x00, 0x08, 0x7E, 0x09, 0x01, 0x02}, // f\n    {0x00, 0x18, 0xA4, 0xA4, 0xA4, 0x7C}, // g\n    {0x00, 0x7F, 0x08, 0x04, 0x04, 0x78}, // h\n    {0x00, 0x00, 0x44, 0x7D, 0x40, 0x00}, // i\n    {0x00, 0x40, 0x80, 0x84, 0x7D, 0x00}, // j\n    {0x00, 0x7F, 0x10, 0x28, 0x44, 0x00}, // k\n    {0x00, 0x00, 0x41, 0x7F, 0x40, 0x00}, // l\n    {0x00, 0x7C, 0x04, 0x18, 0x04, 0x78}, // m\n    {0x00, 0x7C, 0x08, 0x04, 0x04, 0x78}, // n\n    {0x00, 0x38, 0x44, 0x44, 0x44, 0x38}, // o\n    {0x00, 0xFC, 0x24, 0x24, 0x24, 0x18}, // p\n    {0x00, 0x18, 0x24, 0x24, 0x18, 0xFC}, // q\n    {0x00, 0x7C, 0x08, 0x04, 0x04, 0x08}, // r\n    {0x00, 0x48, 0x54, 0x54, 0x54, 0x20}, // s\n    {0x00, 0x04, 0x3F, 0x44, 0x40, 0x20}, // t\n    {0x00, 0x3C, 0x40, 0x40, 0x20, 0x7C}, // u\n    {0x00, 0x1C, 0x20, 0x40, 0x20, 0x1C}, // v\n    {0x00, 0x3C, 0x40, 0x30, 0x40, 0x3C}, // w\n    {0x00, 0x44, 0x28, 0x10, 0x28, 0x44}, // x\n    {0x00, 0x1C, 0xA0, 0xA0, 0xA0, 0x7C}, // y\n    {0x00, 0x44, 0x64, 0x54, 0x4C, 0x44}, // z\n    {0x14, 0x14, 0x14, 0x14, 0x14, 0x14}, // horiz lines\n};\n\nconst ASCIIFont afont8x6 = {\n    .h = 8,\n    .w = 6,\n    .chars = (unsigned char *)ascii_8x6,\n};\n\nconst unsigned char ascii_12x6[][12] = {\n    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, /*\" \",0*/\n    {0x00, 0x00, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00}, /*\"!\",1*/\n    {0x00, 0x0C, 0x02, 0x0C, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, /*\"\"\",2*/\n    {0x90, 0xD0, 0xBC, 0xD0, 0xBC, 0x90, 0x00, 0x03, 0x00, 0x03, 0x00, 0x00}, /*\"#\",3*/\n    {0x18, 0x24, 0xFE, 0x44, 0x8C, 0x00, 0x03, 0x02, 0x07, 0x02, 0x01, 0x00}, /*\"$\",4*/\n    {0x18, 0x24, 0xD8, 0xB0, 0x4C, 0x80, 0x00, 0x03, 0x00, 0x01, 0x02, 0x01}, /*\"%\",5*/\n    {0xC0, 0x38, 0xE4, 0x38, 0xE0, 0x00, 0x01, 0x02, 0x02, 0x01, 0x02, 0x02}, /*\"&amp;\",6*/\n    {0x08, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, /*\"'\",7*/\n    {0x00, 0x00, 0x00, 0xF8, 0x04, 0x02, 0x00, 0x00, 0x00, 0x01, 0x02, 0x04}, /*\"(\",8*/\n    {0x00, 0x02, 0x04, 0xF8, 0x00, 0x00, 0x00, 0x04, 0x02, 0x01, 0x00, 0x00}, /*\")\",9*/\n    {0x90, 0x60, 0xF8, 0x60, 0x90, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00}, /*\"*\",10*/\n    {0x20, 0x20, 0xFC, 0x20, 0x20, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00}, /*\"+\",11*/\n    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x06, 0x00, 0x00, 0x00, 0x00}, /*\",\",12*/\n    {0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, /*\"-\",13*/\n    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00}, /*\".\",14*/\n    {0x00, 0x80, 0x60, 0x1C, 0x02, 0x00, 0x04, 0x03, 0x00, 0x00, 0x00, 0x00}, /*\"/\",15*/\n    {0xF8, 0x04, 0x04, 0x04, 0xF8, 0x00, 0x01, 0x02, 0x02, 0x02, 0x01, 0x00}, /*\"0\",16*/\n    {0x00, 0x08, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x02, 0x03, 0x02, 0x00, 0x00}, /*\"1\",17*/\n    {0x18, 0x84, 0x44, 0x24, 0x18, 0x00, 0x03, 0x02, 0x02, 0x02, 0x02, 0x00}, /*\"2\",18*/\n    {0x08, 0x04, 0x24, 0x24, 0xD8, 0x00, 0x01, 0x02, 0x02, 0x02, 0x01, 0x00}, /*\"3\",19*/\n    {0x40, 0xB0, 0x88, 0xFC, 0x80, 0x00, 0x00, 0x00, 0x00, 0x03, 0x02, 0x00}, /*\"4\",20*/\n    {0x3C, 0x24, 0x24, 0x24, 0xC4, 0x00, 0x01, 0x02, 0x02, 0x02, 0x01, 0x00}, /*\"5\",21*/\n    {0xF8, 0x24, 0x24, 0x2C, 0xC0, 0x00, 0x01, 0x02, 0x02, 0x02, 0x01, 0x00}, /*\"6\",22*/\n    {0x0C, 0x04, 0xE4, 0x1C, 0x04, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00}, /*\"7\",23*/\n    {0xD8, 0x24, 0x24, 0x24, 0xD8, 0x00, 0x01, 0x02, 0x02, 0x02, 0x01, 0x00}, /*\"8\",24*/\n    {0x38, 0x44, 0x44, 0x44, 0xF8, 0x00, 0x00, 0x03, 0x02, 0x02, 0x01, 0x00}, /*\"9\",25*/\n    {0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00}, /*\":\",26*/\n    {0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00}, /*\";\",27*/\n    {0x00, 0x20, 0x50, 0x88, 0x04, 0x02, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02}, /*\"&lt;\",28*/\n    {0x90, 0x90, 0x90, 0x90, 0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, /*\"=\",29*/\n    {0x00, 0x02, 0x04, 0x88, 0x50, 0x20, 0x00, 0x02, 0x01, 0x00, 0x00, 0x00}, /*\"&gt;\",30*/\n    {0x18, 0x04, 0xC4, 0x24, 0x18, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00}, /*\"?\",31*/\n    {0xF8, 0x04, 0xE4, 0x94, 0xF8, 0x00, 0x01, 0x02, 0x02, 0x02, 0x02, 0x00}, /*\"@\",32*/\n    {0x00, 0xE0, 0x9C, 0xF0, 0x80, 0x00, 0x02, 0x03, 0x00, 0x00, 0x03, 0x02}, /*\"A\",33*/\n    {0x04, 0xFC, 0x24, 0x24, 0xD8, 0x00, 0x02, 0x03, 0x02, 0x02, 0x01, 0x00}, /*\"B\",34*/\n    {0xF8, 0x04, 0x04, 0x04, 0x0C, 0x00, 0x01, 0x02, 0x02, 0x02, 0x01, 0x00}, /*\"C\",35*/\n    {0x04, 0xFC, 0x04, 0x04, 0xF8, 0x00, 0x02, 0x03, 0x02, 0x02, 0x01, 0x00}, /*\"D\",36*/\n    {0x04, 0xFC, 0x24, 0x74, 0x0C, 0x00, 0x02, 0x03, 0x02, 0x02, 0x03, 0x00}, /*\"E\",37*/\n    {0x04, 0xFC, 0x24, 0x74, 0x0C, 0x00, 0x02, 0x03, 0x02, 0x00, 0x00, 0x00}, /*\"F\",38*/\n    {0xF0, 0x08, 0x04, 0x44, 0xCC, 0x40, 0x00, 0x01, 0x02, 0x02, 0x01, 0x00}, /*\"G\",39*/\n    {0x04, 0xFC, 0x20, 0x20, 0xFC, 0x04, 0x02, 0x03, 0x00, 0x00, 0x03, 0x02}, /*\"H\",40*/\n    {0x04, 0x04, 0xFC, 0x04, 0x04, 0x00, 0x02, 0x02, 0x03, 0x02, 0x02, 0x00}, /*\"I\",41*/\n    {0x00, 0x04, 0x04, 0xFC, 0x04, 0x04, 0x06, 0x04, 0x04, 0x03, 0x00, 0x00}, /*\"J\",42*/\n    {0x04, 0xFC, 0x24, 0xD0, 0x0C, 0x04, 0x02, 0x03, 0x02, 0x00, 0x03, 0x02}, /*\"K\",43*/\n    {0x04, 0xFC, 0x04, 0x00, 0x00, 0x00, 0x02, 0x03, 0x02, 0x02, 0x02, 0x03}, /*\"L\",44*/\n    {0xFC, 0x3C, 0xC0, 0x3C, 0xFC, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00}, /*\"M\",45*/\n    {0x04, 0xFC, 0x30, 0xC4, 0xFC, 0x04, 0x02, 0x03, 0x02, 0x00, 0x03, 0x00}, /*\"N\",46*/\n    {0xF8, 0x04, 0x04, 0x04, 0xF8, 0x00, 0x01, 0x02, 0x02, 0x02, 0x01, 0x00}, /*\"O\",47*/\n    {0x04, 0xFC, 0x24, 0x24, 0x18, 0x00, 0x02, 0x03, 0x02, 0x00, 0x00, 0x00}, /*\"P\",48*/\n    {0xF8, 0x84, 0x84, 0x04, 0xF8, 0x00, 0x01, 0x02, 0x02, 0x07, 0x05, 0x00}, /*\"Q\",49*/\n    {0x04, 0xFC, 0x24, 0x64, 0x98, 0x00, 0x02, 0x03, 0x02, 0x00, 0x03, 0x02}, /*\"R\",50*/\n    {0x18, 0x24, 0x24, 0x44, 0x8C, 0x00, 0x03, 0x02, 0x02, 0x02, 0x01, 0x00}, /*\"S\",51*/\n    {0x0C, 0x04, 0xFC, 0x04, 0x0C, 0x00, 0x00, 0x02, 0x03, 0x02, 0x00, 0x00}, /*\"T\",52*/\n    {0x04, 0xFC, 0x00, 0x00, 0xFC, 0x04, 0x00, 0x01, 0x02, 0x02, 0x01, 0x00}, /*\"U\",53*/\n    {0x04, 0x7C, 0x80, 0xE0, 0x1C, 0x04, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00}, /*\"V\",54*/\n    {0x1C, 0xE0, 0x3C, 0xE0, 0x1C, 0x00, 0x00, 0x03, 0x00, 0x03, 0x00, 0x00}, /*\"W\",55*/\n    {0x04, 0x9C, 0x60, 0x9C, 0x04, 0x00, 0x02, 0x03, 0x00, 0x03, 0x02, 0x00}, /*\"X\",56*/\n    {0x04, 0x1C, 0xE0, 0x1C, 0x04, 0x00, 0x00, 0x02, 0x03, 0x02, 0x00, 0x00}, /*\"Y\",57*/\n    {0x0C, 0x84, 0x64, 0x1C, 0x04, 0x00, 0x02, 0x03, 0x02, 0x02, 0x03, 0x00}, /*\"Z\",58*/\n    {0x00, 0x00, 0xFE, 0x02, 0x02, 0x00, 0x00, 0x00, 0x07, 0x04, 0x04, 0x00}, /*\"[\",59*/\n    {0x00, 0x0E, 0x30, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x00}, /*\"\\\",60*/\n    {0x00, 0x02, 0x02, 0xFE, 0x00, 0x00, 0x00, 0x04, 0x04, 0x07, 0x00, 0x00}, /*\"]\",61*/\n    {0x00, 0x04, 0x02, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, /*\"^\",62*/\n    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08}, /*\"_\",63*/\n    {0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, /*\"`\",64*/\n    {0x00, 0x40, 0xA0, 0xA0, 0xC0, 0x00, 0x00, 0x01, 0x02, 0x02, 0x03, 0x02}, /*\"a\",65*/\n    {0x04, 0xFC, 0x20, 0x20, 0xC0, 0x00, 0x00, 0x03, 0x02, 0x02, 0x01, 0x00}, /*\"b\",66*/\n    {0x00, 0xC0, 0x20, 0x20, 0x60, 0x00, 0x00, 0x01, 0x02, 0x02, 0x02, 0x00}, /*\"c\",67*/\n    {0x00, 0xC0, 0x20, 0x24, 0xFC, 0x00, 0x00, 0x01, 0x02, 0x02, 0x03, 0x02}, /*\"d\",68*/\n    {0x00, 0xC0, 0xA0, 0xA0, 0xC0, 0x00, 0x00, 0x01, 0x02, 0x02, 0x02, 0x00}, /*\"e\",69*/\n    {0x00, 0x20, 0xF8, 0x24, 0x24, 0x04, 0x00, 0x02, 0x03, 0x02, 0x02, 0x00}, /*\"f\",70*/\n    {0x00, 0x40, 0xA0, 0xA0, 0x60, 0x20, 0x00, 0x07, 0x0A, 0x0A, 0x0A, 0x04}, /*\"g\",71*/\n    {0x04, 0xFC, 0x20, 0x20, 0xC0, 0x00, 0x02, 0x03, 0x02, 0x00, 0x03, 0x02}, /*\"h\",72*/\n    {0x00, 0x20, 0xE4, 0x00, 0x00, 0x00, 0x00, 0x02, 0x03, 0x02, 0x00, 0x00}, /*\"i\",73*/\n    {0x00, 0x00, 0x20, 0xE4, 0x00, 0x00, 0x08, 0x08, 0x08, 0x07, 0x00, 0x00}, /*\"j\",74*/\n    {0x04, 0xFC, 0x80, 0xE0, 0x20, 0x20, 0x02, 0x03, 0x02, 0x00, 0x03, 0x02}, /*\"k\",75*/\n    {0x04, 0x04, 0xFC, 0x00, 0x00, 0x00, 0x02, 0x02, 0x03, 0x02, 0x02, 0x00}, /*\"l\",76*/\n    {0xE0, 0x20, 0xE0, 0x20, 0xC0, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00}, /*\"m\",77*/\n    {0x20, 0xE0, 0x20, 0x20, 0xC0, 0x00, 0x02, 0x03, 0x02, 0x00, 0x03, 0x02}, /*\"n\",78*/\n    {0x00, 0xC0, 0x20, 0x20, 0xC0, 0x00, 0x00, 0x01, 0x02, 0x02, 0x01, 0x00}, /*\"o\",79*/\n    {0x20, 0xE0, 0x20, 0x20, 0xC0, 0x00, 0x08, 0x0F, 0x0A, 0x02, 0x01, 0x00}, /*\"p\",80*/\n    {0x00, 0xC0, 0x20, 0x20, 0xE0, 0x00, 0x00, 0x01, 0x02, 0x0A, 0x0F, 0x08}, /*\"q\",81*/\n    {0x20, 0xE0, 0x40, 0x20, 0x20, 0x00, 0x02, 0x03, 0x02, 0x00, 0x00, 0x00}, /*\"r\",82*/\n    {0x00, 0x60, 0xA0, 0xA0, 0x20, 0x00, 0x00, 0x02, 0x02, 0x02, 0x03, 0x00}, /*\"s\",83*/\n    {0x00, 0x20, 0xF8, 0x20, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x02, 0x00}, /*\"t\",84*/\n    {0x20, 0xE0, 0x00, 0x20, 0xE0, 0x00, 0x00, 0x01, 0x02, 0x02, 0x03, 0x02}, /*\"u\",85*/\n    {0x20, 0xE0, 0x20, 0x80, 0x60, 0x20, 0x00, 0x00, 0x03, 0x01, 0x00, 0x00}, /*\"v\",86*/\n    {0x60, 0x80, 0xE0, 0x80, 0x60, 0x00, 0x00, 0x03, 0x00, 0x03, 0x00, 0x00}, /*\"w\",87*/\n    {0x20, 0x60, 0x80, 0x60, 0x20, 0x00, 0x02, 0x03, 0x00, 0x03, 0x02, 0x00}, /*\"x\",88*/\n    {0x20, 0xE0, 0x20, 0x80, 0x60, 0x20, 0x08, 0x08, 0x07, 0x01, 0x00, 0x00}, /*\"y\",89*/\n    {0x00, 0x20, 0xA0, 0x60, 0x20, 0x00, 0x00, 0x02, 0x03, 0x02, 0x02, 0x00}, /*\"z\",90*/\n    {0x00, 0x00, 0x20, 0xDE, 0x02, 0x00, 0x00, 0x00, 0x00, 0x07, 0x04, 0x00}, /*\"{\",91*/\n    {0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00}, /*\"|\",92*/\n    {0x00, 0x02, 0xDE, 0x20, 0x00, 0x00, 0x00, 0x04, 0x07, 0x00, 0x00, 0x00}, /*\"}\",93*/\n    {0x02, 0x01, 0x02, 0x04, 0x04, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, /*\"~\",94*/\n};\n\nconst ASCIIFont afont12x6 = {\n    .h = 12,\n    .w = 6,\n    .chars = (unsigned char *)ascii_12x6,\n};\n\nconst unsigned char ascii_16x8[][16] = {\n    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, /*\" \",0*/\n    {0x00, 0x00, 0x00, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x33, 0x30, 0x00, 0x00, 0x00}, /*\"!\",1*/\n    {0x00, 0x10, 0x0C, 0x06, 0x10, 0x0C, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, /*\"\"\",2*/\n    {0x40, 0xC0, 0x78, 0x40, 0xC0, 0x78, 0x40, 0x00, 0x04, 0x3F, 0x04, 0x04, 0x3F, 0x04, 0x04, 0x00}, /*\"#\",3*/\n    {0x00, 0x70, 0x88, 0xFC, 0x08, 0x30, 0x00, 0x00, 0x00, 0x18, 0x20, 0xFF, 0x21, 0x1E, 0x00, 0x00}, /*\"$\",4*/\n    {0xF0, 0x08, 0xF0, 0x00, 0xE0, 0x18, 0x00, 0x00, 0x00, 0x21, 0x1C, 0x03, 0x1E, 0x21, 0x1E, 0x00}, /*\"%\",5*/\n    {0x00, 0xF0, 0x08, 0x88, 0x70, 0x00, 0x00, 0x00, 0x1E, 0x21, 0x23, 0x24, 0x19, 0x27, 0x21, 0x10}, /*\"&amp;\",6*/\n    {0x10, 0x16, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, /*\"'\",7*/\n    {0x00, 0x00, 0x00, 0xE0, 0x18, 0x04, 0x02, 0x00, 0x00, 0x00, 0x00, 0x07, 0x18, 0x20, 0x40, 0x00}, /*\"(\",8*/\n    {0x00, 0x02, 0x04, 0x18, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x40, 0x20, 0x18, 0x07, 0x00, 0x00, 0x00}, /*\")\",9*/\n    {0x40, 0x40, 0x80, 0xF0, 0x80, 0x40, 0x40, 0x00, 0x02, 0x02, 0x01, 0x0F, 0x01, 0x02, 0x02, 0x00}, /*\"*\",10*/\n    {0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x1F, 0x01, 0x01, 0x01, 0x00}, /*\"+\",11*/\n    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xB0, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00}, /*\",\",12*/\n    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01}, /*\"-\",13*/\n    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00}, /*\".\",14*/\n    {0x00, 0x00, 0x00, 0x00, 0x80, 0x60, 0x18, 0x04, 0x00, 0x60, 0x18, 0x06, 0x01, 0x00, 0x00, 0x00}, /*\"/\",15*/\n    {0x00, 0xE0, 0x10, 0x08, 0x08, 0x10, 0xE0, 0x00, 0x00, 0x0F, 0x10, 0x20, 0x20, 0x10, 0x0F, 0x00}, /*\"0\",16*/\n    {0x00, 0x10, 0x10, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x20, 0x3F, 0x20, 0x20, 0x00, 0x00}, /*\"1\",17*/\n    {0x00, 0x70, 0x08, 0x08, 0x08, 0x88, 0x70, 0x00, 0x00, 0x30, 0x28, 0x24, 0x22, 0x21, 0x30, 0x00}, /*\"2\",18*/\n    {0x00, 0x30, 0x08, 0x88, 0x88, 0x48, 0x30, 0x00, 0x00, 0x18, 0x20, 0x20, 0x20, 0x11, 0x0E, 0x00}, /*\"3\",19*/\n    {0x00, 0x00, 0xC0, 0x20, 0x10, 0xF8, 0x00, 0x00, 0x00, 0x07, 0x04, 0x24, 0x24, 0x3F, 0x24, 0x00}, /*\"4\",20*/\n    {0x00, 0xF8, 0x08, 0x88, 0x88, 0x08, 0x08, 0x00, 0x00, 0x19, 0x21, 0x20, 0x20, 0x11, 0x0E, 0x00}, /*\"5\",21*/\n    {0x00, 0xE0, 0x10, 0x88, 0x88, 0x18, 0x00, 0x00, 0x00, 0x0F, 0x11, 0x20, 0x20, 0x11, 0x0E, 0x00}, /*\"6\",22*/\n    {0x00, 0x38, 0x08, 0x08, 0xC8, 0x38, 0x08, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00}, /*\"7\",23*/\n    {0x00, 0x70, 0x88, 0x08, 0x08, 0x88, 0x70, 0x00, 0x00, 0x1C, 0x22, 0x21, 0x21, 0x22, 0x1C, 0x00}, /*\"8\",24*/\n    {0x00, 0xE0, 0x10, 0x08, 0x08, 0x10, 0xE0, 0x00, 0x00, 0x00, 0x31, 0x22, 0x22, 0x11, 0x0F, 0x00}, /*\"9\",25*/\n    {0x00, 0x00, 0x00, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00, 0x00, 0x00}, /*\":\",26*/\n    {0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x60, 0x00, 0x00, 0x00, 0x00}, /*\";\",27*/\n    {0x00, 0x00, 0x80, 0x40, 0x20, 0x10, 0x08, 0x00, 0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x00}, /*\"&lt;\",28*/\n    {0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x00, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x00}, /*\"=\",29*/\n    {0x00, 0x08, 0x10, 0x20, 0x40, 0x80, 0x00, 0x00, 0x00, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01, 0x00}, /*\"&gt;\",30*/\n    {0x00, 0x70, 0x48, 0x08, 0x08, 0x08, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x30, 0x36, 0x01, 0x00, 0x00}, /*\"?\",31*/\n    {0xC0, 0x30, 0xC8, 0x28, 0xE8, 0x10, 0xE0, 0x00, 0x07, 0x18, 0x27, 0x24, 0x23, 0x14, 0x0B, 0x00}, /*\"@\",32*/\n    {0x00, 0x00, 0xC0, 0x38, 0xE0, 0x00, 0x00, 0x00, 0x20, 0x3C, 0x23, 0x02, 0x02, 0x27, 0x38, 0x20}, /*\"A\",33*/\n    {0x08, 0xF8, 0x88, 0x88, 0x88, 0x70, 0x00, 0x00, 0x20, 0x3F, 0x20, 0x20, 0x20, 0x11, 0x0E, 0x00}, /*\"B\",34*/\n    {0xC0, 0x30, 0x08, 0x08, 0x08, 0x08, 0x38, 0x00, 0x07, 0x18, 0x20, 0x20, 0x20, 0x10, 0x08, 0x00}, /*\"C\",35*/\n    {0x08, 0xF8, 0x08, 0x08, 0x08, 0x10, 0xE0, 0x00, 0x20, 0x3F, 0x20, 0x20, 0x20, 0x10, 0x0F, 0x00}, /*\"D\",36*/\n    {0x08, 0xF8, 0x88, 0x88, 0xE8, 0x08, 0x10, 0x00, 0x20, 0x3F, 0x20, 0x20, 0x23, 0x20, 0x18, 0x00}, /*\"E\",37*/\n    {0x08, 0xF8, 0x88, 0x88, 0xE8, 0x08, 0x10, 0x00, 0x20, 0x3F, 0x20, 0x00, 0x03, 0x00, 0x00, 0x00}, /*\"F\",38*/\n    {0xC0, 0x30, 0x08, 0x08, 0x08, 0x38, 0x00, 0x00, 0x07, 0x18, 0x20, 0x20, 0x22, 0x1E, 0x02, 0x00}, /*\"G\",39*/\n    {0x08, 0xF8, 0x08, 0x00, 0x00, 0x08, 0xF8, 0x08, 0x20, 0x3F, 0x21, 0x01, 0x01, 0x21, 0x3F, 0x20}, /*\"H\",40*/\n    {0x00, 0x08, 0x08, 0xF8, 0x08, 0x08, 0x00, 0x00, 0x00, 0x20, 0x20, 0x3F, 0x20, 0x20, 0x00, 0x00}, /*\"I\",41*/\n    {0x00, 0x00, 0x08, 0x08, 0xF8, 0x08, 0x08, 0x00, 0xC0, 0x80, 0x80, 0x80, 0x7F, 0x00, 0x00, 0x00}, /*\"J\",42*/\n    {0x08, 0xF8, 0x88, 0xC0, 0x28, 0x18, 0x08, 0x00, 0x20, 0x3F, 0x20, 0x01, 0x26, 0x38, 0x20, 0x00}, /*\"K\",43*/\n    {0x08, 0xF8, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x3F, 0x20, 0x20, 0x20, 0x20, 0x30, 0x00}, /*\"L\",44*/\n    {0x08, 0xF8, 0xF8, 0x00, 0xF8, 0xF8, 0x08, 0x00, 0x20, 0x3F, 0x00, 0x3F, 0x00, 0x3F, 0x20, 0x00}, /*\"M\",45*/\n    {0x08, 0xF8, 0x30, 0xC0, 0x00, 0x08, 0xF8, 0x08, 0x20, 0x3F, 0x20, 0x00, 0x07, 0x18, 0x3F, 0x00}, /*\"N\",46*/\n    {0xE0, 0x10, 0x08, 0x08, 0x08, 0x10, 0xE0, 0x00, 0x0F, 0x10, 0x20, 0x20, 0x20, 0x10, 0x0F, 0x00}, /*\"O\",47*/\n    {0x08, 0xF8, 0x08, 0x08, 0x08, 0x08, 0xF0, 0x00, 0x20, 0x3F, 0x21, 0x01, 0x01, 0x01, 0x00, 0x00}, /*\"P\",48*/\n    {0xE0, 0x10, 0x08, 0x08, 0x08, 0x10, 0xE0, 0x00, 0x0F, 0x18, 0x24, 0x24, 0x38, 0x50, 0x4F, 0x00}, /*\"Q\",49*/\n    {0x08, 0xF8, 0x88, 0x88, 0x88, 0x88, 0x70, 0x00, 0x20, 0x3F, 0x20, 0x00, 0x03, 0x0C, 0x30, 0x20}, /*\"R\",50*/\n    {0x00, 0x70, 0x88, 0x08, 0x08, 0x08, 0x38, 0x00, 0x00, 0x38, 0x20, 0x21, 0x21, 0x22, 0x1C, 0x00}, /*\"S\",51*/\n    {0x18, 0x08, 0x08, 0xF8, 0x08, 0x08, 0x18, 0x00, 0x00, 0x00, 0x20, 0x3F, 0x20, 0x00, 0x00, 0x00}, /*\"T\",52*/\n    {0x08, 0xF8, 0x08, 0x00, 0x00, 0x08, 0xF8, 0x08, 0x00, 0x1F, 0x20, 0x20, 0x20, 0x20, 0x1F, 0x00}, /*\"U\",53*/\n    {0x08, 0x78, 0x88, 0x00, 0x00, 0xC8, 0x38, 0x08, 0x00, 0x00, 0x07, 0x38, 0x0E, 0x01, 0x00, 0x00}, /*\"V\",54*/\n    {0xF8, 0x08, 0x00, 0xF8, 0x00, 0x08, 0xF8, 0x00, 0x03, 0x3C, 0x07, 0x00, 0x07, 0x3C, 0x03, 0x00}, /*\"W\",55*/\n    {0x08, 0x18, 0x68, 0x80, 0x80, 0x68, 0x18, 0x08, 0x20, 0x30, 0x2C, 0x03, 0x03, 0x2C, 0x30, 0x20}, /*\"X\",56*/\n    {0x08, 0x38, 0xC8, 0x00, 0xC8, 0x38, 0x08, 0x00, 0x00, 0x00, 0x20, 0x3F, 0x20, 0x00, 0x00, 0x00}, /*\"Y\",57*/\n    {0x10, 0x08, 0x08, 0x08, 0xC8, 0x38, 0x08, 0x00, 0x20, 0x38, 0x26, 0x21, 0x20, 0x20, 0x18, 0x00}, /*\"Z\",58*/\n    {0x00, 0x00, 0x00, 0xFE, 0x02, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x40, 0x40, 0x40, 0x00}, /*\"[\",59*/\n    {0x00, 0x0C, 0x30, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x06, 0x38, 0xC0, 0x00}, /*\"\\\",60*/\n    {0x00, 0x02, 0x02, 0x02, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x40, 0x40, 0x40, 0x7F, 0x00, 0x00, 0x00}, /*\"]\",61*/\n    {0x00, 0x00, 0x04, 0x02, 0x02, 0x02, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, /*\"^\",62*/\n    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80}, /*\"_\",63*/\n    {0x00, 0x02, 0x02, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, /*\"`\",64*/\n    {0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x19, 0x24, 0x22, 0x22, 0x22, 0x3F, 0x20}, /*\"a\",65*/\n    {0x08, 0xF8, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x11, 0x20, 0x20, 0x11, 0x0E, 0x00}, /*\"b\",66*/\n    {0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x0E, 0x11, 0x20, 0x20, 0x20, 0x11, 0x00}, /*\"c\",67*/\n    {0x00, 0x00, 0x00, 0x80, 0x80, 0x88, 0xF8, 0x00, 0x00, 0x0E, 0x11, 0x20, 0x20, 0x10, 0x3F, 0x20}, /*\"d\",68*/\n    {0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x1F, 0x22, 0x22, 0x22, 0x22, 0x13, 0x00}, /*\"e\",69*/\n    {0x00, 0x80, 0x80, 0xF0, 0x88, 0x88, 0x88, 0x18, 0x00, 0x20, 0x20, 0x3F, 0x20, 0x20, 0x00, 0x00}, /*\"f\",70*/\n    {0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x6B, 0x94, 0x94, 0x94, 0x93, 0x60, 0x00}, /*\"g\",71*/\n    {0x08, 0xF8, 0x00, 0x80, 0x80, 0x80, 0x00, 0x00, 0x20, 0x3F, 0x21, 0x00, 0x00, 0x20, 0x3F, 0x20}, /*\"h\",72*/\n    {0x00, 0x80, 0x98, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x20, 0x3F, 0x20, 0x20, 0x00, 0x00}, /*\"i\",73*/\n    {0x00, 0x00, 0x00, 0x80, 0x98, 0x98, 0x00, 0x00, 0x00, 0xC0, 0x80, 0x80, 0x80, 0x7F, 0x00, 0x00}, /*\"j\",74*/\n    {0x08, 0xF8, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0x20, 0x3F, 0x24, 0x02, 0x2D, 0x30, 0x20, 0x00}, /*\"k\",75*/\n    {0x00, 0x08, 0x08, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x20, 0x3F, 0x20, 0x20, 0x00, 0x00}, /*\"l\",76*/\n    {0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x20, 0x3F, 0x20, 0x00, 0x3F, 0x20, 0x00, 0x3F}, /*\"m\",77*/\n    {0x80, 0x80, 0x00, 0x80, 0x80, 0x80, 0x00, 0x00, 0x20, 0x3F, 0x21, 0x00, 0x00, 0x20, 0x3F, 0x20}, /*\"n\",78*/\n    {0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x1F, 0x20, 0x20, 0x20, 0x20, 0x1F, 0x00}, /*\"o\",79*/\n    {0x80, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x80, 0xFF, 0xA1, 0x20, 0x20, 0x11, 0x0E, 0x00}, /*\"p\",80*/\n    {0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x0E, 0x11, 0x20, 0x20, 0xA0, 0xFF, 0x80}, /*\"q\",81*/\n    {0x80, 0x80, 0x80, 0x00, 0x80, 0x80, 0x80, 0x00, 0x20, 0x20, 0x3F, 0x21, 0x20, 0x00, 0x01, 0x00}, /*\"r\",82*/\n    {0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x33, 0x24, 0x24, 0x24, 0x24, 0x19, 0x00}, /*\"s\",83*/\n    {0x00, 0x80, 0x80, 0xE0, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x20, 0x20, 0x00, 0x00}, /*\"t\",84*/\n    {0x80, 0x80, 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00, 0x1F, 0x20, 0x20, 0x20, 0x10, 0x3F, 0x20}, /*\"u\",85*/\n    {0x80, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0x01, 0x0E, 0x30, 0x08, 0x06, 0x01, 0x00}, /*\"v\",86*/\n    {0x80, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x80, 0x0F, 0x30, 0x0C, 0x03, 0x0C, 0x30, 0x0F, 0x00}, /*\"w\",87*/\n    {0x00, 0x80, 0x80, 0x00, 0x80, 0x80, 0x80, 0x00, 0x00, 0x20, 0x31, 0x2E, 0x0E, 0x31, 0x20, 0x00}, /*\"x\",88*/\n    {0x80, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x81, 0x8E, 0x70, 0x18, 0x06, 0x01, 0x00}, /*\"y\",89*/\n    {0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x21, 0x30, 0x2C, 0x22, 0x21, 0x30, 0x00}, /*\"z\",90*/\n    {0x00, 0x00, 0x00, 0x00, 0x80, 0x7C, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x40, 0x40}, /*\"{\",91*/\n    {0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00}, /*\"|\",92*/\n    {0x00, 0x02, 0x02, 0x7C, 0x80, 0x00, 0x00, 0x00, 0x00, 0x40, 0x40, 0x3F, 0x00, 0x00, 0x00, 0x00}, /*\"}\",93*/\n    {0x00, 0x06, 0x01, 0x01, 0x02, 0x02, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, /*\"~\",94*/\n};\n\nconst ASCIIFont afont16x8 = {\n    .h = 16,\n    .w = 8,\n    .chars = (unsigned char *)ascii_16x8,\n};\n\nconst unsigned char ascii_24x12[][36] = {\n    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, /*\" \",0*/\n    {0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0xF0, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x7F, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x1C, 0x1C, 0x00, 0x00, 0x00, 0x00}, /*\"!\",1*/\n    {0x00, 0x00, 0x80, 0x60, 0x30, 0x1C, 0x8C, 0x60, 0x30, 0x1C, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, /*\"\"\",2*/\n    {0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x86, 0xE6, 0x9F, 0x86, 0x86, 0x86, 0x86, 0xE6, 0x9F, 0x86, 0x00, 0x00, 0x01, 0x1F, 0x01, 0x01, 0x01, 0x01, 0x01, 0x1F, 0x01, 0x01, 0x00}, /*\"#\",3*/\n    {0x00, 0x00, 0x80, 0xC0, 0x60, 0x20, 0xF8, 0x20, 0xE0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x03, 0x07, 0x0C, 0x18, 0xFF, 0x70, 0xE1, 0x81, 0x00, 0x00, 0x00, 0x00, 0x07, 0x0F, 0x10, 0x10, 0x7F, 0x10, 0x0F, 0x07, 0x00, 0x00}, /*\"$\",4*/\n    {0x80, 0x60, 0x20, 0x60, 0x80, 0x00, 0x00, 0x00, 0xE0, 0x20, 0x00, 0x00, 0x0F, 0x30, 0x20, 0x30, 0x9F, 0x70, 0xDC, 0x37, 0x10, 0x30, 0xC0, 0x00, 0x00, 0x00, 0x10, 0x0E, 0x03, 0x00, 0x07, 0x18, 0x10, 0x18, 0x07, 0x00}, /*\"%\",5*/\n    {0x00, 0x00, 0xC0, 0x20, 0x20, 0xE0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xE0, 0x1F, 0x38, 0xE8, 0x87, 0x03, 0xC4, 0x3C, 0x04, 0x00, 0x00, 0x07, 0x0F, 0x18, 0x10, 0x10, 0x0B, 0x07, 0x0D, 0x10, 0x10, 0x08, 0x00}, /*\"&amp;\",6*/\n    {0x00, 0x80, 0x8C, 0x4C, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, /*\"'\",7*/\n    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xE0, 0x30, 0x08, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x0F, 0x18, 0x20, 0x40, 0x00}, /*\"(\",8*/\n    {0x00, 0x04, 0x08, 0x30, 0xE0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x20, 0x18, 0x0F, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, /*\")\",9*/\n    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x66, 0x66, 0x3C, 0x18, 0xFF, 0x18, 0x3C, 0x66, 0x66, 0x42, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00}, /*\"*\",10*/\n    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x10, 0x10, 0x10, 0xFF, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00}, /*\"+\",11*/\n    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x8C, 0x4C, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, /*\",\",12*/\n    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, /*\"-\",13*/\n    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x1C, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, /*\".\",14*/\n    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x38, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x70, 0x1C, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x38, 0x0E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, /*\"/\",15*/\n    {0x00, 0x00, 0x80, 0xC0, 0x60, 0x20, 0x20, 0x60, 0xC0, 0x80, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFE, 0x00, 0x00, 0x01, 0x07, 0x0E, 0x18, 0x10, 0x10, 0x18, 0x0E, 0x07, 0x01, 0x00}, /*\"0\",16*/\n    {0x00, 0x00, 0x80, 0x80, 0x80, 0xC0, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x10, 0x1F, 0x1F, 0x10, 0x10, 0x10, 0x00, 0x00}, /*\"1\",17*/\n    {0x00, 0x80, 0x40, 0x20, 0x20, 0x20, 0x20, 0x60, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x03, 0x03, 0x00, 0x80, 0x40, 0x20, 0x38, 0x1F, 0x07, 0x00, 0x00, 0x00, 0x1C, 0x1A, 0x19, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1F, 0x00, 0x00}, /*\"2\",18*/\n    {0x00, 0x80, 0xC0, 0x20, 0x20, 0x20, 0x60, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x00, 0x10, 0x10, 0x18, 0x2F, 0xE7, 0x80, 0x00, 0x00, 0x00, 0x07, 0x0F, 0x10, 0x10, 0x10, 0x10, 0x18, 0x0F, 0x07, 0x00, 0x00}, /*\"3\",19*/\n    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xB0, 0x88, 0x86, 0x81, 0x80, 0xFF, 0xFF, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x1F, 0x1F, 0x10, 0x10, 0x00}, /*\"4\",20*/\n    {0x00, 0x00, 0xE0, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x10, 0x08, 0x08, 0x08, 0x18, 0xF0, 0xE0, 0x00, 0x00, 0x00, 0x07, 0x0B, 0x10, 0x10, 0x10, 0x10, 0x1C, 0x0F, 0x03, 0x00, 0x00}, /*\"5\",21*/\n    {0x00, 0x00, 0x80, 0xC0, 0x40, 0x20, 0x20, 0x20, 0xE0, 0xC0, 0x00, 0x00, 0x00, 0xFC, 0xFF, 0x21, 0x10, 0x08, 0x08, 0x08, 0x18, 0xF0, 0xE0, 0x00, 0x00, 0x01, 0x07, 0x0C, 0x18, 0x10, 0x10, 0x10, 0x08, 0x0F, 0x03, 0x00}, /*\"6\",22*/\n    {0x00, 0x00, 0xC0, 0xE0, 0x60, 0x60, 0x60, 0x60, 0x60, 0xE0, 0x60, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0xE0, 0x18, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00}, /*\"7\",23*/\n    {0x00, 0x80, 0xC0, 0x60, 0x20, 0x20, 0x20, 0x20, 0x60, 0xC0, 0x80, 0x00, 0x00, 0x87, 0xEF, 0x2C, 0x18, 0x18, 0x30, 0x30, 0x68, 0xCF, 0x83, 0x00, 0x00, 0x07, 0x0F, 0x08, 0x10, 0x10, 0x10, 0x10, 0x18, 0x0F, 0x07, 0x00}, /*\"8\",24*/\n    {0x00, 0x00, 0xC0, 0xC0, 0x20, 0x20, 0x20, 0x20, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x1F, 0x3F, 0x60, 0x40, 0x40, 0x40, 0x20, 0x10, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x0C, 0x1C, 0x10, 0x10, 0x10, 0x08, 0x0F, 0x03, 0x00, 0x00}, /*\"9\",25*/\n    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x0E, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x1C, 0x1C, 0x00, 0x00, 0x00, 0x00}, /*\":\",26*/\n    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00}, /*\";\",27*/\n    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x40, 0x20, 0x10, 0x00, 0x00, 0x00, 0x10, 0x28, 0x44, 0x82, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x00}, /*\"&lt;\",28*/\n    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, /*\"=\",29*/\n    {0x00, 0x00, 0x10, 0x20, 0x40, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x82, 0x44, 0x28, 0x10, 0x00, 0x00, 0x00, 0x10, 0x08, 0x04, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00}, /*\"&gt;\",30*/\n    {0x00, 0xC0, 0x20, 0x20, 0x10, 0x10, 0x10, 0x10, 0x30, 0xE0, 0xC0, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0xF0, 0x10, 0x08, 0x0C, 0x07, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x1C, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00}, /*\"?\",31*/\n    {0x00, 0x00, 0x00, 0xC0, 0x40, 0x60, 0x20, 0x20, 0x20, 0x40, 0xC0, 0x00, 0x00, 0xFC, 0xFF, 0x01, 0xF0, 0x0E, 0x03, 0xC1, 0xFE, 0x03, 0x80, 0x7F, 0x00, 0x01, 0x07, 0x0E, 0x08, 0x11, 0x11, 0x10, 0x11, 0x09, 0x04, 0x02}, /*\"@\",32*/\n    {0x00, 0x00, 0x00, 0x00, 0x80, 0xE0, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x7C, 0x43, 0x40, 0x47, 0x7F, 0xF8, 0x80, 0x00, 0x00, 0x10, 0x18, 0x1F, 0x10, 0x00, 0x00, 0x00, 0x00, 0x13, 0x1F, 0x1C, 0x10}, /*\"A\",33*/\n    {0x20, 0xE0, 0xE0, 0x20, 0x20, 0x20, 0x20, 0x60, 0xC0, 0x80, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x10, 0x10, 0x10, 0x10, 0x18, 0x2F, 0xE7, 0x80, 0x00, 0x10, 0x1F, 0x1F, 0x10, 0x10, 0x10, 0x10, 0x10, 0x18, 0x0F, 0x07, 0x00}, /*\"B\",34*/\n    {0x00, 0x00, 0x80, 0xC0, 0x40, 0x20, 0x20, 0x20, 0x20, 0x60, 0xE0, 0x00, 0x00, 0xFC, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x07, 0x0E, 0x18, 0x10, 0x10, 0x10, 0x08, 0x04, 0x03, 0x00}, /*\"C\",35*/\n    {0x20, 0xE0, 0xE0, 0x20, 0x20, 0x20, 0x20, 0x40, 0xC0, 0x80, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFE, 0x00, 0x10, 0x1F, 0x1F, 0x10, 0x10, 0x10, 0x18, 0x08, 0x0E, 0x07, 0x01, 0x00}, /*\"D\",36*/\n    {0x20, 0xE0, 0xE0, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x60, 0x80, 0x00, 0x00, 0xFF, 0xFF, 0x10, 0x10, 0x10, 0x10, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x10, 0x1F, 0x1F, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x18, 0x06, 0x00}, /*\"E\",37*/\n    {0x20, 0xE0, 0xE0, 0x20, 0x20, 0x20, 0x20, 0x20, 0x60, 0x60, 0x80, 0x00, 0x00, 0xFF, 0xFF, 0x10, 0x10, 0x10, 0x10, 0x7C, 0x00, 0x00, 0x01, 0x00, 0x10, 0x1F, 0x1F, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, /*\"F\",38*/\n    {0x00, 0x00, 0x80, 0xC0, 0x60, 0x20, 0x20, 0x20, 0x40, 0xE0, 0x00, 0x00, 0x00, 0xFC, 0xFF, 0x01, 0x00, 0x00, 0x40, 0x40, 0xC0, 0xC1, 0x40, 0x40, 0x00, 0x01, 0x07, 0x0E, 0x18, 0x10, 0x10, 0x10, 0x0F, 0x0F, 0x00, 0x00}, /*\"G\",39*/\n    {0x20, 0xE0, 0xE0, 0x20, 0x00, 0x00, 0x00, 0x00, 0x20, 0xE0, 0xE0, 0x20, 0x00, 0xFF, 0xFF, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0xFF, 0xFF, 0x00, 0x10, 0x1F, 0x1F, 0x10, 0x00, 0x00, 0x00, 0x00, 0x10, 0x1F, 0x1F, 0x10}, /*\"H\",40*/\n    {0x00, 0x00, 0x20, 0x20, 0x20, 0xE0, 0xE0, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x10, 0x1F, 0x1F, 0x10, 0x10, 0x10, 0x00, 0x00}, /*\"I\",41*/\n    {0x00, 0x00, 0x00, 0x00, 0x20, 0x20, 0x20, 0xE0, 0xE0, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x60, 0xE0, 0x80, 0x80, 0x80, 0xC0, 0x7F, 0x3F, 0x00, 0x00, 0x00}, /*\"J\",42*/\n    {0x20, 0xE0, 0xE0, 0x20, 0x00, 0x00, 0x20, 0xA0, 0x60, 0x20, 0x20, 0x00, 0x00, 0xFF, 0xFF, 0x30, 0x18, 0x7C, 0xE3, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x10, 0x1F, 0x1F, 0x10, 0x00, 0x00, 0x01, 0x13, 0x1F, 0x1C, 0x18, 0x10}, /*\"K\",43*/\n    {0x20, 0xE0, 0xE0, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x1F, 0x1F, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x18, 0x06, 0x00}, /*\"L\",44*/\n    {0x20, 0xE0, 0xE0, 0xE0, 0x00, 0x00, 0x00, 0x00, 0xE0, 0xE0, 0xE0, 0x20, 0x00, 0xFF, 0x01, 0x3F, 0xFE, 0xC0, 0xE0, 0x1E, 0x01, 0xFF, 0xFF, 0x00, 0x10, 0x1F, 0x10, 0x00, 0x03, 0x1F, 0x03, 0x00, 0x10, 0x1F, 0x1F, 0x10}, /*\"M\",45*/\n    {0x20, 0xE0, 0xE0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0xE0, 0x20, 0x00, 0xFF, 0x00, 0x03, 0x07, 0x1C, 0x78, 0xE0, 0x80, 0x00, 0xFF, 0x00, 0x10, 0x1F, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x0F, 0x1F, 0x00}, /*\"N\",46*/\n    {0x00, 0x00, 0x80, 0xC0, 0x60, 0x20, 0x20, 0x60, 0xC0, 0x80, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFE, 0x00, 0x00, 0x01, 0x07, 0x0E, 0x18, 0x10, 0x10, 0x18, 0x0C, 0x07, 0x01, 0x00}, /*\"O\",47*/\n    {0x20, 0xE0, 0xE0, 0x20, 0x20, 0x20, 0x20, 0x20, 0x60, 0xC0, 0x80, 0x00, 0x00, 0xFF, 0xFF, 0x20, 0x20, 0x20, 0x20, 0x20, 0x30, 0x1F, 0x0F, 0x00, 0x10, 0x1F, 0x1F, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, /*\"P\",48*/\n    {0x00, 0x00, 0x80, 0xC0, 0x60, 0x20, 0x20, 0x60, 0xC0, 0x80, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFE, 0x00, 0x00, 0x01, 0x07, 0x0E, 0x11, 0x11, 0x13, 0x3C, 0x7C, 0x67, 0x21, 0x00}, /*\"Q\",49*/\n    {0x20, 0xE0, 0xE0, 0x20, 0x20, 0x20, 0x20, 0x20, 0x60, 0xC0, 0x80, 0x00, 0x00, 0xFF, 0xFF, 0x10, 0x10, 0x30, 0xF0, 0xD0, 0x08, 0x0F, 0x07, 0x00, 0x10, 0x1F, 0x1F, 0x10, 0x00, 0x00, 0x00, 0x03, 0x0F, 0x1C, 0x10, 0x10}, /*\"R\",50*/\n    {0x00, 0x80, 0xC0, 0x60, 0x20, 0x20, 0x20, 0x20, 0x40, 0x40, 0xE0, 0x00, 0x00, 0x07, 0x0F, 0x0C, 0x18, 0x18, 0x30, 0x30, 0x60, 0xE0, 0x81, 0x00, 0x00, 0x1F, 0x0C, 0x08, 0x10, 0x10, 0x10, 0x10, 0x18, 0x0F, 0x07, 0x00}, /*\"S\",51*/\n    {0x80, 0x60, 0x20, 0x20, 0x20, 0xE0, 0xE0, 0x20, 0x20, 0x20, 0x60, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x10, 0x1F, 0x1F, 0x10, 0x00, 0x00, 0x00, 0x00}, /*\"T\",52*/\n    {0x20, 0xE0, 0xE0, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0xE0, 0x20, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x07, 0x0F, 0x18, 0x10, 0x10, 0x10, 0x10, 0x10, 0x08, 0x07, 0x00}, /*\"U\",53*/\n    {0x20, 0x60, 0xE0, 0xE0, 0x20, 0x00, 0x00, 0x00, 0x20, 0xE0, 0x60, 0x20, 0x00, 0x00, 0x07, 0x7F, 0xF8, 0x80, 0x00, 0x80, 0x7C, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x1F, 0x1C, 0x07, 0x00, 0x00, 0x00, 0x00}, /*\"V\",54*/\n    {0x20, 0xE0, 0xE0, 0x20, 0x00, 0xE0, 0xE0, 0x20, 0x00, 0x20, 0xE0, 0x20, 0x00, 0x07, 0xFF, 0xF8, 0xE0, 0x1F, 0xFF, 0xFC, 0xE0, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x03, 0x1F, 0x03, 0x00, 0x01, 0x1F, 0x03, 0x00, 0x00, 0x00}, /*\"W\",55*/\n    {0x00, 0x20, 0x60, 0xE0, 0xA0, 0x00, 0x00, 0x20, 0xE0, 0x60, 0x20, 0x00, 0x00, 0x00, 0x00, 0x03, 0x8F, 0x7C, 0xF8, 0xC6, 0x01, 0x00, 0x00, 0x00, 0x00, 0x10, 0x18, 0x1E, 0x13, 0x00, 0x01, 0x17, 0x1F, 0x18, 0x10, 0x00}, /*\"X\",56*/\n    {0x20, 0x60, 0xE0, 0xE0, 0x20, 0x00, 0x00, 0x00, 0x20, 0xE0, 0x60, 0x20, 0x00, 0x00, 0x01, 0x07, 0x3E, 0xF8, 0xE0, 0x18, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x1F, 0x1F, 0x10, 0x10, 0x00, 0x00, 0x00}, /*\"Y\",57*/\n    {0x00, 0x80, 0x60, 0x20, 0x20, 0x20, 0x20, 0xA0, 0xE0, 0xE0, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xF0, 0x3E, 0x0F, 0x03, 0x00, 0x00, 0x00, 0x00, 0x10, 0x1C, 0x1F, 0x17, 0x10, 0x10, 0x10, 0x10, 0x18, 0x06, 0x00}, /*\"Z\",58*/\n    {0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0x04, 0x04, 0x04, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x40, 0x40, 0x40, 0x40, 0x40, 0x00}, /*\"[\",59*/\n    {0x00, 0x00, 0x10, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x1C, 0x60, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x0C, 0x70, 0x80, 0x00}, /*\"\\\",60*/\n    {0x00, 0x00, 0x04, 0x04, 0x04, 0x04, 0x04, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x40, 0x40, 0x40, 0x40, 0x7F, 0x00, 0x00, 0x00, 0x00}, /*\"]\",61*/\n    {0x00, 0x00, 0x00, 0x10, 0x08, 0x0C, 0x04, 0x0C, 0x08, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, /*\"^\",62*/\n    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80}, /*\"_\",63*/\n    {0x00, 0x00, 0x00, 0x04, 0x04, 0x08, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, /*\"`\",64*/\n    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x98, 0xD8, 0x44, 0x64, 0x24, 0x24, 0xFC, 0xF8, 0x00, 0x00, 0x00, 0x0F, 0x1F, 0x18, 0x10, 0x10, 0x10, 0x08, 0x1F, 0x1F, 0x10, 0x18}, /*\"a\",65*/\n    {0x00, 0x20, 0xE0, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x18, 0x08, 0x04, 0x04, 0x0C, 0xF8, 0xF0, 0x00, 0x00, 0x00, 0x1F, 0x0F, 0x18, 0x10, 0x10, 0x10, 0x18, 0x0F, 0x03, 0x00}, /*\"b\",66*/\n    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0xF8, 0x18, 0x04, 0x04, 0x04, 0x3C, 0x38, 0x00, 0x00, 0x00, 0x00, 0x03, 0x0F, 0x0C, 0x10, 0x10, 0x10, 0x10, 0x08, 0x06, 0x00, 0x00}, /*\"c\",67*/\n    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0xE0, 0xF0, 0x00, 0x00, 0x00, 0xE0, 0xF8, 0x1C, 0x04, 0x04, 0x04, 0x08, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x03, 0x0F, 0x18, 0x10, 0x10, 0x10, 0x08, 0x1F, 0x0F, 0x08, 0x00}, /*\"d\",68*/\n    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0xF8, 0x48, 0x44, 0x44, 0x44, 0x4C, 0x78, 0x70, 0x00, 0x00, 0x00, 0x03, 0x0F, 0x0C, 0x18, 0x10, 0x10, 0x10, 0x08, 0x04, 0x00}, /*\"e\",69*/\n    {0x00, 0x00, 0x00, 0x00, 0x80, 0xC0, 0x60, 0x20, 0x20, 0xE0, 0xC0, 0x00, 0x00, 0x04, 0x04, 0x04, 0xFF, 0xFF, 0x04, 0x04, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x1F, 0x1F, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00}, /*\"f\",70*/\n    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0xF8, 0x8C, 0x04, 0x04, 0x8C, 0xF8, 0x74, 0x04, 0x0C, 0x00, 0x70, 0x76, 0xCF, 0x8D, 0x8D, 0x8D, 0x89, 0xC8, 0x78, 0x70, 0x00}, /*\"g\",71*/\n    {0x00, 0x20, 0xE0, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x08, 0x04, 0x04, 0x04, 0xFC, 0xF8, 0x00, 0x00, 0x00, 0x10, 0x1F, 0x1F, 0x10, 0x00, 0x00, 0x10, 0x1F, 0x1F, 0x10, 0x00}, /*\"h\",72*/\n    {0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x04, 0x04, 0xFC, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x10, 0x1F, 0x1F, 0x10, 0x10, 0x10, 0x00, 0x00}, /*\"i\",73*/\n    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x04, 0x04, 0xFC, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xC0, 0x80, 0x80, 0xC0, 0x7F, 0x3F, 0x00, 0x00, 0x00}, /*\"j\",74*/\n    {0x00, 0x20, 0xE0, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x80, 0xC0, 0xF4, 0x1C, 0x04, 0x04, 0x00, 0x00, 0x00, 0x10, 0x1F, 0x1F, 0x11, 0x00, 0x03, 0x1F, 0x1C, 0x10, 0x10, 0x00}, /*\"k\",75*/\n    {0x00, 0x00, 0x20, 0x20, 0x20, 0xE0, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x10, 0x1F, 0x1F, 0x10, 0x10, 0x10, 0x00, 0x00}, /*\"l\",76*/\n    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xFC, 0xFC, 0x08, 0x04, 0xFC, 0xFC, 0x08, 0x04, 0xFC, 0xFC, 0x00, 0x10, 0x1F, 0x1F, 0x10, 0x00, 0x1F, 0x1F, 0x10, 0x00, 0x1F, 0x1F, 0x10}, /*\"m\",77*/\n    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xFC, 0xFC, 0x08, 0x08, 0x04, 0x04, 0xFC, 0xF8, 0x00, 0x00, 0x00, 0x10, 0x1F, 0x1F, 0x10, 0x00, 0x00, 0x10, 0x1F, 0x1F, 0x10, 0x00}, /*\"n\",78*/\n    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0xF0, 0x18, 0x0C, 0x04, 0x04, 0x0C, 0x18, 0xF0, 0xE0, 0x00, 0x00, 0x03, 0x0F, 0x0C, 0x10, 0x10, 0x10, 0x10, 0x0C, 0x0F, 0x03, 0x00}, /*\"o\",79*/\n    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xFC, 0xFC, 0x08, 0x04, 0x04, 0x04, 0x0C, 0xF8, 0xF0, 0x00, 0x00, 0x80, 0xFF, 0xFF, 0x88, 0x90, 0x10, 0x10, 0x1C, 0x0F, 0x03, 0x00}, /*\"p\",80*/\n    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0xF8, 0x1C, 0x04, 0x04, 0x04, 0x08, 0xF8, 0xFC, 0x00, 0x00, 0x00, 0x03, 0x0F, 0x18, 0x10, 0x10, 0x90, 0x88, 0xFF, 0xFF, 0x80, 0x00}, /*\"q\",81*/\n    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x04, 0x04, 0xFC, 0xFC, 0x10, 0x08, 0x04, 0x04, 0x0C, 0x0C, 0x00, 0x10, 0x10, 0x10, 0x1F, 0x1F, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00}, /*\"r\",82*/\n    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x78, 0xCC, 0xC4, 0x84, 0x84, 0x84, 0x0C, 0x1C, 0x00, 0x00, 0x00, 0x1E, 0x18, 0x10, 0x10, 0x10, 0x11, 0x19, 0x0F, 0x06, 0x00}, /*\"s\",83*/\n    {0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x04, 0x04, 0xFF, 0xFF, 0x04, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x1F, 0x10, 0x10, 0x10, 0x0C, 0x00, 0x00}, /*\"t\",84*/\n    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xFC, 0xFE, 0x00, 0x00, 0x00, 0x04, 0xFC, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x1F, 0x18, 0x10, 0x10, 0x08, 0x1F, 0x0F, 0x08, 0x00}, /*\"u\",85*/\n    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x0C, 0x3C, 0xFC, 0xC4, 0x00, 0x00, 0xC4, 0x3C, 0x0C, 0x04, 0x00, 0x00, 0x00, 0x00, 0x01, 0x0F, 0x1E, 0x0E, 0x01, 0x00, 0x00, 0x00}, /*\"v\",86*/\n    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x3C, 0xFC, 0xC4, 0x00, 0xE4, 0x7C, 0xFC, 0x84, 0x80, 0x7C, 0x04, 0x00, 0x00, 0x07, 0x1F, 0x07, 0x00, 0x00, 0x07, 0x1F, 0x07, 0x00, 0x00}, /*\"w\",87*/\n    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x04, 0x1C, 0x7C, 0xE4, 0xC0, 0x34, 0x1C, 0x04, 0x04, 0x00, 0x00, 0x10, 0x10, 0x1C, 0x16, 0x01, 0x13, 0x1F, 0x1C, 0x18, 0x10, 0x00}, /*\"x\",88*/\n    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x0C, 0x3C, 0xFC, 0xC4, 0x00, 0xC4, 0x3C, 0x04, 0x04, 0x00, 0x00, 0x00, 0xC0, 0x80, 0xC1, 0x37, 0x0E, 0x01, 0x00, 0x00, 0x00, 0x00}, /*\"y\",89*/\n    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x04, 0x04, 0xC4, 0xF4, 0x7C, 0x1C, 0x04, 0x00, 0x00, 0x00, 0x00, 0x10, 0x1C, 0x1F, 0x17, 0x11, 0x10, 0x10, 0x18, 0x0E, 0x00}, /*\"z\",90*/\n    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x0C, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x28, 0xEF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x60, 0x40, 0x00, 0x00}, /*\"{\",91*/\n    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00}, /*\"|\",92*/\n    {0x00, 0x00, 0x04, 0x0C, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xEF, 0x28, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x60, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, /*\"}\",93*/\n    {0x00, 0x18, 0x06, 0x02, 0x02, 0x04, 0x08, 0x10, 0x20, 0x20, 0x30, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\n    /*\"~\",94*/                                                                                                                                                                                                                /*\"~\",94*/\n};\n\nconst ASCIIFont afont24x12 = {\n    .h=24,\n    .w=12,\n    .chars=(unsigned char *)ascii_24x12,\n};\n\nconst uint8_t zh16x16[][36] = {\n/* 0 \u6ce2 */ {0xe6,0xb3,0xa2,0x00,0x10,0x60,0x02,0x0c,0xc0,0x00,0xf8,0x88,0x88,0x88,0xff,0x88,0x88,0xa8,0x18,0x00,0x04,0x04,0x7c,0x03,0x80,0x60,0x1f,0x80,0x43,0x2c,0x10,0x28,0x46,0x81,0x80,0x00,},\n/* 1 \u7279 */ {0xe7,0x89,0xb9,0x00,0x40,0x3c,0x10,0xff,0x10,0x10,0x40,0x48,0x48,0x48,0x7f,0x48,0xc8,0x48,0x40,0x00,0x02,0x06,0x02,0xff,0x01,0x01,0x00,0x02,0x0a,0x12,0x42,0x82,0x7f,0x02,0x02,0x00,},\n/* 2 \u5f8b */ {0xe5,0xbe,0x8b,0x00,0x00,0x10,0x88,0xc4,0x33,0x10,0x54,0x54,0x54,0xff,0x54,0x54,0x7c,0x10,0x10,0x00,0x02,0x01,0x00,0xff,0x00,0x10,0x12,0x12,0x12,0xff,0x12,0x12,0x12,0x10,0x00,0x00,},\n/* 3 \u52a8 */ {0xe5,0x8a,0xa8,0x00,0x40,0x44,0xc4,0x44,0x44,0x44,0x40,0x10,0x10,0xff,0x10,0x10,0x10,0xf0,0x00,0x00,0x10,0x3c,0x13,0x10,0x14,0xb8,0x40,0x30,0x0e,0x01,0x40,0x80,0x40,0x3f,0x00,0x00,}\n};\n\nconst Font font16x16 = {\n    .h = 16,\n    .w = 16,\n    .chars= (const uint8_t *)zh16x16,\n    .len = sizeof(zh16x16)/36,\n    .ascii = &amp;afont16x8,\n};\n\nconst uint8_t bilibiliData[] = {\n0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x86, 0x8f, 0x9f, 0xbf, 0xff, 0xfc, 0xf8, 0xf8, 0xe0, 0xe0, 0xc0, 0x80,\n0x80, 0x80, 0x80, 0x80, 0xc0, 0xe0, 0xe0, 0xf8, 0xf8, 0xfc, 0xfe, 0xbf, 0x9f, 0x8f, 0x86, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00,\n0x00, 0x00, 0x00, 0xf8, 0xfe, 0xff, 0xff, 0xff, 0xff, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f,\n0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f,\n0xff, 0xff, 0xff, 0xfe, 0xfc, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0xe0, 0xe0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf8, 0xf8, 0xf8,\n0xf8, 0xf8, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf0, 0xf0, 0xf0, 0xf0, 0xe0,\n0x20, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x03, 0x01, 0x01, 0x01, 0x01,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0xc0, 0xc0, 0x80, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01,\n0x01, 0x03, 0x03, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x07, 0x07, 0x07, 0x07, 0x07, 0x03, 0x07, 0x07, 0x07, 0x07, 0x07, 0x03, 0x01, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x07, 0x07, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f,\n0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f,\n0x1f, 0x1f, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x07, 0x07, 0x03,\n};\n\nconst Image bilibiliImg = {\n    .w = 51,\n    .h = 48,\n    .data = bilibiliData,\n};\n\nconst uint8_t copilotData[] = {\n0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x7f, 0x7f, 0x3f, 0x3f, 0x3f, 0x3f, \n0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x7f, 0x7f, 0x7f, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, \n0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x1f, 0x0f, 0xe7, 0xf3, 0xf9, 0xf9, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf0, \n0x00, 0x00, 0x80, 0x80, 0x00, 0x00, 0xf0, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf9, 0xf9, 0xf3, 0xe7, 0x0f, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, \n0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x3f, 0x3f, 0x1f, 0x00, 0x00, 0x00, 0x8f, 0x8f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x8f, \n0xcf, 0xc7, 0xe0, 0xf8, 0xf9, 0xf9, 0xf8, 0xe0, 0xc7, 0xcf, 0x8f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x8f, 0x8f, 0x00, 0x00, 0x00, 0x3f, 0x3f, 0x3f, \n0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, \n0xff, 0x07, 0x03, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0x03, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, \n0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfe, 0xfc, 0xf8, 0xf8, 0xf0, 0xf0, 0xe0, 0xe7, 0xc7, 0xcf, 0x8f, \n0x8f, 0x8f, 0x9f, 0x1f, 0x1e, 0x1e, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x1e, 0x1e, 0x1f, 0x9f, 0x8f, 0x8f, 0x8f, 0xc7, 0xc7, 0xe7, 0xe0, 0xf0, \n0xf0, 0xf8, 0xfc, 0xfc, 0xfe, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, \n0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, \n0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, \n};\n\nconst Image copilotImg = {\n    50, \n    48, \n    copilotData\n};\n</code></pre>"},{"location":"INTERFACING/OLED/oled/#oledh","title":"\"oled.h\"","text":"<pre><code>/**\n * @file oled.c\n * @brief \u6ce2\u7279\u5f8b\u52a8OLED\u9a71\u52a8(CH1116)\n * @anchor \u6ce2\u7279\u5f8b\u52a8(keysking \u535a\u54e5\u5728\u5b66\u4e60)\n * @version 1.0\n * @date 2023-08-04\n * @license MIT License\n *\n * @attention\n * \u672c\u9a71\u52a8\u5e93\u9488\u5bf9\u6ce2\u7279\u5f8b\u52a8\u00b7keysking\u7684STM32\u6559\u7a0b\u5b66\u4e60\u5957\u4ef6\u8fdb\u884c\u5f00\u53d1\n * \u5728\u5176\u4ed6\u5e73\u53f0\u6216\u9a71\u52a8\u82af\u7247\u4e0a\u4f7f\u7528\u53ef\u80fd\u9700\u8981\u8fdb\u884c\u79fb\u690d\n *\n * @note\n * \u4f7f\u7528\u6d41\u7a0b:\n * 1. STM32\u521d\u59cb\u5316IIC\u5b8c\u6210\u540e\u8c03\u7528OLED_Init()\u521d\u59cb\u5316OLED. \u6ce8\u610fSTM32\u542f\u52a8\u6bd4OLED\u4e0a\u7535\u5feb, \u53ef\u7b49\u5f8520ms\u518d\u521d\u59cb\u5316OLED\n * 2. \u8c03\u7528OLED_NewFrame()\u5f00\u59cb\u7ed8\u5236\u65b0\u7684\u4e00\u5e27\n * 3. \u8c03\u7528OLED_DrawXXX()\u7cfb\u5217\u51fd\u6570\u7ed8\u5236\u56fe\u5f62\u5230\u663e\u5b58 \u8c03\u7528OLED_Printxxx()\u7cfb\u5217\u51fd\u6570\u7ed8\u5236\u6587\u672c\u5230\u663e\u5b58\n * 4. \u8c03\u7528OLED_ShowFrame()\u5c06\u663e\u5b58\u5185\u5bb9\u663e\u793a\u5230OLED\n *\n * @note\n * \u4e3a\u4fdd\u8bc1\u4e2d\u6587\u663e\u793a\u6b63\u5e38 \u8bf7\u5c06\u7f16\u8bd1\u5668\u7684\u5b57\u7b26\u96c6\u8bbe\u7f6e\u4e3aUTF-8\n *\n */\n/**\n * @file oled.c\n * @brief BaudDance OLED Driver (CH1116)\n * @anchor BaudDance (keysking learning)\n * @version 1.0\n * @date 2023-08-04\n * @license MIT License\n *\n * @attention\n * This driver library is developed for the BoteLvdong \u00b7 keysking STM32 tutorial kit.\n * Porting may be required for other platforms or driver chips.\n *\n * @note\n * Usage Flow:\n * 1. After initializing IIC on STM32, call OLED_Init() to initialize the OLED. Note that STM32 boots faster than OLED power-on; wait for 20ms before initializing OLED.\n * 2. Call OLED_NewFrame() to start drawing a new frame.\n * 3. Call OLED_DrawXXX() series functions to draw graphics to the framebuffer and OLED_PrintXXX() series functions to draw text to the framebuffer.\n * 4. Call OLED_ShowFrame() to display the framebuffer content on the OLED.\n *\n * @note\n * To ensure proper Chinese display, set the compiler's character set to UTF-8.\n *\n */\n#ifndef _OLED_H_\n#define _OLED_H_\n\n#include \"font.h\"\n#include \"main.h\"\n#include \"string.h\"\n\ntypedef enum\n{\n  OLED_COLOR_NORMAL = 0, // \u6b63\u5e38\u6a21\u5f0f \u9ed1\u5e95\u767d\u5b57 normal mode black background white font\n  OLED_COLOR_REVERSED    // \u53cd\u8272\u6a21\u5f0f \u767d\u5e95\u9ed1\u5b57 reversed mode white background black font\n} OLED_ColorMode;\n\nvoid OLED_Init();\nvoid OLED_DisPlay_On();\nvoid OLED_DisPlay_Off();\n\nvoid OLED_NewFrame();\nvoid OLED_ShowFrame();\nvoid OLED_SetPixel(uint8_t x, uint8_t y, OLED_ColorMode color);\n\nvoid OLED_DrawLine(uint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2, OLED_ColorMode color);\nvoid OLED_DrawRectangle(uint8_t x, uint8_t y, uint8_t w, uint8_t h, OLED_ColorMode color);\nvoid OLED_DrawFilledRectangle(uint8_t x, uint8_t y, uint8_t w, uint8_t h, OLED_ColorMode color);\nvoid OLED_DrawTriangle(uint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2, uint8_t x3, uint8_t y3, OLED_ColorMode color);\nvoid OLED_DrawFilledTriangle(uint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2, uint8_t x3, uint8_t y3, OLED_ColorMode color);\nvoid OLED_DrawCircle(uint8_t x, uint8_t y, uint8_t r, OLED_ColorMode color);\nvoid OLED_DrawFilledCircle(uint8_t x, uint8_t y, uint8_t r, OLED_ColorMode color);\nvoid OLED_DrawEllipse(uint8_t x, uint8_t y, uint8_t a, uint8_t b, OLED_ColorMode color);\nvoid OLED_DrawImage(uint8_t x, uint8_t y, const Image *img, OLED_ColorMode color);\n\nvoid OLED_PrintASCIIChar(uint8_t x, uint8_t y, char ch, const ASCIIFont *font, OLED_ColorMode color);\nvoid OLED_PrintASCIIString(uint8_t x, uint8_t y, char *str, const ASCIIFont *font, OLED_ColorMode color);\nvoid OLED_PrintString(uint8_t x, uint8_t y, char *str, const Font *font, OLED_ColorMode color);\n\n#endif // _OLED_H_\n</code></pre>"},{"location":"INTERFACING/OLED/oled/#oledc","title":"\"oled.c\"","text":"<pre><code>/**\n * @file oled.c\n * @brief \u6ce2\u7279\u5f8b\u52a8OLED\u9a71\u52a8(CH1116)\n * @anchor \u6ce2\u7279\u5f8b\u52a8(keysking \u535a\u54e5\u5728\u5b66\u4e60)\n * @version 1.0\n * @date 2023-08-04\n * @license MIT License\n *\n * @attention\n * \u672c\u9a71\u52a8\u5e93\u9488\u5bf9\u6ce2\u7279\u5f8b\u52a8\u00b7keysking\u7684STM32\u6559\u7a0b\u5b66\u4e60\u5957\u4ef6\u8fdb\u884c\u5f00\u53d1\n * \u5728\u5176\u4ed6\u5e73\u53f0\u6216\u9a71\u52a8\u82af\u7247\u4e0a\u4f7f\u7528\u53ef\u80fd\u9700\u8981\u8fdb\u884c\u79fb\u690d\n *\n * @note\n * \u4f7f\u7528\u6d41\u7a0b:\n * 1. STM32\u521d\u59cb\u5316IIC\u5b8c\u6210\u540e\u8c03\u7528OLED_Init()\u521d\u59cb\u5316OLED. \u6ce8\u610fSTM32\u542f\u52a8\u6bd4OLED\u4e0a\u7535\u5feb, \u53ef\u7b49\u5f8520ms\u518d\u521d\u59cb\u5316OLED\n * 2. \u8c03\u7528OLED_NewFrame()\u5f00\u59cb\u7ed8\u5236\u65b0\u7684\u4e00\u5e27\n * 3. \u8c03\u7528OLED_DrawXXX()\u7cfb\u5217\u51fd\u6570\u7ed8\u5236\u56fe\u5f62\u5230\u663e\u5b58 \u8c03\u7528OLED_Printxxx()\u7cfb\u5217\u51fd\u6570\u7ed8\u5236\u6587\u672c\u5230\u663e\u5b58\n * 4. \u8c03\u7528OLED_ShowFrame()\u5c06\u663e\u5b58\u5185\u5bb9\u663e\u793a\u5230OLED\n *\n * @note\n * \u4e3a\u4fdd\u8bc1\u4e2d\u6587\u663e\u793a\u6b63\u5e38 \u8bf7\u5c06\u7f16\u8bd1\u5668\u7684\u5b57\u7b26\u96c6\u8bbe\u7f6e\u4e3aUTF-8\n *\n */\n/**\n * @file oled.c\n * @brief BaudDance OLED Driver (CH1116)\n * @anchor BaudDance (keysking learning)\n * @version 1.0\n * @date 2023-08-04\n * @license MIT License\n *\n * @attention\n * This driver library is developed for the BoteLvdong \u00b7 keysking STM32 tutorial kit.\n * Porting may be required for other platforms or driver chips.\n *\n * @note\n * Usage Flow:\n * 1. After initializing IIC on STM32, call OLED_Init() to initialize the OLED. Note that STM32 boots faster than OLED power-on; wait for 20ms before initializing OLED.\n * 2. Call OLED_NewFrame() to start drawing a new frame.\n * 3. Call OLED_DrawXXX() series functions to draw graphics to the framebuffer and OLED_PrintXXX() series functions to draw text to the framebuffer.\n * 4. Call OLED_ShowFrame() to display the framebuffer content on the OLED.\n *\n * @note\n * To ensure proper Chinese display, set the compiler's character set to UTF-8.\n *\n */\n#include \"oled.h\"\n#include \"i2c.h\"\n#include &lt;math.h&gt;\n#include &lt;stdlib.h&gt;\n\n// OLED\u5668\u4ef6\u5730\u5740\n#define OLED_ADDRESS 0x78\n\n// OLED\u53c2\u6570\n#define OLED_PAGE 8            // OLED\u9875\u6570\n#define OLED_ROW 8 * OLED_PAGE // OLED\u884c\u6570\n#define OLED_COLUMN 128        // OLED\u5217\u6570\n\n// \u663e\u5b58\nuint8_t OLED_GRAM[OLED_PAGE][OLED_COLUMN];\n\n// ========================== \u5e95\u5c42\u901a\u4fe1\u51fd\u6570 ==========================\n\n/**\n * @brief \u5411OLED\u53d1\u9001\u6570\u636e\u7684\u51fd\u6570\n * @param data \u8981\u53d1\u9001\u7684\u6570\u636e\n * @param len \u8981\u53d1\u9001\u7684\u6570\u636e\u957f\u5ea6\n * @return None\n * @note \u6b64\u51fd\u6570\u662f\u79fb\u690d\u672c\u9a71\u52a8\u65f6\u7684\u91cd\u8981\u51fd\u6570 \u5c06\u672c\u9a71\u52a8\u5e93\u79fb\u690d\u5230\u5176\u4ed6\u5e73\u53f0\u65f6\u5e94\u6839\u636e\u5b9e\u9645\u60c5\u51b5\u4fee\u6539\u6b64\u51fd\u6570\n */\nvoid OLED_Send(uint8_t *data, uint8_t len)\n{\n  HAL_I2C_Master_Transmit(&amp;hi2c1, OLED_ADDRESS, data, len, HAL_MAX_DELAY);\n}\n\n/**\n * @brief \u5411OLED\u53d1\u9001\u6307\u4ee4\n */\nvoid OLED_SendCmd(uint8_t cmd)\n{\n  static uint8_t sendBuffer[2] = {0};\n  sendBuffer[1] = cmd;\n  OLED_Send(sendBuffer, 2);\n}\n\n// ========================== OLED\u9a71\u52a8\u51fd\u6570 ==========================\n\n/**\n * @brief \u521d\u59cb\u5316OLED\n * @note \u6b64\u51fd\u6570\u662f\u79fb\u690d\u672c\u9a71\u52a8\u65f6\u7684\u91cd\u8981\u51fd\u6570 \u5c06\u672c\u9a71\u52a8\u5e93\u79fb\u690d\u5230\u5176\u4ed6\u9a71\u52a8\u82af\u7247\u65f6\u5e94\u6839\u636e\u5b9e\u9645\u60c5\u51b5\u4fee\u6539\u6b64\u51fd\u6570\n */\nvoid OLED_Init()\n{\n\n  OLED_SendCmd(0xAE); /*\u5173\u95ed\u663e\u793a display off*/\n\n  OLED_SendCmd(0x02); /*\u8bbe\u7f6e\u5217\u8d77\u59cb\u5730\u5740 set lower column address*/\n  OLED_SendCmd(0x10); /*\u8bbe\u7f6e\u5217\u7ed3\u675f\u5730\u5740 set higher column address*/\n\n  OLED_SendCmd(0x40); /*\u8bbe\u7f6e\u8d77\u59cb\u884c set display start line*/\n\n  OLED_SendCmd(0xB0); /*\u8bbe\u7f6e\u9875\u5730\u5740 set page address*/\n\n  OLED_SendCmd(0x81); /*\u8bbe\u7f6e\u5bf9\u6bd4\u5ea6 contract control*/\n  OLED_SendCmd(0xCF); /*128*/\n\n  OLED_SendCmd(0xA1); /*\u8bbe\u7f6e\u5206\u6bb5\u91cd\u6620\u5c04 \u4ece\u53f3\u5230\u5de6 set segment remap*/\n\n  OLED_SendCmd(0xA6); /*\u6b63\u5411\u663e\u793a normal / reverse*/\n\n  OLED_SendCmd(0xA8); /*\u591a\u8def\u590d\u7528\u7387 multiplex ratio*/\n  OLED_SendCmd(0x3F); /*duty = 1/64*/\n\n  OLED_SendCmd(0xAD); /*\u8bbe\u7f6e\u542f\u52a8\u7535\u8377\u6cf5 set charge pump enable*/\n  OLED_SendCmd(0x8B); /*\u542f\u52a8DC-DC */\n\n  OLED_SendCmd(0x33); /*\u8bbe\u7f6e\u6cf5\u7535\u538b set VPP 10V */\n\n  OLED_SendCmd(0xC8); /*\u8bbe\u7f6e\u8f93\u51fa\u626b\u63cf\u65b9\u5411 COM[N-1]\u5230COM[0] Com scan direction*/\n\n  OLED_SendCmd(0xD3); /*\u8bbe\u7f6e\u663e\u793a\u504f\u79fb set display offset*/\n  OLED_SendCmd(0x00); /* 0x00 */\n\n  OLED_SendCmd(0xD5); /*\u8bbe\u7f6e\u5185\u90e8\u65f6\u949f\u9891\u7387 set osc frequency*/\n  OLED_SendCmd(0xC0);\n\n  OLED_SendCmd(0xD9); /*\u8bbe\u7f6e\u653e\u7535/\u9884\u5145\u7535\u65f6\u95f4 set pre-charge period*/\n  OLED_SendCmd(0x1F); /*0x22*/\n\n  OLED_SendCmd(0xDA); /*\u8bbe\u7f6e\u5f15\u811a\u5e03\u5c40 set COM pins*/\n  OLED_SendCmd(0x12);\n\n  OLED_SendCmd(0xDB); /*\u8bbe\u7f6e\u7535\u5e73 set vcomh*/\n  OLED_SendCmd(0x40);\n\n  OLED_NewFrame();\n  OLED_ShowFrame();\n\n  OLED_SendCmd(0xAF); /*\u5f00\u542f\u663e\u793a display ON*/\n}\n\n/**\n * @brief \u5f00\u542fOLED\u663e\u793a\n */\nvoid OLED_DisPlay_On()\n{\n  OLED_SendCmd(0x8D); // \u7535\u8377\u6cf5\u4f7f\u80fd\n  OLED_SendCmd(0x14); // \u5f00\u542f\u7535\u8377\u6cf5\n  OLED_SendCmd(0xAF); // \u70b9\u4eae\u5c4f\u5e55\n}\n\n/**\n * @brief \u5173\u95edOLED\u663e\u793a\n */\nvoid OLED_DisPlay_Off()\n{\n  OLED_SendCmd(0x8D); // \u7535\u8377\u6cf5\u4f7f\u80fd\n  OLED_SendCmd(0x10); // \u5173\u95ed\u7535\u8377\u6cf5\n  OLED_SendCmd(0xAE); // \u5173\u95ed\u5c4f\u5e55\n}\n\n/**\n * @brief \u8bbe\u7f6e\u989c\u8272\u6a21\u5f0f \u9ed1\u5e95\u767d\u5b57\u6216\u767d\u5e95\u9ed1\u5b57\n * @param ColorMode \u989c\u8272\u6a21\u5f0fCOLOR_NORMAL/COLOR_REVERSED\n * @note \u6b64\u51fd\u6570\u76f4\u63a5\u8bbe\u7f6e\u5c4f\u5e55\u7684\u989c\u8272\u6a21\u5f0f\n */\nvoid OLED_SetColorMode(OLED_ColorMode mode)\n{\n  if (mode == OLED_COLOR_NORMAL)\n  {\n    OLED_SendCmd(0xA6); // \u6b63\u5e38\u663e\u793a\n  }\n  if (mode == OLED_COLOR_REVERSED)\n  {\n    OLED_SendCmd(0xA7); // \u53cd\u8272\u663e\u793a\n  }\n}\n\n// ========================== \u663e\u5b58\u64cd\u4f5c\u51fd\u6570 ==========================\n\n/**\n * @brief \u6e05\u7a7a\u663e\u5b58 \u7ed8\u5236\u65b0\u7684\u4e00\u5e27\n */\nvoid OLED_NewFrame()\n{\n  memset(OLED_GRAM, 0, sizeof(OLED_GRAM));\n}\n\n/**\n * @brief \u5c06\u5f53\u524d\u663e\u5b58\u663e\u793a\u5230\u5c4f\u5e55\u4e0a\n * @note \u6b64\u51fd\u6570\u662f\u79fb\u690d\u672c\u9a71\u52a8\u65f6\u7684\u91cd\u8981\u51fd\u6570 \u5c06\u672c\u9a71\u52a8\u5e93\u79fb\u690d\u5230\u5176\u4ed6\u9a71\u52a8\u82af\u7247\u65f6\u5e94\u6839\u636e\u5b9e\u9645\u60c5\u51b5\u4fee\u6539\u6b64\u51fd\u6570\n */\nvoid OLED_ShowFrame()\n{\n  static uint8_t sendBuffer[OLED_COLUMN + 1];\n  sendBuffer[0] = 0x40;\n  for (uint8_t i = 0; i &lt; OLED_PAGE; i++)\n  {\n    OLED_SendCmd(0xB0 + i); // \u8bbe\u7f6e\u9875\u5730\u5740\n    OLED_SendCmd(0x02);     // \u8bbe\u7f6e\u5217\u5730\u5740\u4f4e4\u4f4d\n    OLED_SendCmd(0x10);     // \u8bbe\u7f6e\u5217\u5730\u5740\u9ad84\u4f4d\n    memcpy(sendBuffer + 1, OLED_GRAM[i], OLED_COLUMN);\n    OLED_Send(sendBuffer, OLED_COLUMN + 1);\n  }\n}\n\n/**\n * @brief \u8bbe\u7f6e\u4e00\u4e2a\u50cf\u7d20\u70b9\n * @param x \u6a2a\u5750\u6807\n * @param y \u7eb5\u5750\u6807\n * @param color \u989c\u8272\n */\nvoid OLED_SetPixel(uint8_t x, uint8_t y, OLED_ColorMode color)\n{\n  if (x &gt;= OLED_COLUMN || y &gt;= OLED_ROW)\n    return;\n  if (!color)\n  {\n    OLED_GRAM[y / 8][x] |= 1 &lt;&lt; (y % 8);\n  }\n  else\n  {\n    OLED_GRAM[y / 8][x] &amp;= ~(1 &lt;&lt; (y % 8));\n  }\n}\n\n/**\n * @brief \u8bbe\u7f6e\u663e\u5b58\u4e2d\u4e00\u5b57\u8282\u6570\u636e\u7684\u67d0\u51e0\u4f4d\n * @param page \u9875\u5730\u5740\n * @param column \u5217\u5730\u5740\n * @param data \u6570\u636e\n * @param start \u8d77\u59cb\u4f4d\n * @param end \u7ed3\u675f\u4f4d\n * @param color \u989c\u8272\n * @note \u6b64\u51fd\u6570\u5c06\u663e\u5b58\u4e2d\u7684\u67d0\u4e00\u5b57\u8282\u7684\u7b2cstart\u4f4d\u5230\u7b2cend\u4f4d\u8bbe\u7f6e\u4e3a\u4e0edata\u76f8\u540c\n * @note start\u548cend\u7684\u8303\u56f4\u4e3a0-7, start\u5fc5\u987b\u5c0f\u4e8e\u7b49\u4e8eend\n * @note \u6b64\u51fd\u6570\u4e0eOLED_SetByte_Fine\u7684\u533a\u522b\u5728\u4e8e\u6b64\u51fd\u6570\u53ea\u80fd\u8bbe\u7f6e\u663e\u5b58\u4e2d\u7684\u67d0\u4e00\u771f\u5b9e\u5b57\u8282\n */\nvoid OLED_SetByte_Fine(uint8_t page, uint8_t column, uint8_t data, uint8_t start, uint8_t end, OLED_ColorMode color)\n{\n  static uint8_t temp;\n  if (page &gt;= OLED_PAGE || column &gt;= OLED_COLUMN)\n    return;\n  if (color)\n    data = ~data;\n\n  temp = data | (0xff &lt;&lt; (end + 1)) | (0xff &gt;&gt; (8 - start));\n  OLED_GRAM[page][column] &amp;= temp;\n  temp = data &amp; ~(0xff &lt;&lt; (end + 1)) &amp; ~(0xff &gt;&gt; (8 - start));\n  OLED_GRAM[page][column] |= temp;\n  // \u4f7f\u7528OLED_SetPixel\u5b9e\u73b0\n  // for (uint8_t i = start; i &lt;= end; i++) {\n  //   OLED_SetPixel(column, page * 8 + i, !((data &gt;&gt; i) &amp; 0x01));\n  // }\n}\n\n/**\n * @brief \u8bbe\u7f6e\u663e\u5b58\u4e2d\u7684\u4e00\u5b57\u8282\u6570\u636e\n * @param page \u9875\u5730\u5740\n * @param column \u5217\u5730\u5740\n * @param data \u6570\u636e\n * @param color \u989c\u8272\n * @note \u6b64\u51fd\u6570\u5c06\u663e\u5b58\u4e2d\u7684\u67d0\u4e00\u5b57\u8282\u8bbe\u7f6e\u4e3adata\u7684\u503c\n */\nvoid OLED_SetByte(uint8_t page, uint8_t column, uint8_t data, OLED_ColorMode color)\n{\n  if (page &gt;= OLED_PAGE || column &gt;= OLED_COLUMN)\n    return;\n  if (color)\n    data = ~data;\n  OLED_GRAM[page][column] = data;\n}\n\n/**\n * @brief \u8bbe\u7f6e\u663e\u5b58\u4e2d\u7684\u4e00\u5b57\u8282\u6570\u636e\u7684\u67d0\u51e0\u4f4d\n * @param x \u6a2a\u5750\u6807\n * @param y \u7eb5\u5750\u6807\n * @param data \u6570\u636e\n * @param len \u4f4d\u6570\n * @param color \u989c\u8272\n * @note \u6b64\u51fd\u6570\u5c06\u663e\u5b58\u4e2d\u4ece(x,y)\u5f00\u59cb\u5411\u4e0b\u6570len\u4f4d\u8bbe\u7f6e\u4e3a\u4e0edata\u76f8\u540c\n * @note len\u7684\u8303\u56f4\u4e3a1-8\n * @note \u6b64\u51fd\u6570\u4e0eOLED_SetByte_Fine\u7684\u533a\u522b\u5728\u4e8e\u6b64\u51fd\u6570\u7684\u6a2a\u5750\u6807\u548c\u7eb5\u5750\u6807\u662f\u4ee5\u50cf\u7d20\u4e3a\u5355\u4f4d\u7684, \u53ef\u80fd\u51fa\u73b0\u8de8\u4e24\u4e2a\u771f\u5b9e\u5b57\u8282\u7684\u60c5\u51b5(\u8de8\u9875)\n */\nvoid OLED_SetBits_Fine(uint8_t x, uint8_t y, uint8_t data, uint8_t len, OLED_ColorMode color)\n{\n  uint8_t page = y / 8;\n  uint8_t bit = y % 8;\n  if (bit + len &gt; 8)\n  {\n    OLED_SetByte_Fine(page, x, data &lt;&lt; bit, bit, 7, color);\n    OLED_SetByte_Fine(page + 1, x, data &gt;&gt; (8 - bit), 0, len + bit - 1 - 8, color);\n  }\n  else\n  {\n    OLED_SetByte_Fine(page, x, data &lt;&lt; bit, bit, bit + len - 1, color);\n  }\n  // \u4f7f\u7528OLED_SetPixel\u5b9e\u73b0\n  // for (uint8_t i = 0; i &lt; len; i++) {\n  //   OLED_SetPixel(x, y + i, !((data &gt;&gt; i) &amp; 0x01));\n  // }\n}\n\n/**\n * @brief \u8bbe\u7f6e\u663e\u5b58\u4e2d\u4e00\u5b57\u8282\u957f\u5ea6\u7684\u6570\u636e\n * @param x \u6a2a\u5750\u6807\n * @param y \u7eb5\u5750\u6807\n * @param data \u6570\u636e\n * @param color \u989c\u8272\n * @note \u6b64\u51fd\u6570\u5c06\u663e\u5b58\u4e2d\u4ece(x,y)\u5f00\u59cb\u5411\u4e0b\u65708\u4f4d\u8bbe\u7f6e\u4e3a\u4e0edata\u76f8\u540c\n * @note \u6b64\u51fd\u6570\u4e0eOLED_SetByte\u7684\u533a\u522b\u5728\u4e8e\u6b64\u51fd\u6570\u7684\u6a2a\u5750\u6807\u548c\u7eb5\u5750\u6807\u662f\u4ee5\u50cf\u7d20\u4e3a\u5355\u4f4d\u7684, \u53ef\u80fd\u51fa\u73b0\u8de8\u4e24\u4e2a\u771f\u5b9e\u5b57\u8282\u7684\u60c5\u51b5(\u8de8\u9875)\n */\nvoid OLED_SetBits(uint8_t x, uint8_t y, uint8_t data, OLED_ColorMode color)\n{\n  uint8_t page = y / 8;\n  uint8_t bit = y % 8;\n  OLED_SetByte_Fine(page, x, data &lt;&lt; bit, bit, 7, color);\n  if (bit)\n  {\n    OLED_SetByte_Fine(page + 1, x, data &gt;&gt; (8 - bit), 0, bit - 1, color);\n  }\n}\n\n/**\n * @brief \u8bbe\u7f6e\u4e00\u5757\u663e\u5b58\u533a\u57df\n * @param x \u8d77\u59cb\u6a2a\u5750\u6807\n * @param y \u8d77\u59cb\u7eb5\u5750\u6807\n * @param data \u6570\u636e\u7684\u8d77\u59cb\u5730\u5740\n * @param w \u5bbd\u5ea6\n * @param h \u9ad8\u5ea6\n * @param color \u989c\u8272\n * @note \u6b64\u51fd\u6570\u5c06\u663e\u5b58\u4e2d\u4ece(x,y)\u5f00\u59cb\u7684w*h\u4e2a\u50cf\u7d20\u8bbe\u7f6e\u4e3adata\u4e2d\u7684\u6570\u636e\n * @note data\u7684\u6570\u636e\u5e94\u8be5\u91c7\u7528\u5217\u884c\u5f0f\u6392\u5217\n */\nvoid OLED_SetBlock(uint8_t x, uint8_t y, const uint8_t *data, uint8_t w, uint8_t h, OLED_ColorMode color)\n{\n  uint8_t fullRow = h / 8; // \u5b8c\u6574\u7684\u884c\u6570\n  uint8_t partBit = h % 8; // \u4e0d\u5b8c\u6574\u7684\u5b57\u8282\u4e2d\u7684\u6709\u6548\u4f4d\u6570\n  for (uint8_t i = 0; i &lt; w; i++)\n  {\n    for (uint8_t j = 0; j &lt; fullRow; j++)\n    {\n      OLED_SetBits(x + i, y + j * 8, data[i + j * w], color);\n    }\n  }\n  if (partBit)\n  {\n    uint16_t fullNum = w * fullRow; // \u5b8c\u6574\u7684\u5b57\u8282\u6570\n    for (uint8_t i = 0; i &lt; w; i++)\n    {\n      OLED_SetBits_Fine(x + i, y + (fullRow * 8), data[fullNum + i], partBit, color);\n    }\n  }\n  // \u4f7f\u7528OLED_SetPixel\u5b9e\u73b0\n  // for (uint8_t i = 0; i &lt; w; i++) {\n  //   for (uint8_t j = 0; j &lt; h; j++) {\n  //     for (uint8_t k = 0; k &lt; 8; k++) {\n  //       if (j * 8 + k &gt;= h) break; // \u9632\u6b62\u8d8a\u754c(\u4e0d\u5b8c\u6574\u7684\u5b57\u8282\n  //       OLED_SetPixel(x + i, y + j * 8 + k, !((data[i + j * w] &gt;&gt; k) &amp; 0x01));\n  //     }\n  //   }\n  // }\n}\n\n// ========================== \u56fe\u5f62\u7ed8\u5236\u51fd\u6570 ==========================\n/**\n * @brief \u7ed8\u5236\u4e00\u6761\u7ebf\u6bb5\n * @param x1 \u8d77\u59cb\u70b9\u6a2a\u5750\u6807\n * @param y1 \u8d77\u59cb\u70b9\u7eb5\u5750\u6807\n * @param x2 \u7ec8\u6b62\u70b9\u6a2a\u5750\u6807\n * @param y2 \u7ec8\u6b62\u70b9\u7eb5\u5750\u6807\n * @param color \u989c\u8272\n * @note \u6b64\u51fd\u6570\u4f7f\u7528Bresenham\u7b97\u6cd5\u7ed8\u5236\u7ebf\u6bb5\n */\nvoid OLED_DrawLine(uint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2, OLED_ColorMode color)\n{\n  static uint8_t temp = 0;\n  if (x1 == x2)\n  {\n    if (y1 &gt; y2)\n    {\n      temp = y1;\n      y1 = y2;\n      y2 = temp;\n    }\n    for (uint8_t y = y1; y &lt;= y2; y++)\n    {\n      OLED_SetPixel(x1, y, color);\n    }\n  }\n  else if (y1 == y2)\n  {\n    if (x1 &gt; x2)\n    {\n      temp = x1;\n      x1 = x2;\n      x2 = temp;\n    }\n    for (uint8_t x = x1; x &lt;= x2; x++)\n    {\n      OLED_SetPixel(x, y1, color);\n    }\n  }\n  else\n  {\n    // Bresenham\u76f4\u7ebf\u7b97\u6cd5\n    int16_t dx = x2 - x1;\n    int16_t dy = y2 - y1;\n    int16_t ux = ((dx &gt; 0) &lt;&lt; 1) - 1;\n    int16_t uy = ((dy &gt; 0) &lt;&lt; 1) - 1;\n    int16_t x = x1, y = y1, eps = 0;\n    dx = abs(dx);\n    dy = abs(dy);\n    if (dx &gt; dy)\n    {\n      for (x = x1; x != x2; x += ux)\n      {\n        OLED_SetPixel(x, y, color);\n        eps += dy;\n        if ((eps &lt;&lt; 1) &gt;= dx)\n        {\n          y += uy;\n          eps -= dx;\n        }\n      }\n    }\n    else\n    {\n      for (y = y1; y != y2; y += uy)\n      {\n        OLED_SetPixel(x, y, color);\n        eps += dx;\n        if ((eps &lt;&lt; 1) &gt;= dy)\n        {\n          x += ux;\n          eps -= dy;\n        }\n      }\n    }\n  }\n}\n\n/**\n * @brief \u7ed8\u5236\u4e00\u4e2a\u77e9\u5f62\n * @param x \u8d77\u59cb\u70b9\u6a2a\u5750\u6807\n * @param y \u8d77\u59cb\u70b9\u7eb5\u5750\u6807\n * @param w \u77e9\u5f62\u5bbd\u5ea6\n * @param h \u77e9\u5f62\u9ad8\u5ea6\n * @param color \u989c\u8272\n */\nvoid OLED_DrawRectangle(uint8_t x, uint8_t y, uint8_t w, uint8_t h, OLED_ColorMode color)\n{\n  OLED_DrawLine(x, y, x + w, y, color);\n  OLED_DrawLine(x, y + h, x + w, y + h, color);\n  OLED_DrawLine(x, y, x, y + h, color);\n  OLED_DrawLine(x + w, y, x + w, y + h, color);\n}\n\n/**\n * @brief \u7ed8\u5236\u4e00\u4e2a\u586b\u5145\u77e9\u5f62\n * @param x \u8d77\u59cb\u70b9\u6a2a\u5750\u6807\n * @param y \u8d77\u59cb\u70b9\u7eb5\u5750\u6807\n * @param w \u77e9\u5f62\u5bbd\u5ea6\n * @param h \u77e9\u5f62\u9ad8\u5ea6\n * @param color \u989c\u8272\n */\nvoid OLED_DrawFilledRectangle(uint8_t x, uint8_t y, uint8_t w, uint8_t h, OLED_ColorMode color)\n{\n  for (uint8_t i = 0; i &lt; h; i++)\n  {\n    OLED_DrawLine(x, y + i, x + w - 1, y + i, color);\n  }\n}\n\n/**\n * @brief \u7ed8\u5236\u4e00\u4e2a\u4e09\u89d2\u5f62\n * @param x1 \u7b2c\u4e00\u4e2a\u70b9\u6a2a\u5750\u6807\n * @param y1 \u7b2c\u4e00\u4e2a\u70b9\u7eb5\u5750\u6807\n * @param x2 \u7b2c\u4e8c\u4e2a\u70b9\u6a2a\u5750\u6807\n * @param y2 \u7b2c\u4e8c\u4e2a\u70b9\u7eb5\u5750\u6807\n * @param x3 \u7b2c\u4e09\u4e2a\u70b9\u6a2a\u5750\u6807\n * @param y3 \u7b2c\u4e09\u4e2a\u70b9\u7eb5\u5750\u6807\n * @param color \u989c\u8272\n */\nvoid OLED_DrawTriangle(uint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2, uint8_t x3, uint8_t y3, OLED_ColorMode color)\n{\n  OLED_DrawLine(x1, y1, x2, y2, color);\n  OLED_DrawLine(x2, y2, x3, y3, color);\n  OLED_DrawLine(x3, y3, x1, y1, color);\n}\n\n/**\n * @brief \u7ed8\u5236\u4e00\u4e2a\u586b\u5145\u4e09\u89d2\u5f62\n * @param x1 \u7b2c\u4e00\u4e2a\u70b9\u6a2a\u5750\u6807\n * @param y1 \u7b2c\u4e00\u4e2a\u70b9\u7eb5\u5750\u6807\n * @param x2 \u7b2c\u4e8c\u4e2a\u70b9\u6a2a\u5750\u6807\n * @param y2 \u7b2c\u4e8c\u4e2a\u70b9\u7eb5\u5750\u6807\n * @param x3 \u7b2c\u4e09\u4e2a\u70b9\u6a2a\u5750\u6807\n * @param y3 \u7b2c\u4e09\u4e2a\u70b9\u7eb5\u5750\u6807\n * @param color \u989c\u8272\n */\nvoid OLED_DrawFilledTriangle(uint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2, uint8_t x3, uint8_t y3, OLED_ColorMode color)\n{\n  uint8_t a = 0, b = 0, y = 0, last = 0;\n  if (y1 &gt; y2)\n  {\n    a = y2;\n    b = y1;\n  }\n  else\n  {\n    a = y1;\n    b = y2;\n  }\n  y = a;\n  for (; y &lt;= b; y++)\n  {\n    if (y &lt;= y3)\n    {\n      OLED_DrawLine(x1 + (y - y1) * (x2 - x1) / (y2 - y1), y, x1 + (y - y1) * (x3 - x1) / (y3 - y1), y, color);\n    }\n    else\n    {\n      last = y - 1;\n      break;\n    }\n  }\n  for (; y &lt;= b; y++)\n  {\n    OLED_DrawLine(x2 + (y - y2) * (x3 - x2) / (y3 - y2), y, x1 + (y - last) * (x3 - x1) / (y3 - last), y, color);\n  }\n}\n\n/**\n * @brief \u7ed8\u5236\u4e00\u4e2a\u5706\n * @param x \u5706\u5fc3\u6a2a\u5750\u6807\n * @param y \u5706\u5fc3\u7eb5\u5750\u6807\n * @param r \u5706\u534a\u5f84\n * @param color \u989c\u8272\n * @note \u6b64\u51fd\u6570\u4f7f\u7528Bresenham\u7b97\u6cd5\u7ed8\u5236\u5706\n */\nvoid OLED_DrawCircle(uint8_t x, uint8_t y, uint8_t r, OLED_ColorMode color)\n{\n  int16_t a = 0, b = r, di = 3 - (r &lt;&lt; 1);\n  while (a &lt;= b)\n  {\n    OLED_SetPixel(x - b, y - a, color);\n    OLED_SetPixel(x + b, y - a, color);\n    OLED_SetPixel(x - a, y + b, color);\n    OLED_SetPixel(x - b, y - a, color);\n    OLED_SetPixel(x - a, y - b, color);\n    OLED_SetPixel(x + b, y + a, color);\n    OLED_SetPixel(x + a, y - b, color);\n    OLED_SetPixel(x + a, y + b, color);\n    OLED_SetPixel(x - b, y + a, color);\n    a++;\n    if (di &lt; 0)\n    {\n      di += 4 * a + 6;\n    }\n    else\n    {\n      di += 10 + 4 * (a - b);\n      b--;\n    }\n    OLED_SetPixel(x + a, y + b, color);\n  }\n}\n\n/**\n * @brief \u7ed8\u5236\u4e00\u4e2a\u586b\u5145\u5706\n * @param x \u5706\u5fc3\u6a2a\u5750\u6807\n * @param y \u5706\u5fc3\u7eb5\u5750\u6807\n * @param r \u5706\u534a\u5f84\n * @param color \u989c\u8272\n * @note \u6b64\u51fd\u6570\u4f7f\u7528Bresenham\u7b97\u6cd5\u7ed8\u5236\u5706\n */\nvoid OLED_DrawFilledCircle(uint8_t x, uint8_t y, uint8_t r, OLED_ColorMode color)\n{\n  int16_t a = 0, b = r, di = 3 - (r &lt;&lt; 1);\n  while (a &lt;= b)\n  {\n    for (int16_t i = x - b; i &lt;= x + b; i++)\n    {\n      OLED_SetPixel(i, y + a, color);\n      OLED_SetPixel(i, y - a, color);\n    }\n    for (int16_t i = x - a; i &lt;= x + a; i++)\n    {\n      OLED_SetPixel(i, y + b, color);\n      OLED_SetPixel(i, y - b, color);\n    }\n    a++;\n    if (di &lt; 0)\n    {\n      di += 4 * a + 6;\n    }\n    else\n    {\n      di += 10 + 4 * (a - b);\n      b--;\n    }\n  }\n}\n\n/**\n * @brief \u7ed8\u5236\u4e00\u4e2a\u692d\u5706\n * @param x \u692d\u5706\u4e2d\u5fc3\u6a2a\u5750\u6807\n * @param y \u692d\u5706\u4e2d\u5fc3\u7eb5\u5750\u6807\n * @param a \u692d\u5706\u957f\u8f74\n * @param b \u692d\u5706\u77ed\u8f74\n */\nvoid OLED_DrawEllipse(uint8_t x, uint8_t y, uint8_t a, uint8_t b, OLED_ColorMode color)\n{\n  int xpos = 0, ypos = b;\n  int a2 = a * a, b2 = b * b;\n  int d = b2 + a2 * (0.25 - b);\n  while (a2 * ypos &gt; b2 * xpos)\n  {\n    OLED_SetPixel(x + xpos, y + ypos, color);\n    OLED_SetPixel(x - xpos, y + ypos, color);\n    OLED_SetPixel(x + xpos, y - ypos, color);\n    OLED_SetPixel(x - xpos, y - ypos, color);\n    if (d &lt; 0)\n    {\n      d = d + b2 * ((xpos &lt;&lt; 1) + 3);\n      xpos += 1;\n    }\n    else\n    {\n      d = d + b2 * ((xpos &lt;&lt; 1) + 3) + a2 * (-(ypos &lt;&lt; 1) + 2);\n      xpos += 1, ypos -= 1;\n    }\n  }\n  d = b2 * (xpos + 0.5) * (xpos + 0.5) + a2 * (ypos - 1) * (ypos - 1) - a2 * b2;\n  while (ypos &gt; 0)\n  {\n    OLED_SetPixel(x + xpos, y + ypos, color);\n    OLED_SetPixel(x - xpos, y + ypos, color);\n    OLED_SetPixel(x + xpos, y - ypos, color);\n    OLED_SetPixel(x - xpos, y - ypos, color);\n    if (d &lt; 0)\n    {\n      d = d + b2 * ((xpos &lt;&lt; 1) + 2) + a2 * (-(ypos &lt;&lt; 1) + 3);\n      xpos += 1, ypos -= 1;\n    }\n    else\n    {\n      d = d + a2 * (-(ypos &lt;&lt; 1) + 3);\n      ypos -= 1;\n    }\n  }\n}\n\n/**\n * @brief \u7ed8\u5236\u4e00\u5f20\u56fe\u7247\n * @param x \u8d77\u59cb\u70b9\u6a2a\u5750\u6807\n * @param y \u8d77\u59cb\u70b9\u7eb5\u5750\u6807\n * @param img \u56fe\u7247\n * @param color \u989c\u8272\n */\nvoid OLED_DrawImage(uint8_t x, uint8_t y, const Image *img, OLED_ColorMode color)\n{\n  OLED_SetBlock(x, y, img-&gt;data, img-&gt;w, img-&gt;h, color);\n}\n\n// ================================ \u6587\u5b57\u7ed8\u5236 ================================\n\n/**\n * @brief \u7ed8\u5236\u4e00\u4e2aASCII\u5b57\u7b26\n * @param x \u8d77\u59cb\u70b9\u6a2a\u5750\u6807\n * @param y \u8d77\u59cb\u70b9\u7eb5\u5750\u6807\n * @param ch \u5b57\u7b26\n * @param font \u5b57\u4f53\n * @param color \u989c\u8272\n */\nvoid OLED_PrintASCIIChar(uint8_t x, uint8_t y, char ch, const ASCIIFont *font, OLED_ColorMode color)\n{\n  OLED_SetBlock(x, y, font-&gt;chars + (ch - ' ') * (((font-&gt;h + 7) / 8) * font-&gt;w), font-&gt;w, font-&gt;h, color);\n}\n\n/**\n * @brief \u7ed8\u5236\u4e00\u4e2aASCII\u5b57\u7b26\u4e32\n * @param x \u8d77\u59cb\u70b9\u6a2a\u5750\u6807\n * @param y \u8d77\u59cb\u70b9\u7eb5\u5750\u6807\n * @param str \u5b57\u7b26\u4e32\n * @param font \u5b57\u4f53\n * @param color \u989c\u8272\n */\nvoid OLED_PrintASCIIString(uint8_t x, uint8_t y, char *str, const ASCIIFont *font, OLED_ColorMode color)\n{\n  uint8_t x0 = x;\n  while (*str)\n  {\n    OLED_PrintASCIIChar(x0, y, *str, font, color);\n    x0 += font-&gt;w;\n    str++;\n  }\n}\n\n/**\n * @brief \u83b7\u53d6UTF-8\u7f16\u7801\u7684\u5b57\u7b26\u957f\u5ea6\n */\nuint8_t _OLED_GetUTF8Len(char *string)\n{\n  if ((string[0] &amp; 0x80) == 0x00)\n  {\n    return 1;\n  }\n  else if ((string[0] &amp; 0xE0) == 0xC0)\n  {\n    return 2;\n  }\n  else if ((string[0] &amp; 0xF0) == 0xE0)\n  {\n    return 3;\n  }\n  else if ((string[0] &amp; 0xF8) == 0xF0)\n  {\n    return 4;\n  }\n  return 0;\n}\n\n/**\n * @brief \u7ed8\u5236\u5b57\u7b26\u4e32\n * @param x \u8d77\u59cb\u70b9\u6a2a\u5750\u6807\n * @param y \u8d77\u59cb\u70b9\u7eb5\u5750\u6807\n * @param str \u5b57\u7b26\u4e32\n * @param font \u5b57\u4f53\n * @param color \u989c\u8272\n *\n * @note \u4e3a\u4fdd\u8bc1\u5b57\u7b26\u4e32\u4e2d\u7684\u4e2d\u6587\u4f1a\u88ab\u81ea\u52a8\u8bc6\u522b\u5e76\u7ed8\u5236, \u9700:\n * 1. \u7f16\u8bd1\u5668\u5b57\u7b26\u96c6\u8bbe\u7f6e\u4e3aUTF-8\n * 2. \u4f7f\u7528\u6ce2\u7279\u5f8b\u52a8LED\u53d6\u6a21\u5de5\u5177\u751f\u6210\u5b57\u6a21(https://led.baud-dance.com)\n */\n/**\n * @brief \u7ed8\u5236\u5b57\u7b26\u4e32\n * @param x \u8d77\u59cb\u70b9\u6a2a\u5750\u6807\n * @param y \u8d77\u59cb\u70b9\u7eb5\u5750\u6807\n * @param str \u5b57\u7b26\u4e32\n * @param font \u5b57\u4f53\n * @param color \u989c\u8272\n *\n * @note \u4e3a\u4fdd\u8bc1\u5b57\u7b26\u4e32\u4e2d\u7684\u4e2d\u6587\u4f1a\u88ab\u81ea\u52a8\u8bc6\u522b\u5e76\u7ed8\u5236, \u9700:\n * 1. \u7f16\u8bd1\u5668\u5b57\u7b26\u96c6\u8bbe\u7f6e\u4e3aUTF-8\n * 2. \u4f7f\u7528\u6ce2\u7279\u5f8b\u52a8LED\u53d6\u6a21\u5de5\u5177\u751f\u6210\u5b57\u6a21(https://led.baud-dance.com)\n */\nvoid OLED_PrintString(uint8_t x, uint8_t y, char *str, const Font *font, OLED_ColorMode color)\n{\n  uint16_t i = 0;                                       // \u5b57\u7b26\u4e32\u7d22\u5f15\n  uint8_t oneLen = (((font-&gt;h + 7) / 8) * font-&gt;w) + 4; // \u4e00\u4e2a\u5b57\u6a21\u5360\u591a\u5c11\u5b57\u8282\n  uint8_t found;                                        // \u662f\u5426\u627e\u5230\u5b57\u6a21\n  uint8_t utf8Len;                                      // UTF-8\u7f16\u7801\u957f\u5ea6\n  uint8_t *head;                                        // \u5b57\u6a21\u5934\u6307\u9488\n  while (str[i])\n  {\n    found = 0;\n    utf8Len = _OLED_GetUTF8Len(str + i);\n    if (utf8Len == 0)\n      break; // \u6709\u95ee\u9898\u7684UTF-8\u7f16\u7801\n\n    // \u5bfb\u627e\u5b57\u7b26  TODO \u4f18\u5316\u67e5\u627e\u7b97\u6cd5, \u4e8c\u5206\u67e5\u627e\u6216\u8005hash\n    for (uint8_t j = 0; j &lt; font-&gt;len; j++)\n    {\n      head = (uint8_t *)(font-&gt;chars) + (j * oneLen);\n      if (memcmp(str + i, head, utf8Len) == 0)\n      {\n        OLED_SetBlock(x, y, head + 4, font-&gt;w, font-&gt;h, color);\n        // \u79fb\u52a8\u5149\u6807\n        x += font-&gt;w;\n        i += utf8Len;\n        found = 1;\n        break;\n      }\n    }\n\n    // \u82e5\u672a\u627e\u5230\u5b57\u6a21,\u4e14\u4e3aASCII\u5b57\u7b26, \u5219\u7f3a\u7701\u663e\u793aASCII\u5b57\u7b26\n    if (found == 0)\n    {\n      if (utf8Len == 1)\n      {\n        OLED_PrintASCIIChar(x, y, str[i], font-&gt;ascii, color);\n        // \u79fb\u52a8\u5149\u6807\n        x += font-&gt;ascii-&gt;w;\n        i += utf8Len;\n      }\n      else\n      {\n        OLED_PrintASCIIChar(x, y, ' ', font-&gt;ascii, color);\n        x += font-&gt;ascii-&gt;w;\n        i += utf8Len;\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"INTERFACING/RGB_LED/rgb_led/","title":"RGB LED","text":""},{"location":"INTERFACING/RGB_LED/rgb_led/#rgb-led-introduction","title":"RGB LED Introduction","text":"<p>To better indicate the MCU status, an external RGB LED is added to the Node, which is handy for MCU status indication. The RGB LED is connected to the GPIO pins of the MCU, and the color of the LED can be controlled by the MCU.</p>"},{"location":"INTERFACING/RGB_LED/rgb_led/#rgb-led-work-principle","title":"RGB LED Work Principle","text":"<p>The RGB LED is a combination of three LEDs, each of which can emit red, green, or blue light. By adjusting the brightness of each LED, the RGB LED can emit various colors. The RGB LED is connected to the GPIO pins of the MCU, and the color of the LED can be controlled by the MCU.</p>"},{"location":"INTERFACING/RGB_LED/rgb_led/#rgb-led-hardware-and-connection","title":"RGB LED Hardware and Connection","text":"RGB LED PIN MCU PIN GND GND (or external GND) R PH13 G PH14 B PH15"},{"location":"INTERFACING/RGB_LED/rgb_led/#source-code","title":"Source Code","text":""},{"location":"INTERFACING/RGB_LED/rgb_led/#led_rgbh","title":"led_rgb.h","text":"<pre><code>/**\n * @file led_rgb.h\n * @author SHUAIWEN CUI (SHUAIWEN001 AT e DOT ntu DOT edu DOT sg)\n * @brief This file is for RGB LED control function declaration.\n * @version 1.0\n * @date 2024-09-22\n *\n * @copyright Copyright (c) 2024\n *\n */\n#ifndef _LED_RGB_H_\n#define _LED_RGB_H_\n\n#include \"stm32h7xx_hal.h\" // HAL library file declaration, replace it with the corresponding file according to the actual situation\n#include \"main.h\" // IO definition and initialization function are in the main.c file, must be referenced\n\nvoid LED_RGB(int LED_R, int LED_G, int LED_B);\nvoid LED_RGB_Toggle(void); \n\n#endif /* _LED_RGB_H_ */\n</code></pre>"},{"location":"INTERFACING/RGB_LED/rgb_led/#led_rgbc","title":"led_rgb.c","text":"<pre><code>/**\n * @file led_rgb.c\n * @author SHUAIWEN CUI (SHUAIWEN001 AT e DOT ntu DOT edu DOT sg)\n * @brief This file is for RGB LED control function declaration.\n * @version 1.0\n * @date 2024-09-22\n *\n * @copyright Copyright (c) 2024\n *\n */\n\n#include \"led_rgb.h\"\n\nvoid LED_RGB(int LED_R, int LED_G, int LED_B) // LED RGB independent control function (0 is off, other values are on)\n{\n    if (LED_R)\n    {\n        HAL_GPIO_WritePin(LED_R_GPIO_Port, LED_R_Pin, GPIO_PIN_SET);\n    }\n    else\n    {\n        HAL_GPIO_WritePin(LED_R_GPIO_Port, LED_R_Pin, GPIO_PIN_RESET);\n    }\n\n    if (LED_G)\n    {\n        HAL_GPIO_WritePin(LED_G_GPIO_Port, LED_G_Pin, GPIO_PIN_SET);\n    }\n    else\n    {\n        HAL_GPIO_WritePin(LED_G_GPIO_Port, LED_G_Pin, GPIO_PIN_RESET);\n    }\n\n    if (LED_B)\n    {\n        HAL_GPIO_WritePin(LED_B_GPIO_Port, LED_B_Pin, GPIO_PIN_SET);\n    }\n    else\n    {\n        HAL_GPIO_WritePin(LED_B_GPIO_Port, LED_B_Pin, GPIO_PIN_RESET);\n    }\n}\n\nvoid LED_RGB_Toggle(void)\n{\n    int state_R = HAL_GPIO_ReadPin(LED_R_GPIO_Port, LED_R_Pin);\n    HAL_GPIO_WritePin(LED_R_GPIO_Port, LED_R_Pin, 1 - state_R);\n\n    int state_G = HAL_GPIO_ReadPin(LED_G_GPIO_Port, LED_G_Pin);\n    HAL_GPIO_WritePin(LED_G_GPIO_Port, LED_G_Pin, 1 - state_G);\n\n    int state_B = HAL_GPIO_ReadPin(LED_B_GPIO_Port, LED_B_Pin);\n    HAL_GPIO_WritePin(LED_B_GPIO_Port, LED_B_Pin, 1 - state_B);\n}\n</code></pre>"},{"location":"MAIN-CONTROL/main-control/","title":"MAIN CONTROL","text":""},{"location":"MAIN-CONTROL/main-control/#main-control-overview","title":"MAIN CONTROL OVERVIEW","text":"<ul> <li> <p> product link on Taobao</p> <p>Product link on Taobao</p> <p>  Purchase Link </p> </li> </ul>"},{"location":"MAIN-CONTROL/main-control/#onboard-resources","title":"ONBOARD RESOURCES","text":"<ul> <li>MAIN FREQUENCY: 480MHz</li> <li>RAM: 1MB (BUILT-IN)</li> <li>ROM: 2MB (BUILT-IN)</li> <li>SDRAM: 32MB (16BIT) WINBOND W9825G6KH-6I</li> <li>FLASH: 8MB (QSPI) WINBOND W25Q64</li> <li>TF CARD: 32GB (MAXIMUM) (BY TEST, LARGER CAPACITY IS SUPPORTED)</li> <li>LED: 1 PWR; 1 PROGRAMMABLE</li> <li>BUTTON: 1 RESET; 1 BOOT</li> <li>USB: TYPE-C</li> <li>PINS: 2.54MM PITCH, 2x2x28PINS</li> </ul>"},{"location":"MAIN-CONTROL/main-control/#mechanical-dimensions","title":"MECHANICAL DIMENSIONS","text":""},{"location":"MAIN-CONTROL/BSP/bsp/","title":"BOARD SUPPORT PACKAGE (BSP)","text":""},{"location":"MAIN-CONTROL/BSP/bsp/#introduction-of-the-bsp","title":"INTRODUCTION OF THE BSP","text":"<p>To facilitate the development and transplantation of the main control board, I have prepared a BSP consisting a series of useful drivers and libraries. The STM32 related BSP is based on the STM32Cube HAL library and is compatible with STM32H7 series microcontrollers, if you want you can modify it to fit other series. The BSP includes the following modules:</p> <ul> <li>bsp_led: The driver for the LED.</li> <li>bsp_usart: The driver for the USART, mainly for serial communication.</li> <li>bsp_sdram: The low-level driver for the SDRAM.</li> <li>bsp_memory: The memory management module.</li> <li>bsp_sdcard: The driver for the SD card.</li> <li>bsp_file: The file system module.</li> <li>...</li> </ul> <p>Tip</p> <p>The tutorial is written in a section-by-section manner, but in practice, the users can set up all required configuration in STM32CUBEMX in one go and then move forward to Keil or VSCode programming. Users can transplant the BSP from the library (link attached below) and incorporate it into their projects accordingly.</p> <ul> <li> <p> MCU_BSP</p> <p>MCU BSP BASED ON STM32</p> <p>  Github Repo </p> </li> </ul>"},{"location":"MAIN-CONTROL/BSP/bsp/#setup-your-keil-for-better-experience","title":"SETUP YOUR KEIL FOR BETTER EXPERIENCE","text":"<p>Open 'Options for Target' and conduct the following settings:</p>"},{"location":"MAIN-CONTROL/BSP/bsp/#use-ac6-compiler","title":"USE AC6 COMPILER","text":"<p>Since this is a new project, every thing is started with the AC6 compiler. We can use AC6 for compiling and debugging, which is much faster than the AC5 compiler.</p>"},{"location":"MAIN-CONTROL/BSP/bsp/#reset-and-run","title":"RESET AND RUN","text":"<p>Select the 'Debug' tab, and at the right upper corner, select 'Settings'. In the 'Flash and Download' tab, select 'Reset and Run' to automatically reset and run the program after downloading the program to the board. This is very handy for programming and debugging.</p>"},{"location":"MAIN-CONTROL/BSP/bsp/#how-to-integrate-bsp-into-your-project","title":"How to Integrate BSP into Your Project","text":""},{"location":"MAIN-CONTROL/BSP/bsp/#step-1-download-bsp","title":"Step 1: Download BSP","text":"<p>Clone the BSP git repository to your local workspace.</p> <pre><code>git clone https://github.com/Shuaiwen-Cui/MCU_BSP.git\n</code></pre>"},{"location":"MAIN-CONTROL/BSP/bsp/#step-2-move-bsp-into-your-project","title":"Step 2: Move BSP into Your Project","text":"<p>Select only the 'STM32-HAL-CUBEMX' folder and move it to your project directory.</p>"},{"location":"MAIN-CONTROL/BSP/bsp/#step-3-include-bsp-in-your-project","title":"Step 3: Include BSP in Your Project","text":"<p>Open Keil, select 'Options for Target' -&gt; 'C/C++' -&gt; 'Include Paths', and add the respective paths of the BSP modules to your project include paths.</p>"},{"location":"MAIN-CONTROL/BSP/bsp/#step-4-add-bsp-modules-to-your-project","title":"Step 4: Add BSP Modules to Your Project","text":"<p>Open 'Manage Project Items', and add the respective modules to your project.</p> <p>Tip</p> <p>When adding files, change the file type to 'All Types' so that both '.h' and '.c' files are merged into the project for convenient use.</p>"},{"location":"MAIN-CONTROL/BSP/bsp/#step-5-include-header-files-and-call-the-node_init-function-to-initialize-nodes","title":"Step 5: Include Header Files and Call the Node_Init() Function to Initialize Nodes","text":"<p>In your main function, include the 'setup.h' header file, and call 'Node_Init()' to initialize nodes. The corresponding hardware is initialized during this process.</p> <p>Tip</p> <p>When modifying code, make changes between 'USER CODE BEGIN' and 'USER CODE END' to avoid losing your modifications when regenerating code.</p>"},{"location":"MAIN-CONTROL/BSP/bsp/#configuration-with-the-setup-module","title":"Configuration with the SETUP Module","text":"<p>Note</p> <p>As previously mentioned, SETUP is used for configuration and initialization. For each driver in the BSP, there is a SETUP module for management. For detailed management processes, refer to the SETUP section.</p>"},{"location":"MAIN-CONTROL/BSP/bsp/#recommended-bsp-module-configuration","title":"Recommended BSP Module Configuration","text":"<p>There is a part of the configuration related to BSP within SETUP. You can follow these recommendations for configuration:</p> Module Name Configuration MODULE_ENABLE_LED \u2705 Enable MODULE_ENABLE_KEY \u274c Disable MODULE_ENABLE_USART1 \u2705 Enable MODULE_ENABLE_SDRAM \u2705 Enable MODULE_ENABLE_MEMORY \u2705 Enable MODULE_ENABLE_SDCARD \u274c Disable MODULE_ENABLE_FILE \u2705 Enable"},{"location":"MAIN-CONTROL/FILE-SYS/file-sys/","title":"FILE SYSTEM","text":"<p>Info</p> <p>File system is a method of storing and organizing computer files and their data. Here, we will use the FatFs library to interface with the SD card.</p>"},{"location":"MAIN-CONTROL/FILE-SYS/file-sys/#file-system-as-a-middleware","title":"FILE SYSTEM AS A MIDDLEWARE","text":"<p>In STM32CUBEMX, FATFS is already incorporated into the software as a middleware. To enable FATFS, go to the 'Middleware' tab and enable the 'FATFS' middleware.</p>"},{"location":"MAIN-CONTROL/FILE-SYS/file-sys/#file-system-configuration","title":"FILE SYSTEM CONFIGURATION","text":"<p>As shown, select FATFS for SD card, and enable the long file name support. </p> <p></p> <p>Then, under the Advanced Settings, select the DMA template for the SD card.</p>"},{"location":"MAIN-CONTROL/FILE-SYS/file-sys/#generate-and-update-code","title":"GENERATE AND UPDATE CODE","text":"<p>Finally, let's generate the code to save the current progress and to make it ready for following programming steps. Click the 'Generate Code' button at the top right corner of the screen.</p>"},{"location":"MAIN-CONTROL/FILE-SYS/file-sys/#programming-in-keil","title":"PROGRAMMING IN KEIL","text":""},{"location":"MAIN-CONTROL/FILE-SYS/file-sys/#modify-the-configuration-in-sd_diskioc","title":"MODIFY THE CONFIGURATION IN SD_DISKIO.C","text":"<p>As shown above, modify the code in the sd_diskio.c file to configure the SD card and FATFS.</p>"},{"location":"MAIN-CONTROL/FILE-SYS/file-sys/#incorporate-the-module-code-ifile","title":"INCORPORATE THE MODULE CODE - IFILE","text":"<p>We have introduced how to transplant and incorporate the BSP code into the project, and that applies to each respective module. For transplantation:</p> <ol> <li>Copy the module codes from the BSP project to the user project.</li> <li>Add the module codes to the user project include path.</li> <li>Add the module codes to the project items.</li> <li>Include the header file of the module code in the user project.</li> <li>Call the module function in the user project.</li> </ol> <p>Warning</p> <p>Since we are using FATFS here, and FATFS has a built-in SDCARD driver, it will conflict with our own isdcard driver. Therefore, in the <code>bsp_init</code>, if we want to use the FATFS file system, we should not include the isdcard driver; otherwise, it will cause a conflict.</p>"},{"location":"MAIN-CONTROL/FILE-SYS/file-sys/#code-review-file-sys","title":"CODE REVIEW - FILE-SYS","text":""},{"location":"MAIN-CONTROL/FILE-SYS/file-sys/#bsp_fileh","title":"bsp_file.h","text":"<pre><code>/**\n * @file bsp_file.h\n * @author SHUAIWEN CUI (shuaiwencui AT gmail DOT com)\n * @brief This is the header file for the bsp_file.c file\n * @version 1.0\n * @date 2024-07-17\n * @ref https://blog.csdn.net/Mculover666/article/details/102688285\uff1bhttps://blog.csdn.net/qq_36561846/article/details/133808890\n * @copyright Copyright (c) 2024\n *\n */\n#ifndef _BSP_FILE_H_\n#define _BSP_FILE_H_\n\n/**\n * @name INCLUDES\n */\n\n#include \"stm32h7xx.h\"\n#include \"main.h\"\n#include \"ff.h\"         // FATFS main header file\n#include \"diskio.h\"     // Disk I/O header file\n#include \"fatfs.h\"      // FATFS configuration header file (if using STM32CubeMX)\n#include \"ff_gen_drv.h\" // Generic driver header file\n#include \"ffconf.h\"\n#include \"stdio.h\"\n\n/* Define custom storage device */\n/* Number of bytes per sector for user storage device */\n#define User_Sector 512\n/* FatFs object for user storage device */\n#define User_FatFs SDFatFS\n/* Volume path for user storage device */\n#define User_SDPath SDPath\n\n/*functions*/\nvoid Mount_FatFs(void);\nvoid FatFs_GetDiskInfo(void);\nvoid FatFs_ScanDir(const TCHAR* PathName);\nvoid FatFs_ReadTXTFile(TCHAR *filename);\nvoid FatFs_WriteTXTFile(TCHAR *filename,uint16_t year, uint8_t month, uint8_t day);\nvoid FatFs_GetFileInfo(TCHAR *filename);\nvoid FatFs_DeleteFile(TCHAR *filename);\nvoid FatFs_PrintfFileDate(WORD date, WORD time);\n\nuint8_t BSP_SD_ReadBlocks_DMA(uint32_t *pData, uint32_t ReadAddr, uint32_t NumOfBlocks);\nuint8_t BSP_SD_WriteBlocks_DMA(uint32_t *pData, uint32_t WriteAddr, uint32_t NumOfBlocks);\n#endif /* _BSP_FILE_H_ */\n</code></pre>"},{"location":"MAIN-CONTROL/FILE-SYS/file-sys/#bsp_filec","title":"bsp_file.c","text":"<pre><code>/**\n * @file bsp_file.c\n * @author SHUAIWEN CUI (shuaiwencui AT gmail DOT com)\n * @brief This is the source file for the bsp_file.c file\n * @version 1.0\n * @date 2024-07-17\n * @ref https://blog.csdn.net/Mculover666/article/details/102688285\uff1bhttps://blog.csdn.net/qq_36561846/article/details/133808890\n * @copyright Copyright (c) 2024\n *\n */\n\n#include \"bsp_file.h\"\n#include \"bsp_usart.h\"\n#include \"sdmmc.h\"\n\n// Define a work buffer for formatting\nBYTE workBuffer[4 * User_Sector];\n\n/**\n * @name Mount_FatFs\n * @brief Mount FatFs file system\n * @param None\n * @retval None\n * @note Working\n */\n/* Mount FatFs file system */\nvoid Mount_FatFs(void)\n{\n    // Mount file system\n    FRESULT retUSER = f_mount(&amp;User_FatFs, User_SDPath, 1);\n    // Error occurred\n    if (retUSER != FR_OK)\n    {\n        // No file system, need to format\n        if (retUSER == FR_NO_FILESYSTEM)\n        {\n            printf(\"\\r\\nNo file system, start formatting\\r\\n\");\n            // Create file system\n            retUSER = f_mkfs(User_SDPath, FM_FAT32, 0, workBuffer, 4 * User_Sector);\n            // Formatting failed\n            if (retUSER != FR_OK)\n            {\n                printf(\"Formatting failed, error code = %d\\r\\n\", retUSER);\n            }\n            // Formatting succeeded\n            else\n            {\n                printf(\"Formatting succeeded, remounting\\r\\n\");\n                // Remount after creating file system\n                retUSER = f_mount(&amp;User_FatFs, User_SDPath, 1);\n                // Mounting failed\n                if (retUSER != FR_OK)\n                {\n                    printf(\"Error occurred, error code = %d\\r\\n\", retUSER);\n                }\n                // Mounting succeeded\n                else\n                {\n                    printf(\"*** File system mounted successfully ***\\r\\n\");\n                }\n            }\n        }\n        // Other error occurred\n        else\n        {\n            printf(\"Other error occurred, error code = %d\\r\\n\", retUSER);\n        }\n    }\n    // File system already exists, mounted successfully\n    else\n    {\n        printf(\"File system mounted successfully\\r\\n\");\n    }\n}\n\n/**\n * @name FatFs_GetDiskInfo\n * @brief Get disk information and display on LCD\n * @param None\n * @retval None\n * @note Working\n */\n/* Get disk information and display on LCD */\nvoid FatFs_GetDiskInfo(void)\n{\n    FATFS *fs;\n\n    // Define variable for remaining clusters\n    DWORD fre_clust;\n\n    // Get remaining clusters\n    FRESULT res = f_getfree(\"0:\", &amp;fre_clust, &amp;fs);\n\n    // Getting failed\n    if (res != FR_OK)\n    {\n        printf(\"f_getfree() error\\r\\n\");\n        return;\n    }\n    printf(\"\\r\\n*** FAT disk info ***\\r\\n\");\n\n    // Total number of sectors\n    DWORD tot_sect = (fs-&gt;n_fatent - 2) * fs-&gt;csize;\n\n    // Remaining number of sectors = remaining clusters * sectors per cluster\n    DWORD fre_sect = fre_clust * fs-&gt;csize;\n\n    // For SD card and USB flash drive, _MIN_SS=512 bytes\n#if _MAX_SS == _MIN_SS\n    // SD card's _MIN_SS is fixed at 512, right shift 11 bits equals dividing by 2048\n    // Remaining space size, unit: MB, for SD card and USB flash drive\n    DWORD freespace = (fre_sect &gt;&gt; 11);\n    // Total space size, unit: MB, for SD card and USB flash drive\n    DWORD totalSpace = (tot_sect &gt;&gt; 11);\n#else\n    // Flash storage, small capacity\n    // Remaining space size, unit: KB\n    DWORD freespace = (fre_sect * fs-&gt;ssize) &gt;&gt; 10;\n    // Total space size, unit: KB\n    DWORD totalSpace = (tot_sect * fs-&gt;ssize) &gt;&gt; 10;\n#endif\n\n    // FAT type\n    printf(\"FAT type = %d \", fs-&gt;fs_type);\n    printf(\"[1=FAT12, 2=FAT16, 3=FAT32, 4=exFAT]\\r\\n\");\n\n    // Sector size in bytes\n    printf(\"Sector size(bytes) = \");\n    // SD card fixed 512 bytes\n#if _MAX_SS == _MIN_SS\n    printf(\"%d\\r\\n\", _MIN_SS);\n#else\n    // Flash storage\n    printf(\"%d\\r\\n\", fs-&gt;ssize);\n#endif\n\n    printf(\"Cluster size(sectors) = %d\\r\\n\", fs-&gt;csize);\n    printf(\"Total cluster count = %ld\\r\\n\", fs-&gt;n_fatent - 2);\n    printf(\"Total sector count = %ld\\r\\n\", tot_sect);\n\n    // Total space\n#if _MAX_SS == _MIN_SS\n    printf(\"Total space = %ld(MB) = %ld(GB)\\r\\n\", totalSpace, totalSpace &gt;&gt; 10);\n#else\n    printf(\"Total space = %ld(KB) = %ld(MB)\\r\\n\", totalSpace, totalSpace &gt;&gt; 10);\n#endif\n\n    // Free cluster count\n    printf(\"Free cluster count = %ld\\r\\n\", fre_clust);\n    // Free sector count\n    printf(\"Free sector count = %ld\\r\\n\", fre_sect);\n\n    // Free space\n#if _MAX_SS == _MIN_SS\n    printf(\"Free space = %ld(MB) = %ld(GB)\\r\\n\", freespace, freespace &gt;&gt; 10);\n#else\n    printf(\"Free space = %ld(KB) = %ld(MB)\\r\\n\", freespace, freespace &gt;&gt; 10);\n#endif\n\n    printf(\"Get FAT disk info OK\\r\\n\");\n}\n\n/* Create a text file */\nvoid FatFs_WriteTXTFile(TCHAR *filename, uint16_t year, uint8_t month, uint8_t day)\n{\n    FIL file;\n    printf(\"\\r\\n*** Creating TXT file: %s ***\\r\\n\", filename);\n\n    FRESULT res = f_open(&amp;file, filename, FA_CREATE_ALWAYS | FA_WRITE);\n    // File opened/created successfully\n    if (res == FR_OK)\n    {\n        // String must have a newline character \"\\n\"\n        TCHAR str[] = \"Line1: Hello, FatFs***\\n\";\n        // Does not write the end character \"\\0\"\n        f_puts(str, &amp;file);\n\n        printf(\"Write file OK: %s\\r\\n\", filename);\n    }\n    else\n    {\n        printf(\"Open file error, error code: %d\\r\\n\", res);\n    }\n    // Close the file after use\n    f_close(&amp;file);\n}\n\n/* Read the content of a text file */\nvoid FatFs_ReadTXTFile(TCHAR *filename)\n{\n    printf(\"\\r\\n*** Reading TXT file: %s ***\\r\\n\", filename);\n\n    FIL file;\n    // Open file in read-only mode\n    FRESULT res = f_open(&amp;file, filename, FA_READ);\n    // Opened successfully\n    if (res == FR_OK)\n    {\n        // Read buffer\n        TCHAR str[100];\n        // Not reached the end of file\n        while (!f_eof(&amp;file))\n        {\n            // Read 1 string, automatically add end character \"\\0\"\n            f_gets(str, 100, &amp;file);\n            printf(\"%s\", str);\n        }\n        printf(\"\\r\\n\");\n    }\n    // File does not exist\n    else if (res == FR_NO_FILE)\n        printf(\"File does not exist\\r\\n\");\n    // Opening failed\n    else\n        printf(\"f_open() error, error code: %d\\r\\n\", res);\n    // Close the file\n    f_close(&amp;file);\n}\n\n/* Scan and display files and directories in the specified directory */\nvoid FatFs_ScanDir(const TCHAR *PathName)\n{\n    DIR dir;     // Directory object\n    FILINFO fno; // File information\n    // Open directory\n    FRESULT res = f_opendir(&amp;dir, PathName);\n    // Opening failed\n    if (res != FR_OK)\n    {\n        // Close directory and exit function\n        f_closedir(&amp;dir);\n        printf(\"\\r\\nf_opendir() error, error code: %d\\r\\n\", res);\n        return;\n    }\n\n    printf(\"\\r\\n*** All entries in dir: %s ***\\r\\n\", PathName);\n    // Read files in the directory sequentially\n    while (1)\n    {\n        // Read one item in the directory\n        res = f_readdir(&amp;dir, &amp;fno);\n        // If file name is empty, no more items to read\n        if (res != FR_OK || fno.fname[0] == 0)\n            break;\n        // If it is a directory\n        if (fno.fattrib &amp; AM_DIR)\n        {\n            printf(\"DIR: %s\\r\\n\", fno.fname);\n        }\n        // If it is a file\n        else\n        {\n            printf(\"FILE: %s\\r\\n\", fno.fname);\n        }\n    }\n    // Scanning finished, close directory\n    printf(\"Scan dir OK\\r\\n\");\n    f_closedir(&amp;dir);\n}\n\n/* Get information of a file */\nvoid FatFs_GetFileInfo(TCHAR *filename)\n{\n    printf(\"\\r\\n*** File info of: %s ***\\r\\n\", filename);\n\n    FILINFO fno;\n    // Check if file or subdirectory exists\n    FRESULT fr = f_stat(filename, &amp;fno);\n    // If exists, read file information from fno\n    if (fr == FR_OK)\n    {\n        printf(\"File size(bytes) = %ld\\r\\n\", fno.fsize);\n        printf(\"File attribute = 0x%x\\r\\n\", fno.fattrib);\n        printf(\"File Name = %s\\r\\n\", fno.fname);\n        // Output the timestamp of file creation/modification\n        FatFs_PrintfFileDate(fno.fdate, fno.ftime);\n    }\n    // If file does not exist\n    else if (fr == FR_NO_FILE)\n        printf(\"File does not exist\\r\\n\");\n    // Other error occurred\n    else\n        printf(\"f_stat() error, error code: %d\\r\\n\", fr);\n}\n\n/* Delete a file */\nvoid FatFs_DeleteFile(TCHAR *filename)\n{\n    printf(\"\\r\\n*** Delete File: %s***\\r\\n\", filename);\n    FIL file;\n    // Open file\n    FRESULT res = f_open(&amp;file, filename, FA_OPEN_EXISTING);\n    if (res == FR_OK)\n    {\n        // Close file\n        f_close(&amp;file);\n        printf(\"Open successfully!\\r\\n\");\n    }\n    // Delete file\n    res = f_unlink(filename);\n    // Delete successfully\n    if (res == FR_OK)\n    {\n        printf(\"The file was deleted successfully!\\r\\n\");\n    }\n    // Delete failed\n    else\n    {\n        printf(\"File deletion failed, error code: %d\\r\\n\", res);\n    }\n}\n\n/* Print file date */\nvoid FatFs_PrintfFileDate(WORD date, WORD time)\n{\n    printf(\"File date = %d/%d/%d\\r\\n\", ((date &gt;&gt; 9) &amp; 0x7F) + 1980, (date &gt;&gt; 5) &amp; 0xF, date &amp; 0x1F);\n    printf(\"File time = %d:%d:%d\\r\\n\", (time &gt;&gt; 11) &amp; 0x1F, (time &gt;&gt; 5) &amp; 0x3F, time &amp; 0x1F);\n}\n\n\n// to over write BSP_SD_ReadBlocks_DMA &amp; BSP_SD_WriteBlocks_DMA in bsp_driver_sd.c\nuint8_t BSP_SD_ReadBlocks_DMA(uint32_t *pData, uint32_t ReadAddr, uint32_t NumOfBlocks)\n{\n  uint8_t sd_state = MSD_OK;\n\n  SCB_CleanDCache();\n\n  /* Read block(s) in DMA transfer mode */\n  if (HAL_SD_ReadBlocks_DMA(&amp;hsd1, (uint8_t *)pData, ReadAddr, NumOfBlocks) != HAL_OK)\n  {\n    sd_state = MSD_ERROR;\n  }\n\n  return sd_state;\n}\n\nuint8_t BSP_SD_WriteBlocks_DMA(uint32_t *pData, uint32_t WriteAddr, uint32_t NumOfBlocks)\n{\n  uint8_t sd_state = MSD_OK;\n\n  SCB_CleanDCache();\n\n  /* Write block(s) in DMA transfer mode */\n  if (HAL_SD_WriteBlocks_DMA(&amp;hsd1, (uint8_t *)pData, WriteAddr, NumOfBlocks) != HAL_OK)\n  {\n    sd_state = MSD_ERROR;\n  }\n\n  return sd_state;\n}\n</code></pre>"},{"location":"MAIN-CONTROL/FMC/fmc/","title":"FMC","text":"<p>Info</p> <p>FMC stands for Flexible Memory Controller. It is a feature that allows the MCU to interface with external memory devices such as SDRAM, SRAM, and NOR Flash. </p>"},{"location":"MAIN-CONTROL/FMC/fmc/#fmc-setup","title":"FMC SETUP","text":"<p>As shown, in the 'Connectivity' tab, enable FMC, and then enable the SDRAM device in FMC configuration zone, and set the parameters according to the datasheet of the SDRAM device.</p>"},{"location":"MAIN-CONTROL/FMC/fmc/#sdram","title":"SDRAM","text":"<p>SDRAM is one of the most common types of external memory devices that can be interfaced with the MCU using the FMC. It is a type of volatile memory that is used in computers and other electronic devices. Here, since the built-in RAM is only 1MB, and not enough for some applications, we need to use external SDRAM to expand the memory capacity.</p>"},{"location":"MAIN-CONTROL/FMC/fmc/#generate-and-update-code","title":"GENERATE AND UPDATE CODE","text":"<p>Finally, let's generate the code to save the current progress and to make it ready for following programming steps. Click the 'Generate Code' button at the top right corner of the screen.</p>"},{"location":"MAIN-CONTROL/LED/led/","title":"LED","text":""},{"location":"MAIN-CONTROL/LED/led/#led-circuit-design","title":"LED CIRCUIT DESIGN","text":""},{"location":"MAIN-CONTROL/LED/led/#configure-the-pin","title":"CONFIGURE THE PIN","text":""},{"location":"MAIN-CONTROL/LED/led/#select-and-set-pin-mode","title":"SELECT AND SET PIN MODE","text":"<p>According to the circuit design, select the corresponding pin PH7 and set the mode to \"GPIO Output\".</p>"},{"location":"MAIN-CONTROL/LED/led/#gpio-setting","title":"GPIO SETTING","text":"<p>In the leftmost pane, select the \"GPIO\" tab and set the parameters for PH7 as shown in the figure below.</p> <ul> <li>GPIO OUTPUT LEVEL: LOW</li> </ul> <p>Info</p> <p>As can be seen from the circuit design, low level output can light up the LED and high level output can turn off the LED.</p> <ul> <li>GPIO MODE: Output</li> </ul> <p>Here, we set the pin mode to \"Output\" as we use it as a control for LED.</p> <ul> <li>GPIO PULL-UP/PULL-DOWN: PULL-UP</li> </ul> <p>Info</p> <p>The pull-up resistor is used to ensure that the pin is in a high state when it is not connected to the ground.</p> <ul> <li>GPIO SPEED: Very High</li> </ul> <p>Info</p> <p>The speed of the GPIO pin means the speed at which the pin changes from one state to another. Here, we set it to \"Very High\" to ensure that the LED can be turned on and off quickly. This is no strict requirement for the speed setting of the LED pin, but it is recommended to set it to \"Very High\" for better performance.</p> <ul> <li>USER LABEL: LED</li> </ul> <p>Info</p> <p>The user label is used to mark the pin for easy identification. Here, we set it to \"LED\" to indicate that this pin is used to control the LED.</p>"},{"location":"MAIN-CONTROL/LED/led/#generate-and-update-code","title":"GENERATE AND UPDATE CODE","text":"<p>Finally, let's generate the code to save the current progress and to make it ready for following programming steps. Click the 'Generate Code' button at the top right corner of the screen.</p>"},{"location":"MAIN-CONTROL/LED/led/#programming-in-keil","title":"PROGRAMMING IN KEIL","text":""},{"location":"MAIN-CONTROL/LED/led/#incorporate-the-module-code","title":"INCORPORATE THE MODULE CODE","text":"<p>We have introduced how to transplant and incorporate the BSP code into the project, and that applies to each respective module. For transplantation:</p> <ol> <li>Copy the module codes from the BSP project to the user project.</li> <li>Add the module codes to the user project include path.</li> <li>Add the module codes to the project items.</li> <li>Include the header file of the module code in the user project.</li> <li>Call the module function in the user project.</li> </ol>"},{"location":"MAIN-CONTROL/LED/led/#code-review-led","title":"CODE REVIEW - LED","text":"<p>Let's review the code for the LED module. This module is actually very simple, readers can refer to the code below for details.</p>"},{"location":"MAIN-CONTROL/LED/led/#bsp_ledh","title":"bsp_led.h","text":"<pre><code>/*\n * bsp_led.h\n *\n *  Created on: June 07, 2024\n *      Author: SHUAIWEN CUI\n */\n\n#ifndef _BSP_LED_H_\n#define _BSP_LED_H_\n\n#include \"stm32h7xx_hal.h\" // HAL library file declaration, replace it with the corresponding file according to the actual situation\n#include \"main.h\" // IO definition and initialization function are in the main.c file, must be referenced\n\nvoid LED(uint8_t state);// LED independent control function (0 is off, other values are on)\nvoid LED_Toggle(void);// LED Toggle\n\n#endif /* _BSP_LED_H_ */\n</code></pre>"},{"location":"MAIN-CONTROL/LED/led/#bsp_ledc","title":"bsp_led.c","text":"<pre><code>/*\n * bsp_led.c\n *\n *  Created on: June 07, 2024\n *      Author: SHUAIWEN CUI\n */\n\n#include \"bsp_led.h\"\n\nvoid LED(uint8_t state) // LED R independent control function (0 is off, other values are on)\n{\n\n    if (state)\n    {\n        HAL_GPIO_WritePin(LED_GPIO_Port, LED_Pin, GPIO_PIN_RESET);\n    }\n    else\n    {\n        HAL_GPIO_WritePin(LED_GPIO_Port, LED_Pin, GPIO_PIN_SET);\n    }\n}\n\nvoid LED_Toggle(void)\n{\n    int state = HAL_GPIO_ReadPin(LED_GPIO_Port, LED_Pin);\n    HAL_GPIO_WritePin(LED_GPIO_Port, LED_Pin, 1 - state);\n}\n</code></pre>"},{"location":"MAIN-CONTROL/MEMORY/memory/","title":"MEMORY MANAGEMENT","text":""},{"location":"MAIN-CONTROL/PREPARATION/preparation/","title":"PREPARATION WORK","text":"<p>Note</p> <p>\"Initialization settings\" is the first step in setting up the main control system, enabling the system to operate its basic functions. This section focuses on the basic configuration of the main control board. Note that for ease of reference and portability, this section only covers the configuration of the core board, while peripheral configurations are addressed in corresponding chapters. When adding peripheral hardware and software, you only need to enable the relevant pins and functions in CUBEMX, without affecting the existing functions.</p>"},{"location":"MAIN-CONTROL/PREPARATION/preparation/#hardware-preparation","title":"HARDWARE PREPARATION","text":"<p>To program the main control board, we need three components:</p> <ul> <li>The main control board -  the development board that embeds the MCU</li> <li>A USB-TTL adapter - to connect the main control board to the computer</li> <li>A DEBUGGER (ST-LINK V2, J-LINK, etc.) - to program the main control board</li> </ul>"},{"location":"MAIN-CONTROL/PREPARATION/preparation/#component-1-the-main-control-board-fanke743","title":"COMPONENT 1 - The Main Control Board - FANKE743","text":"<ul> <li> <p> product link</p> <p>Product link</p> <p>  Purchase Link </p> </li> </ul>"},{"location":"MAIN-CONTROL/PREPARATION/preparation/#component-2-usb-ttl-adapter","title":"COMPONENT 2 - USB-TTL Adapter","text":"<ul> <li> <p> product link</p> <p>Product link</p> <p>  Purchase Link </p> </li> </ul>"},{"location":"MAIN-CONTROL/PREPARATION/preparation/#component-3-debugger","title":"COMPONENT 3 - Debugger","text":"<ul> <li> <p> product link</p> <p>Product link</p> <p>  Purchase Link </p> </li> </ul> <p>Info</p> <p>CMSIS-DAP, ST-LINK, and J-LINK are the most commonly used debuggers. Any of these debuggers can be used to program the main control board.</p>"},{"location":"MAIN-CONTROL/PREPARATION/preparation/#hardware-connection","title":"HARDWARE CONNECTION","text":"<p>Connect the three components as shown in the figure above. Then connect the USB-TTL adapter and the debugger to the computer.</p>"},{"location":"MAIN-CONTROL/PREPARATION/preparation/#software-preparation","title":"SOFTWARE PREPARATION","text":""},{"location":"MAIN-CONTROL/PREPARATION/preparation/#stm32cubemx","title":"STM32CUBEMX","text":"<p>STM32CUBEMX is a graphical tool that allows configuring the STM32 microcontroller very easily and generating the corresponding initialization C code through a step-by-step process. Download and install STM32CubeMX from the official website.</p>"},{"location":"MAIN-CONTROL/PREPARATION/preparation/#keil-mdk","title":"KEIL MDK","text":"<p>KEIL MDK is a complete software development environment for a wide range of ARM Cortex-M based microcontroller devices. Download and install KEIL MDK from the official website.</p>"},{"location":"MAIN-CONTROL/PREPARATION/preparation/#software-setup","title":"SOFTWARE SETUP","text":""},{"location":"MAIN-CONTROL/PREPARATION/preparation/#create-a-new-project-in-stm32cubemx","title":"CREATE A NEW PROJECT IN STM32CUBEMX","text":""},{"location":"MAIN-CONTROL/PREPARATION/preparation/#new-project","title":"New Project","text":"<p>Open STM32CubeMX and click the 'File' tab and then click the option 'New Project'.</p>"},{"location":"MAIN-CONTROL/PREPARATION/preparation/#select-mcu-series-and-model","title":"Select MCU Series and Model","text":"<p>Select the MCU series and the MCU model. Then click 'Start Project'.</p>"},{"location":"MAIN-CONTROL/PREPARATION/preparation/#enable-memory-protection-unit-mpu","title":"Enable Memory Protection Unit (MPU)","text":"<p>Enable the 'Memory Protection Unit' and click 'YES'.</p>"},{"location":"MAIN-CONTROL/PREPARATION/preparation/#configure-project-information-and-code-generation","title":"Configure Project Information and Code Generation","text":"<p>Setup the project information and code generation configuration first as shown in the above figures.Then click 'Generate Code'.</p>"},{"location":"MAIN-CONTROL/PREPARATION/preparation/#system-configuration","title":"SYSTEM CONFIGURATION","text":"<p>Let's go back to the Pinout &amp; Configuration tab and configure the system as shown below.</p>"},{"location":"MAIN-CONTROL/PREPARATION/preparation/#system-core-sys-timebase-source","title":"System Core - SYS: Timebase Source","text":"<p>Select the 'SYS' tab and then select the 'Timebase Source' as 'SysTick'.</p>"},{"location":"MAIN-CONTROL/PREPARATION/preparation/#system-core-rcc-high-speed-clock-hse-low-speed-clock-lse","title":"System Core - RCC: High Speed Clock (HSE) &amp; Low Speed Clock (LSE)","text":"<p>Select the 'RCC' tab and configure the 'High Speed Clock (HSE)' and 'Low Speed Clock (LSE)' as shown in the above figure. Both of them are set to 'Crystal/Ceramic Resonator'. Generally speaking, the external crystal oscillators are more accurate than the internal RC oscillators.</p>"},{"location":"MAIN-CONTROL/PREPARATION/preparation/#system-core-coretex_m7-enable-i-cache-d-cache-mpu","title":"System Core - CORETEX_M7: Enable I-Cache &amp; D-Cache &amp; MPU","text":"<p>Select the 'CORETEX_M7' tab and enable the 'I-Cache', 'D-Cache', and 'MPU' as shown in the above figure. Some advanced features require the I-Cache, D-Cache, and MPU to be enabled, e.g., X-CUBE-AI. </p>"},{"location":"MAIN-CONTROL/PREPARATION/preparation/#timer-rtc-enable-rtc","title":"Timer - RTC: Enable RTC","text":"<p>Select the 'RTC' tab and enable the 'RTC' as shown in the above figure. The RTC is a real-time clock that can be used to keep track of the current time and date. Here, we enable RTC for future potential applications.</p>"},{"location":"MAIN-CONTROL/PREPARATION/preparation/#trace-and-debug-debug-enable-serial-wire","title":"Trace and Debug - DEBUG: Enable Serial Wire","text":"<p>Select the 'DEBUG' tab and enable the 'Serial Wire' as shown in the above figure. The Serial Wire is a debug interface that allows the debugger to communicate with the MCU.</p>"},{"location":"MAIN-CONTROL/PREPARATION/preparation/#clock-configuration","title":"Clock Configuration","text":"<p>Configure the clock as shown in the above figure. The clock configuration is crucial for the MCU to operate correctly.</p> <p>Note</p> <p>So far, we have finished the basic setup up for MCU. You can have check of all configuration again and then click 'Generate Code' to generate the initialization code for the MCU. We will continue to set up the software environment in the next section.</p> <p>Tip</p> <p>For simplicity, I did not include all the CubeMX configuration steps in this section. In stead, the configuration is divided into several sections according to the function of the configuration. In practice, one can configure all the settings in one go. </p>"},{"location":"MAIN-CONTROL/PREPARATION/preparation/#generate-and-update-code","title":"GENERATE AND UPDATE CODE","text":"<p>Finally, let's generate the code to save the current progress and to make it ready for following programming steps. Click the 'Generate Code' button at the top right corner of the screen.</p>"},{"location":"MAIN-CONTROL/PREPARATION/preparation/#project-structure","title":"PROJECT STRUCTURE","text":"<p>The project files in the system explorer looks like this:</p> <p></p> <p>The project structure in Keil looks like this:</p> <p></p> <p>The include path is set up as shown in the figure below:</p> <p></p>"},{"location":"MAIN-CONTROL/RTOS/rtos/","title":"REAL TIME OPERATING SYSTEM (RTOS)","text":"<p>To be updated.</p>"},{"location":"MAIN-CONTROL/SDCARD/sdcard/","title":"SDCARD","text":"<p>Info</p> <p>SDCARD is the abbreviation of Secure Digital Memory Card. It is a type of non-volatile memory card used in computers and other electronic devices. Here, we will use the SDMMC peripheral to interface with the SD card.</p>"},{"location":"MAIN-CONTROL/SDCARD/sdcard/#sdcard-circuit","title":"SDCARD CIRCUIT","text":""},{"location":"MAIN-CONTROL/SDCARD/sdcard/#sdcard-configuration","title":"SDCARD CONFIGURATION","text":"<p>To enable SDCARD, we need to enable SDMMC for this development board. For some other development boards, you may need to enable the SDMMC peripheral.</p> <p>For SDMMC configuration, refer to SDMMC tab.</p>"},{"location":"MAIN-CONTROL/SDCARD/sdcard/#sdcard-gpio","title":"SDCARD GPIO","text":"<p>For SD card, we can use the default GPIO pins. However, you can change the GPIO pins according to your requirements.</p>"},{"location":"MAIN-CONTROL/SDCARD/sdcard/#generate-and-update-code","title":"GENERATE AND UPDATE CODE","text":"<p>Finally, let's generate the code to save the current progress and to make it ready for following programming steps. Click the 'Generate Code' button at the top right corner of the screen.</p>"},{"location":"MAIN-CONTROL/SDCARD/sdcard/#programming-in-keil","title":"PROGRAMMING IN KEIL","text":""},{"location":"MAIN-CONTROL/SDCARD/sdcard/#incorporate-the-module-code","title":"INCORPORATE THE MODULE CODE","text":"<p>We have introduced how to transplant and incorporate the BSP code into the project, and that applies to each respective module. For transplantation:</p> <ol> <li>Copy the module codes from the BSP project to the user project.</li> <li>Add the module codes to the user project include path.</li> <li>Add the module codes to the project items.</li> <li>Include the header file of the module code in the user project.</li> <li>Call the module function in the user project.</li> </ol>"},{"location":"MAIN-CONTROL/SDCARD/sdcard/#code-review-sdcard","title":"CODE REVIEW - SDCARD","text":""},{"location":"MAIN-CONTROL/SDCARD/sdcard/#bsp_sdcardh","title":"bsp_sdcard.h","text":"<pre><code>/**\n * @file bsp_sdcard.h\n * @author SHUAIWEN CUI (shuaiwencui AT gmail DOT com)\n * @brief This is the header file for the bsp_sdcard.c file\n * @version 1.0\n * @date 2024-07-16\n * @ref https://blog.csdn.net/mculover666/article/details/100555620\n * @copyright Copyright (c) 2024\n *\n */\n#ifndef _BSP_SDCARD_H_\n#define _BSP_SDCARD_H_\n\n/**\n * @name INCLUDES\n */\n\n#include \"stm32h7xx.h\"\n\n/**\n * @name MACROS\n */\n\n\n/**\n * @name VARIABLES\n *\n */\nextern uint8_t read_buf[512];\nextern uint8_t write_buf[512];\n\n/**\n * @name FUNCTION PROTOTYPES\n */\n/**\n * @name SD_Init\n * @brief SD card initialization, this function handles the part that not processed by CUBEMX.\n */\nint SD_Init(void);\n\n/**\n * @name SD_Test\n * @brief Display the SD card information for SD card testing\n * \n */\nint SD_Test(void);\n\n#endif /* _BSP_SDCARD_H_ */\n</code></pre>"},{"location":"MAIN-CONTROL/SDCARD/sdcard/#bsp_sdcardc","title":"bsp_sdcard.c","text":"<pre><code>/**\n * @file bsp_sdcard.c\n * @author SHUAIWEN CUI (shuaiwencui AT gmail DOT com)\n * @brief This is the source file for the bsp_sdcard.c file\n * @version 1.0\n * @date 2024-07-16\n * @ref https://blog.csdn.net/mculover666/article/details/100555620\n * @copyright Copyright (c) 2024\n *\n */\n\n/**\n * @name INCLUDES\n *\n */\n#include \"sdmmc.h\"\n#include \"bsp_usart.h\"\n\n/**\n * @name MACROS\n *\n */\n\n/**\n * @name VARIABLES\n *\n */\nuint8_t read_buf[512];\nuint8_t write_buf[512];\n/**\n * @name FUNCTIONS\n * @brief SD card info struct\n * @param None\n * @retval int 0: success, -1: error\n */\n\n/**\n * @name SD_Init\n * @brief SD card initialization, this function handles the part that not processed by CUBEMX.\n */\nint SD_Init(void)\n{\n    HAL_SD_MspInit(&amp;hsd1);\n    if (HAL_SD_Init(&amp;hsd1) != HAL_OK)\n    {\n        printf(\"[Initialization] SD card initialization failed - HAL_SD_Init().\\n\\r\");\n        return -1;\n    }\n    if (HAL_SD_ConfigWideBusOperation(&amp;hsd1, SDMMC_BUS_WIDE_4B) != HAL_OK)\n    {\n        printf(\"[Initialization] SD card initialization failed - HAL_SD_ConfigWideBusOperation().\\n\\r\");\n        return -1;\n    }\n    return 0;\n}\n\n/**\n * @name SD_Test\n * @brief Display the SD card information for SD card testing\n *\n */\nint SD_Test(void)\n{\n    int i;\n\n    int sdcard_status = 0;\n    HAL_SD_CardCIDTypeDef sdcard_cid;\n\n    printf(\"[INITIALIZATION] Micro SD Card Test...\\r\\n\");\n\n    /* Check if the SD card is operating correctly (in transfer mode) */\n    sdcard_status = HAL_SD_GetCardState(&amp;hsd1);\n    if (sdcard_status == HAL_SD_CARD_TRANSFER)\n    {\n        printf(\"[INITIALIZATION] SD card init ok!\\r\\n\\r\\n\");\n\n        // Print basic SD card information\n        printf(\"[INITIALIZATION] SD card information:\\r\\n\");\n        printf(\"[INITIALIZATION] Card Capacity: %llu MB\\r\\n\", ((unsigned long long)hsd1.SdCard.BlockSize * hsd1.SdCard.BlockNbr/1024/1024));\n        printf(\"[INITIALIZATION] Card BlockSize: %d \\r\\n\", hsd1.SdCard.BlockSize);\n        printf(\"[INITIALIZATION] Relative Card Address: %d \\r\\n\", hsd1.SdCard.RelCardAdd);\n        printf(\"[INITIALIZATION] Card Type: %d \\r\\n\", hsd1.SdCard.CardType);\n\n        // Read and print the SD card CID information\n        HAL_SD_GetCardCID(&amp;hsd1, &amp;sdcard_cid);\n        printf(\"[INITIALIZATION] ManufacturerID: %d \\r\\n\", sdcard_cid.ManufacturerID);\n    }\n    else\n    {\n        printf(\"[INITIALIZATION] SD card init fail!\\r\\n\");\n        return 0;\n    }\n\n    /* Erase SD card block */\n    printf(\"[INITIALIZATION] ------------------- Block Erase ------------------------------\\r\\n\");\n    sdcard_status = HAL_SD_Erase(&amp;hsd1, 0, 512);\n    if (sdcard_status == 0)\n    {\n        printf(\"[INITIALIZATION] Erase block ok!\\r\\n\");\n    }\n    else\n    {\n        printf(\"[INITIALIZATION] Erase block fail!\\r\\n\");\n    }\n\n    /* Read data before any operation */\n    printf(\"[INITIALIZATION] ------------------- Read SD card block data Test -------------\\r\\n\");\n    sdcard_status = HAL_SD_ReadBlocks(&amp;hsd1, (uint8_t *)read_buf, 0, 1, 0xffff);\n    if (sdcard_status == 0)\n    {\n        printf(\"[INITIALIZATION] Read block data ok!\\r\\n\");\n        for (i = 0; i &lt; 512; i++)\n        {\n            printf(\"0x%02x \", read_buf[i]);\n            if ((i + 1) % 16 == 0)\n            {\n                printf(\"\\r\\n\");\n            }\n        }\n    }\n    else\n    {\n        printf(\"[INITIALIZATION] Read block data fail!\\r\\n \");\n    }\n\n    /* Fill buffer with data */\n    for (i = 0; i &lt; 512; i++)\n    {\n        write_buf[i] = i % 256;\n    }\n\n    /* Write data to SD card block */\n    printf(\"[INITIALIZATION] ------------------- Write SD card block data Test ------------\\r\\n\");\n    sdcard_status = HAL_SD_WriteBlocks(&amp;hsd1, (uint8_t *)write_buf, 0, 1, 0xffff);\n    if (sdcard_status == 0)\n    {\n        printf(\"[INITIALIZATION] Write block data ok!\\r\\n\");\n    }\n    else\n    {\n        printf(\"[INITIALIZATION] Write block data fail!\\r\\n \");\n    }\n\n    /* Read data after write operation */\n    printf(\"[INITIALIZATION] ------------------- Read SD card block data after Write ------\\r\\n\");\n    sdcard_status = HAL_SD_ReadBlocks(&amp;hsd1, (uint8_t *)read_buf, 0, 1, 0xffff);\n    if (sdcard_status == 0)\n    {\n        printf(\"[INITIALIZATION] Read block data ok!\\r\\n\");\n        for (i = 0; i &lt; 512; i++)\n        {\n            printf(\"0x%02x \", read_buf[i]);\n            if ((i + 1) % 16 == 0)\n            {\n                printf(\"\\r\\n\");\n            }\n        }\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"MAIN-CONTROL/SDMMC/sdmmc/","title":"SDMMC","text":"<p>Info</p> <p>SDMMC stands for Secure Digital Memory Card. It is a type of non-volatile memory card that is used in computers and other electronic devices. Here, we will use the SDMMC peripheral to interface with an SD card.</p>"},{"location":"MAIN-CONTROL/SDMMC/sdmmc/#enable-sdmmc","title":"ENABLE SDMMC","text":"<p>As shown, in the 'Connectivity' tab, enable the SDMMC peripheral. Note that, the divider is set to 2. Note that, at this time, you may need to reconfigure the clock settings in the 'Clock Configuration' tab.</p>"},{"location":"MAIN-CONTROL/SDMMC/sdmmc/#enable-mdma","title":"ENABLE MDMA","text":"<p>Info</p> <p>MDMA stands for Memory Direct Memory Access. It is a type of DMA that is used to transfer data between memory and memory. Here, we will use MDMA to transfer data between the SD card and the SDRAM.</p>"},{"location":"MAIN-CONTROL/SDMMC/sdmmc/#enable-nvic","title":"ENABLE NVIC","text":"<p>As shown, in the 'NVIC Settings' tab, enable the SDMMC interrupt.</p>"},{"location":"MAIN-CONTROL/SDMMC/sdmmc/#nvic-configuration","title":"NVIC CONFIGURATION","text":"<p>So far, the NVIC settings are as shown. </p>"},{"location":"MAIN-CONTROL/SDMMC/sdmmc/#generate-and-update-code","title":"GENERATE AND UPDATE CODE","text":"<p>Finally, let's generate the code to save the current progress and to make it ready for following programming steps. Click the 'Generate Code' button at the top right corner of the screen.</p>"},{"location":"MAIN-CONTROL/SDRAM/sdram/","title":"SDRAM","text":"<p>Info</p> <p>SDRAM stands for Synchronous Dynamic Random Access Memory. It is a type of volatile memory that is used in computers and other electronic devices. Here, since the built-in RAM is only 1MB, and not enough for some applications, we need to use external SDRAM to expand the memory capacity.</p>"},{"location":"MAIN-CONTROL/SDRAM/sdram/#sdram-circuit","title":"SDRAM CIRCUIT","text":"<p>Please carefully compare the pin design with the pin setup in CUBEMX, ensure that the pin configuration is consistent with the hardware connection. In our case, only PH2, PH3, and PH5 are not consistent, so we can manually set up them in the chip view on the right hand side and set them to their respective functions as designed.</p>"},{"location":"MAIN-CONTROL/SDRAM/sdram/#sdram-parameters","title":"SDRAM PARAMETERS","text":"<p>The SDRAM Module we are using is WINBOND W9825G6KH-6I. You can find the datasheet here. The parameters are calculated according to the datasheet.</p>"},{"location":"MAIN-CONTROL/SDRAM/sdram/#gpio-configuration","title":"GPIO CONFIGURATION","text":"<p>Check the pin configuration. Compare the setup in CUBEMX with the pin design.</p>"},{"location":"MAIN-CONTROL/SDRAM/sdram/#generate-and-update-code","title":"GENERATE AND UPDATE CODE","text":"<p>Finally, let's generate the code to save the current progress and to make it ready for following programming steps. Click the 'Generate Code' button at the top right corner of the screen.</p>"},{"location":"MAIN-CONTROL/SDRAM/sdram/#programming-in-keil","title":"PROGRAMMING IN KEIL","text":""},{"location":"MAIN-CONTROL/SDRAM/sdram/#incorporate-the-module-code","title":"INCORPORATE THE MODULE CODE","text":"<p>We have introduced how to transplant and incorporate the BSP code into the project, and that applies to each respective module. For transplantation:</p> <ol> <li>Copy the module codes from the BSP project to the user project.</li> <li>Add the module codes to the user project include path.</li> <li>Add the module codes to the project items.</li> <li>Include the header file of the module code in the user project.</li> <li>Call the module function in the user project.</li> </ol>"},{"location":"MAIN-CONTROL/SDRAM/sdram/#code-review-sdram","title":"CODE REVIEW - SDRAM","text":"<p>Let's review the code for the SDRAM module. </p>"},{"location":"MAIN-CONTROL/SDRAM/sdram/#bsp_sdramh","title":"bsp_sdram.h","text":"<pre><code>/**\n * @file bsp_sdram.h\n * @author SHUAIWEN CUI (shuaiwencui AT gmail DOT com)\n * @brief This file is the header file for the bsp_sdram.c file\n * @version 1.0\n * @date 2024-07-16\n * @ref https://blog.csdn.net/Believeziwo/article/details/131372421\n */\n#ifndef _BSP_SDRAM_H_\n#define _BSP_SDRAM_H_\n\n/**\n * @name INCLUDES\n *\n */\n#include \"stm32h7xx.h\"\n#include &lt;stdio.h&gt;\n\n/**\n * @name MACROS\n *\n */\n#define W9825G6KH_SIZE (32 * 1024 * 1024) // 32M Bytes W9825G6\n#define FMC_BANK_SDRAM FMC_Bank1_SDRAM\n#define FMC_COMMAND_TARGET_BANK FMC_SDRAM_CMD_TARGET_BANK1\n#define SDRAM_BANK_ADDR ((uint32_t)0xC0000000)\n#define SDRAM_TIMEOUT ((uint32_t)0xFFFF)\n#define SDRAM_MODEREG_BURST_LENGTH_1 ((uint16_t)0x0000)\n#define SDRAM_MODEREG_BURST_LENGTH_2 ((uint16_t)0x0001)\n#define SDRAM_MODEREG_BURST_LENGTH_4 ((uint16_t)0x0002)\n#define SDRAM_MODEREG_BURST_LENGTH_8 ((uint16_t)0x0004)\n#define SDRAM_MODEREG_BURST_TYPE_SEQUENTIAL ((uint16_t)0x0000)\n#define SDRAM_MODEREG_BURST_TYPE_INTERLEAVED ((uint16_t)0x0008)\n#define SDRAM_MODEREG_CAS_LATENCY_2 ((uint16_t)0x0020)\n#define SDRAM_MODEREG_CAS_LATENCY_3 ((uint16_t)0x0030)\n#define SDRAM_MODEREG_OPERATING_MODE_STANDARD ((uint16_t)0x0000)\n#define SDRAM_MODEREG_WRITEBURST_MODE_PROGRAMMED ((uint16_t)0x0000)\n#define SDRAM_MODEREG_WRITEBURST_MODE_SINGLE ((uint16_t)0x0200)\n\n#define SDRAM_DEBUG_ON 1\n#define SDRAM_INFO(fmt, arg...) printf(\"[NODE INITIALIZATION] \" fmt \"\\n\", ##arg)\n#define SDRAM_ERROR(fmt, arg...) printf(\"[NODE INITIALIZATION] \" fmt \"\\n\", ##arg)\n#define SDRAM_DEBUG(fmt, arg...)                                       \\\n    do                                                                 \\\n    {                                                                  \\\n        if (SDRAM_DEBUG_ON)                                            \\\n            printf(\"[NODE INITIALIZATION] [%d]\" fmt \"\\n\", __LINE__, ##arg); \\\n    } while (0)\n\n/**\n * @name FUNCTION PROTOTYPES\n *\n */\nvoid SDRAM_InitSequence(void);\nvoid SDRAM_WriteBuffer(uint32_t *pBuffer, uint32_t uwWriteAddress, uint32_t uwBufferSize);\nvoid SDRAM_ReadBuffer(uint32_t *pBuffer, uint32_t uwReadAddress, uint32_t uwBufferSize);\nuint8_t SDRAM_Test(void);\n\n#endif /* _BSP_SDRAM_H_ */\n</code></pre>"},{"location":"MAIN-CONTROL/SDRAM/sdram/#bsp_sdramc","title":"bsp_sdram.c","text":"<pre><code>/**\n * @file bsp_sdram.c\n * @author SHUAIWEN CUI (shuaiwencui AT gmail DOT com)\n * @brief This file is the source file for the bsp_sdram.c file\n * @version 1.0\n * @date 2024-07-16\n * @ref https://blog.csdn.net/Believeziwo/article/details/131372421\n */\n\n/**\n * @name INCLUDES\n *\n */\n#include \"bsp_sdram.h\"\n#include \"fmc.h\"\n\n/**\n * @name VARIABLES\n *\n */\nstatic FMC_SDRAM_CommandTypeDef Command;\n#define sdramHandle hsdram1 // defined in fmc.c\n\n/**\n * @name FUNCTIONS\n *\n */\n\n/**\n  * @brief  initialize SDRAM in 6 steps\n  * @param  None. \n  * @retval None.\n  * ! This is the core for SDRAM initialization. CubeMX will do FMC initialization, then we need this function to do SDRAM initialization. After that, we can use SDRAM in the application layer.\n  */\nvoid SDRAM_InitSequence(void)\n{\n    uint32_t temp = 0;\n\n    /* Step 1 ----------------------------------------------------------------*/\n    /* CONFIGURE COMMAND: enable the clock for sdram */\n    Command.CommandMode = FMC_SDRAM_CMD_CLK_ENABLE;\n    Command.CommandTarget = FMC_COMMAND_TARGET_BANK;\n    Command.AutoRefreshNumber = 1;\n    Command.ModeRegisterDefinition = 0;\n    /* send command */\n    HAL_SDRAM_SendCommand(&amp;sdramHandle, &amp;Command, SDRAM_TIMEOUT);\n\n    /* delay for a while at least 200us */\n    HAL_Delay(1); // 1ms&gt;200us\n\n    /* Step 3 ----------------------------------------------------------------*/\n    /* CONFIGURE COMMAND: precharge all bank */\n    Command.CommandMode = FMC_SDRAM_CMD_PALL;\n    Command.CommandTarget = FMC_COMMAND_TARGET_BANK;\n    Command.AutoRefreshNumber = 1;\n    Command.ModeRegisterDefinition = 0;\n    /* send command */\n    HAL_SDRAM_SendCommand(&amp;sdramHandle, &amp;Command, SDRAM_TIMEOUT);   \n\n    /* Step 4 ----------------------------------------------------------------*/\n    /* CONFIGURE COMMAND: auto refresh */   \n    Command.CommandMode = FMC_SDRAM_CMD_AUTOREFRESH_MODE;\n    Command.CommandTarget = FMC_COMMAND_TARGET_BANK;\n    Command.AutoRefreshNumber = 8;\n    Command.ModeRegisterDefinition = 0;\n    /* send command */\n    HAL_SDRAM_SendCommand(&amp;sdramHandle, &amp;Command, SDRAM_TIMEOUT);\n\n    /* Step 5 ----------------------------------------------------------------*/\n    /* CONFIGURE SDRAM LOAD MODE register */\n    temp = (uint32_t)SDRAM_MODEREG_BURST_LENGTH_1          |\n                   SDRAM_MODEREG_BURST_TYPE_SEQUENTIAL   |\n                   SDRAM_MODEREG_CAS_LATENCY_3           |\n                   SDRAM_MODEREG_OPERATING_MODE_STANDARD |\n                   SDRAM_MODEREG_WRITEBURST_MODE_SINGLE;\n\n    /* CONFIGURE COMMAND: set SDRAM register */\n    Command.CommandMode = FMC_SDRAM_CMD_LOAD_MODE;\n    Command.CommandTarget = FMC_COMMAND_TARGET_BANK;\n    Command.AutoRefreshNumber = 1;\n    Command.ModeRegisterDefinition = temp;\n    /* send command */\n    HAL_SDRAM_SendCommand(&amp;sdramHandle, &amp;Command, SDRAM_TIMEOUT);\n\n    /* Step 6 ----------------------------------------------------------------*/\n    /* CONFIGURE REFRESH COUNTER */\n  /*\n    (SDRAM refresh period / Number of rows\uff09*SDRAM Clock Speed \u2013 20\n    = 64000(64 ms) / 8192*120MHz - 20\n    = 917.2 ~ 918\n\n    note: 64 / 8192 = 7.81us\n  */\n    /* CONFIGURE REFRESH RATE */\n    HAL_SDRAM_ProgramRefreshRate(&amp;sdramHandle, 918); \n}\n\n/**\n  * @brief  write data to SDRAM in \"word\" format\n  * @param  pBuffer:  pointer to data\n  * @param  uwWriteAddress: address to write in SDRAM\n  * @param  uwBufferSize: size of data to write\n  * @retval None.\n  */\nvoid SDRAM_WriteBuffer(uint32_t* pBuffer, uint32_t uwWriteAddress, uint32_t uwBufferSize)\n{\n  __IO uint32_t write_pointer = (uint32_t)uwWriteAddress;\n\n  /* Disable write protection */\n  HAL_SDRAM_WriteProtection_Disable(&amp;hsdram1);\n  /* Check the SDRAM state */\n  while(HAL_SDRAM_GetState(&amp;hsdram1) != RESET)\n  {\n  }\n\n  /* write data to SDRAM by loops*/\n  for (; uwBufferSize != 0; uwBufferSize--) \n  {\n    /* write data to SDRAM */\n    *(uint32_t *) (SDRAM_BANK_ADDR + write_pointer) = *pBuffer++;\n\n    /* address increment */\n    write_pointer += 4;\n  }\n\n}\n\n/**\n  * @brief  read data from SDRAM\n  * @param  pBuffer: pointer to data\n  * @param  ReadAddress: address to read in SDRAM\n  * @param  uwBufferSize: size of data to read\n  * @retval None.\n  */\nvoid SDRAM_ReadBuffer(uint32_t* pBuffer, uint32_t uwReadAddress, uint32_t uwBufferSize)\n{\n  __IO uint32_t write_pointer = (uint32_t)uwReadAddress;\n\n\n  /* Check the SDRAM state */\n  while ( HAL_SDRAM_GetState(&amp;hsdram1) != RESET)\n  {\n  }\n\n  /* read data from SDRAM */\n  for(; uwBufferSize != 0x00; uwBufferSize--)\n  {\n   *pBuffer++ = *(__IO uint32_t *)(SDRAM_BANK_ADDR + write_pointer );\n\n   /* address increment */\n    write_pointer += 4;\n  } \n}\n\n\n/**\n  * @brief  Test SDRAM\n  * @param  None\n  * @retval normal as 1, abnormal as 0\n  */\nuint8_t SDRAM_Test(void)\n{\n  /* counter for write data */\n  uint32_t counter=0;\n\n  /* 8 bit data */\n  uint8_t ubWritedata_8b = 0, ubReaddata_8b = 0;  \n\n  /* 16 bit data */\n  uint16_t uhWritedata_16b = 0, uhReaddata_16b = 0; \n\n  /* 32 bit data */\n  uint32_t uwWritedata_32b = 0, uwReaddata_32b = 0;\n\n  SDRAM_INFO(\"TESTING SDRAM..., WRITE AND READ AS 8/16/32 BIT...\");\n\n\n  /* 8 bit data read and write*/\n\n  /* reset SDRAM data to 0, W9825G6KH_SIZE is in 8 bit */\n  for (counter = 0x00; counter &lt; W9825G6KH_SIZE; counter++)\n  {\n    *(__IO uint8_t*) (SDRAM_BANK_ADDR + counter) = (uint8_t)0x0;\n  }\n\n  /* write data to SDRAM */\n  for (counter = 0; counter &lt; W9825G6KH_SIZE; counter++)\n  {\n    *(__IO uint8_t*) (SDRAM_BANK_ADDR + counter) = (uint8_t)(ubWritedata_8b + counter);\n  }\n\n  /* read data from SDRAM and check */\n  for(counter = 0; counter&lt;W9825G6KH_SIZE;counter++ )\n  {\n    ubReaddata_8b = *(__IO uint8_t*)(SDRAM_BANK_ADDR + counter);  // read data from SDRAM\n\n    if(ubReaddata_8b != (uint8_t)(ubWritedata_8b + counter))      // check data, if not equal, return 0\n    {\n      SDRAM_ERROR(\"8 BIT DATA READ AND WRITE ERROR!\");\n      return -1;\n    }\n  }\n\n\n  /* 16 bit data read and write*/\n\n  /* reset SDRAM data to 0 */\n  for (counter = 0x00; counter &lt; W9825G6KH_SIZE/2; counter++)\n  {\n    *(__IO uint16_t*) (SDRAM_BANK_ADDR + 2*counter) = (uint16_t)0x00;\n  }\n\n  /* write data to SDRAM */\n  for (counter = 0; counter &lt; W9825G6KH_SIZE/2; counter++)\n  {\n    *(__IO uint16_t*) (SDRAM_BANK_ADDR + 2*counter) = (uint16_t)(uhWritedata_16b + counter);\n  }\n\n  /* read data from SDRAM and check */\n  for(counter = 0; counter&lt;W9825G6KH_SIZE/2;counter++ )\n  {\n    uhReaddata_16b = *(__IO uint16_t*)(SDRAM_BANK_ADDR + 2*counter);  // read data from SDRAM\n\n    if(uhReaddata_16b != (uint16_t)(uhWritedata_16b + counter))      // check data, if not equal, return 0\n    {\n      SDRAM_ERROR(\"16 BIT DATA READ AND WRITE ERROR!\");\n\n      return -1;\n    }\n  }\n\n  /* 32 bit data read and write*/\n  /* reset SDRAM data to 0 */\n  for (counter = 0x00; counter &lt; W9825G6KH_SIZE/4; counter++)\n  {\n    *(__IO uint32_t*) (SDRAM_BANK_ADDR + 4*counter) = (uint32_t)0x00;\n  }\n\n  /* write data to SDRAM */\n  for (counter = 0; counter &lt; W9825G6KH_SIZE/4; counter++)\n  {\n    *(__IO uint32_t*) (SDRAM_BANK_ADDR + 4*counter) = (uint32_t)(uwWritedata_32b + counter);\n  }\n\n  /* read data from SDRAM and check */\n  for(counter = 0; counter&lt;W9825G6KH_SIZE/4;counter++ )\n  {\n    uwReaddata_32b = *(__IO uint32_t*)(SDRAM_BANK_ADDR + 4*counter);  // read data from SDRAM\n\n    if(uwReaddata_32b != (uint32_t)(uwWritedata_32b + counter))      // check data, if not equal, return 0\n    {\n      SDRAM_ERROR(\"32 BIT DATA READ AND WRITE ERROR!\");\n      return -1;\n    }\n  }\n\n  SDRAM_INFO(\"SDRAM READ AND WRITE TEST OK!\"); \n  /* normal, return 0 */\n  return 0;\n\n}\n\n\n/*********************************************END OF FILE**********************/\n</code></pre>"},{"location":"MAIN-CONTROL/SDRAM/sdram/#code-review-memory-management","title":"CODE REVIEW - MEMORY MANAGEMENT","text":"<p>Let's review the code for the memory management module. </p>"},{"location":"MAIN-CONTROL/SDRAM/sdram/#bsp_memoryh","title":"bsp_memory.h","text":"<pre><code>/**\n * @file bsp_memory.h\n * @author SHUAIWEN CUI (shuaiwencui AT gmail DOT com)\n * @brief This is the header file for the memory management module.\n * @version 1.0\n * @date 2024-06-30\n * @ref ALIENTEK memory.h &amp; memory.c for STM32H7xx\n * @copyright Copyright (c) 2024\n *\n *\n */\n\n#ifndef _BSP_MEMORY_H_\n#define _BSP_MEMORY_H_\n\n/**\n * @name INCLUDES\n */\n#include \"stm32h7xx.h\"\n#include &lt;stddef.h&gt;\n#include &lt;stdint.h&gt;\n#include \"bsp_usart.h\"\n#include \"bsp_sdram.h\"\n\n/**\n * @name FUNCTION PROTOTYPES\n */\n/**\n * @name memory_init\n * @brief Initialize the memory management module\n * @param None\n * @retval None\n */\nvoid memory_init(void);\n\n/**\n * @name memory_alloc\n * @brief Allocate memory\n * @param size The size of the memory to allocate\n * @return void*\n */\nvoid *memory_alloc(size_t size);\n\n/**\n * @name memory_free\n * @brief Free memory\n * @param ptr The pointer to the memory to free\n * @retval None\n */\nvoid memory_free(void *ptr);\n\n/**\n * @name memory_management_test\n * @brief This function is for memory management test: allocate memory for a given length, set the values, print the values, and free the memory.\n */\nint memory_management_test(void);\n\n\n#endif /* _BSP_MEMORY_H_ */\n</code></pre>"},{"location":"MAIN-CONTROL/SDRAM/sdram/#bsp_memoryc","title":"bsp_memory.c","text":"<pre><code>/**\n * @file bsp_memory.h\n * @author SHUAIWEN CUI (shuaiwencui AT gmail DOT com)\n * @brief This is the header file for the memory management module.\n * @version 1.0\n * @date 2024-06-30\n * @ref ALIENTEK memory.h &amp; memory.c for STM32H7xx\n * @copyright Copyright (c) 2024\n *\n * ! NOTE:\n * ! The memory management is achieved by using linked lists.\n *\n */\n\n/**\n * @name INCLUDES\n */\n#include \"bsp_memory.h\"\n\n/**\n * @name MACROS\n */\n#define SDRAM_START_ADDR 0xC0000000\n#define SDRAM_SIZE 0x02000000 // 32MB\n\n/**\n * @name list structure for memory management\n */\n// block hearder structure: at the beginning of each block, size indicates the size of the block, next is the pointer to the next free block\ntypedef struct BlockHeader\n{\n    size_t size;              // Block size including header\n    struct BlockHeader *next; // Pointer to the next free block\n} BlockHeader;\n\nstatic BlockHeader *freeList = (BlockHeader *)SDRAM_START_ADDR;\n\n/**\n * @name memory_init\n * @brief Initialize the memory management module\n * @param None\n * @retval None\n */\nvoid memory_init(void)\n{\n    freeList-&gt;size = SDRAM_SIZE;\n    freeList-&gt;next = NULL;\n}\n\n/**\n * @name memory_alloc\n * @brief Allocate memory\n * @param size The size of the memory to allocate\n * @return void*\n */\nvoid *memory_alloc(size_t size)\n{\n    BlockHeader *current = freeList;\n    BlockHeader *previous = NULL;\n\n    // Align size to the size of BlockHeader and to 32-bit boundary\n    size = (size + sizeof(BlockHeader) + sizeof(uint32_t) - 1) &amp; ~(sizeof(uint32_t) - 1);\n\n    while (current)\n    {\n        if (current-&gt;size &gt;= size)\n        {\n            if (current-&gt;size &gt; size + sizeof(BlockHeader))\n            {\n                // Split the block\n                BlockHeader *newBlock = (BlockHeader *)((uint32_t *)current + size / sizeof(uint32_t));\n                newBlock-&gt;size = current-&gt;size - size;\n                newBlock-&gt;next = current-&gt;next;\n                current-&gt;size = size;\n                current-&gt;next = NULL;\n\n                if (previous)\n                {\n                    previous-&gt;next = newBlock;\n                }\n                else\n                {\n                    freeList = newBlock;\n                }\n            }\n            else\n            {\n                // Use the whole block\n                if (previous)\n                {\n                    previous-&gt;next = current-&gt;next;\n                }\n                else\n                {\n                    freeList = current-&gt;next;\n                }\n            }\n            return (void *)((uint32_t *)current + sizeof(BlockHeader) / sizeof(uint32_t));\n        }\n\n        previous = current;\n        current = current-&gt;next;\n    }\n\n    // No suitable block found\n    return NULL;\n}\n\n/**\n * @name memory_free\n * @brief Free memory\n * @param ptr The pointer to the memory to free\n * @retval None\n */\nvoid memory_free(void *ptr)\n{\n    if (!ptr)\n        return;\n\n    BlockHeader *block = (BlockHeader *)((uint32_t *)ptr - sizeof(BlockHeader) / sizeof(uint32_t));\n    BlockHeader *current = freeList;\n    BlockHeader *previous = NULL;\n\n    while (current &amp;&amp; current &lt; block)\n    {\n        previous = current;\n        current = current-&gt;next;\n    }\n\n    if (previous)\n    {\n        previous-&gt;next = block;\n    }\n    else\n    {\n        freeList = block;\n    }\n    block-&gt;next = current;\n\n    // Merge adjacent blocks (optional, for reducing fragmentation)\n    if ((uint32_t *)block + block-&gt;size / sizeof(uint32_t) == (uint32_t *)current)\n    {\n        block-&gt;size += current-&gt;size;\n        block-&gt;next = current-&gt;next;\n    }\n    if (previous &amp;&amp; (uint32_t *)previous + previous-&gt;size / sizeof(uint32_t) == (uint32_t *)block)\n    {\n        previous-&gt;size += block-&gt;size;\n        previous-&gt;next = block-&gt;next;\n    }\n}\n\n/**\n * @name memory_management_test\n * @brief This function is for memory management test: allocate memory for a given length, set the values, print the values, and free the memory.\n */\nint memory_management_test(void)\n{\n    int length = 10;\n\n    int *array = (int *)memory_alloc(length * sizeof(int));\n\n    if (!array)\n    {\n        return -1;\n    }\n\n    for (int i = 0; i &lt; length; i++)\n    {\n        array[i] = i;\n    }\n\n    for (int i = 0; i &lt; length; i++)\n    {\n        printf(\"array[%d] = %d\\n\", i, array[i]);\n    }\n\n    memory_free(array);\n\n    return 0;\n}\n</code></pre>"},{"location":"MAIN-CONTROL/SDRAM/sdram/#explanation","title":"EXPLANATION","text":"<p>The isdram module provides basic SDRAM memory interaction functions, but these drivers alone are not enough. We also need a memory management module to handle memory allocation and deallocation in SDRAM. The imemory module provides memory management functionality by using a linked list to manage the memory in SDRAM. This allows us to allocate, use, and free memory in SDRAM without worrying about specific addresses, greatly simplifying our development.</p>"},{"location":"MAIN-CONTROL/SETUP/setup/","title":"SETUP","text":"<p>Note</p> <p>'SETUP' refers to node configuration and initialization. This step means to configure the basic information, functional modules of the hardware, controlling the BSP, Peripheral, and other systems. </p>"},{"location":"MAIN-CONTROL/SETUP/setup/#how-to-setup","title":"HOW TO SETUP","text":"<p>There is a standalone folder named 'Setup' in both the file structure and the project structure. To modify the configuration for node initialization, you just need to modify the parameters and macros in either the .h or the .c file.</p>"},{"location":"MAIN-CONTROL/SETUP/setup/#setup-scope","title":"SETUP SCOPE","text":"<p>'Setup' covers almost all important configurable information, modules, macros, and variables.</p>"},{"location":"MAIN-CONTROL/SETUP/setup/#code","title":"CODE","text":""},{"location":"MAIN-CONTROL/SETUP/setup/#setuph","title":"setup.h","text":"<pre><code>/**\n * @file setup.h\n * @author SHUAIWEN CUI (SHUAIWEN001 AT e DOT ntu DOT edu DOT sg)\n * @brief This file is for MCU node configuration and initialization setup.\n * @version 1.0\n * @date 2024-07-12\n *\n * @copyright Copyright (c) 2024\n *\n */\n#ifndef _SETUP_H_\n#define _SETUP_H_\n\n/**\n * @name MACROS\n */\n#define NODE_SUCCESS 0\n#define NODE_FAIL 1\n\n/**\n * @name CONFIGURATION\n * @brief This section is to determine the modules to be included in the project\n * ! This is where you configure the modules to be included in the project\n * @param MODULE_ENABLE_LED //! Enable LED module\n * @param MODULE_ENABLE_USART //! Enable USART\n * @param MODULE_ENABLE_SDRAM //! Enable SDRAM module to use external RAM for computation\n * @param MODULE_ENABLE_MEMORY //! Enable Memory module - for memory management on SDRAM\n * @param MODULE_ENABLE_SDCARD //! Enable SD Card module- for SD Card basic io. !!! This module can not be used together with MODULE_ENABLE_FILE. Better to disable this and use the MODULE_ENABLE_FILE. Enabling FATFS in CubeMX may lead to fail of this option, and you may need to reformat the SD card before using next time.\n * @param MODULE_ENABLE_FILE //! Enable File module - for file operations on SD Card !!! This module can not be used together with MODULE_ENABLE_SDCARD. Better to enable this.\n */\n#define MODULE_ENABLE_LED // Enable LED module\n#define MODULE_ENABLE_USART // Enable USART module\n#define MODULE_ENABLE_SDRAM  // Enable SDRAM module\n#define MODULE_ENABLE_MEMORY // Enable Memory module - for memory management on SDRAM\n// #define MODULE_ENABLE_SDCARD // Enable SD Card module\n#define MODULE_ENABLE_FILE   // Enable File module - for file operations on SD Card\n\n// Necessary Libraries\n#include &lt;stdio.h&gt;\n\n// LED for Status Indication\n#ifdef MODULE_ENABLE_LED\n#include \"bsp_led.h\"\n#endif\n\n#ifdef MODULE_ENABLE_USART //! Note - Do rember to check the MicroLib option in the project settings\n#include \"bsp_usart.h\"\n#endif\n\n#ifdef MODULE_ENABLE_SDRAM\n#include \"bsp_sdram.h\"\n#endif\n\n#ifdef MODULE_ENABLE_MEMORY\n#include \"bsp_memory.h\"\n#endif\n\n#ifdef MODULE_ENABLE_SDCARD\n#include \"bsp_sdcard.h\"\n#endif\n\n#ifdef MODULE_ENABLE_FILE\n#include \"bsp_file.h\"\n#endif\n\n/**\n * @name NODE INFORMATION\n */\n\n/**\n * @name FUNCTION PROTOTYPING\n */\n\n/**\n * @name Node_Init\n * @brief This function is for board initialization, with configurable initialization test incorporated.\n */\nint Node_Init(void);\n\n#ifdef MODULE_ENABLE_USART\n// IO retargetting\nint fputc(int ch, FILE *f);\nint fgetc(FILE *f);\n#endif\n\n#endif /* _SETUP_H_ */\n</code></pre>"},{"location":"MAIN-CONTROL/SETUP/setup/#setupc","title":"setup.c","text":"<pre><code>/**\n * @file setup.c\n * @author SHUAIWEN CUI (SHUAIWEN001 AT e DOT ntu DOT edu DOT sg)\n * @brief This file is for MCU node configuration and initialization setup.\n * @version 1.0\n * @date 2024-07-12\n *\n * @copyright Copyright (c) 2024\n *\n */\n#include \"setup.h\"\n\n/**\n * @name INITIALIZATION TEST\n * @brief This determines whether to conduct test when initializing the node. To disenable, comment it out.\n */\nint init_test_mode = 0; // 0 for not, 1 for yes.\n\n/**\n * @name VARIABLES\n *\n */\n// The gap between the initialization of each module, in ms.\nint Init_Gap = 300;\n\n/**\n * @name Node_Init\n * @brief This function is for board initialization, with configurable initialization test incorporated.\n */\nint Node_Init(void)\n{\n    // Variables\n    int i;\n\n    // COMPONNET-LED\n#ifdef MODULE_ENABLE_LED\n    LED(0);                  // for deployment, switch off the LED to save power\n    if (init_test_mode == 1) // for debugging, flash the LED to indicate status\n    {\n        LED(1);\n        HAL_Delay(200);\n        LED(0);\n        HAL_Delay(200);\n        LED(1);\n    }\n#endif\n\n    // COMPONENT-USART-SERIAL Communication\n#ifdef MODULE_ENABLE_USART\n    if (init_test_mode == 1)\n    {\n        for (i = 0; i &lt; 3; i++)\n        {\n            printf(\"[NODE INITIALIZATION] Count Down for Upcoming Testing: %d \\n\\r\", 3 - i);\n            HAL_Delay(1000);\n        }\n        printf(\"\\n\\r\");\n    }\n    printf(\"[NODE INITIALIZATION] Serial Communication - SUCCESS.\\n\\r\\n\\r\");\n#endif\n\n    HAL_Delay(Init_Gap); // to give the user enough time to connect to the serial terminal\n\n    // COMPONENT-SDRAM\n#ifdef MODULE_ENABLE_SDRAM\n    // BSP Initialization - SDRAM\n    printf(\"[NODE INITIALIZATION] SDRAM Initialization - START.\\n\\r\");\n    SDRAM_InitSequence();\n    printf(\"[NODE INITIALIZATION] SDRAM Initialization - DONE.\\n\\r\\n\\r\");\n    if (init_test_mode == 1)\n    {\n        if (SDRAM_Test() == 0)\n        {\n            printf(\"[NODE INITIALIZATION] SDRAM TEST - SUCCESS.\\n\\r\\n\\r\");\n        }\n        else\n        {\n            printf(\"[NODE INITIALIZATION] SDRAM TEST - FAIL.\\n\\r\\n\\r\");\n        }\n    }\n#endif\n\n    HAL_Delay(Init_Gap);\n\n    // COMPONENT-MEMORY MANAGEMENT - SDRAM\n#ifdef MODULE_ENABLE_MEMORY\n    printf(\"[NODE INITIALIZATION] Memory Management Initialization - START.\\n\\r\");\n    memory_init();\n    printf(\"[NODE INITIALIZATION] Memory Management Initialization - DONE.\\n\\r\\n\\r\");\n    if (init_test_mode == 1)\n    {\n        printf(\"[NODE INITIALIZATION] Memory Management Test - START.\\n\\r\");\n        if (memory_management_test() == 0)\n        {\n            printf(\"[NODE INITIALIZATION] Memory Management Test - SUCCESS.\\n\\r\\n\\r\");\n        }\n        else\n        {\n            printf(\"[NODE INITIALIZATION] Memory Management Test - FAIL.\\n\\r\\n\\r\");\n        }\n    }\n#endif\n\n    HAL_Delay(Init_Gap);\n\n    // COMPONENT-SDCARD (If you use FATFS, don't enable this.)\n#ifdef MODULE_ENABLE_SDCARD\n    printf(\"[NODE INITIALIZATION] SD Card Initialization - START.\\n\\r\");\n    SD_Init();\n    printf(\"[NODE INITIALIZATION] SD CARD Initialization - DONE.\\n\\r\");\n    if (init_test_mode == 1)\n    {\n        // SD Card Test\n        printf(\"[NODE INITIALIZATION] SD Card Test - START.\\n\\r\");\n        SD_Test();\n        printf(\"[NODE INITIALIZATION] SD Card Test - DONE.\\n\\r\");\n    }\n#endif\n\n    HAL_Delay(Init_Gap);\n\n#ifdef MODULE_ENABLE_FILE // the test is kept outside the test zone, as sd card hard conenction is not quite stable, and we need the test to ensure the connection is okay\n\n    printf(\"[NODE INITIALIZATION] SD Card File IO Initialization and Test - START.\\n\\r\");\n    printf(\"\\n\\r\");\n\n    // mount the file system\n    printf(\"[NODE INITIALIZATION] Mounting the file system.\\n\\r\");\n    Mount_FatFs();\n    printf(\"\\n\\r\");\n\n    // get disk information\n    printf(\"[NODE INITIALIZATION] Getting disk information.\\n\\r\");\n    FatFs_GetDiskInfo();\n    printf(\"\\n\\r\");\n\n    if (init_test_mode == 1)\n    {\n        // scan the directory\n        printf(\"[NODE INITIALIZATION] Scanning the directory.\\n\\r\");\n        FatFs_ScanDir(\"0:/\");\n        printf(\"\\n\\r\");\n\n        // write a text file\n        printf(\"[NODE INITIALIZATION] Writing a text file.\\n\\r\");\n        FatFs_WriteTXTFile(\"test.txt\", 2016, 11, 15);\n        printf(\"\\n\\r\");\n\n        // read a text file\n        printf(\"[NODE INITIALIZATION] Reading a text file.\\n\\r\");\n        FatFs_ReadTXTFile(\"test.txt\");\n        printf(\"\\n\\r\");\n\n        // get file information\n        printf(\"[NODE INITIALIZATION] Getting file information.\\n\\r\");\n        FatFs_GetFileInfo(\"test.txt\");\n        printf(\"\\n\\r\");\n\n        // delete a file\n        printf(\"[NODE INITIALIZATION] Deleting a file.\\n\\r\");\n        FatFs_DeleteFile(\"test.txt\");\n        printf(\"\\n\\r\");\n    }\n    printf(\"[NODE INITIALIZATION] SD Card FATFS File IO Initialization - DONE.\\n\\r\\n\\r\");\n#endif\n\n    return NODE_SUCCESS;\n}\n\n#ifdef MODULE_ENABLE_USART\n// MicroLib needed for retargetting\n// retarget fputc for printf\nint fputc(int ch, FILE *f)\n{\n    uint8_t temp = (uint8_t)ch;\n    HAL_UART_Transmit(&amp;huart1, &amp;temp, 1, HAL_MAX_DELAY);\n    return ch;\n}\n\n// retarget fgetc for scanf\nint fgetc(FILE *f)\n{\n    while (__HAL_UART_GET_FLAG(&amp;huart1, UART_FLAG_RXNE) == RESET)\n        ;                                      // Wait until the data is received\n    return (int)(huart1.Instance-&gt;RDR &amp; 0xFF); // Read the received data\n}\n#endif\n</code></pre>"},{"location":"MAIN-CONTROL/USART/usart-interactive/","title":"USART","text":"<p>USART can be used for many different purposes, and for now, only USART1 is used for serial communication.</p> <p>Alert</p> <p>This version is used for interactive version, the interruption and DMA for usart1 are not enabled. Therefore, the message input and output are in blocking mode.</p>"},{"location":"MAIN-CONTROL/USART/usart-interactive/#usart1-circuit","title":"USART1 CIRCUIT","text":"<p>As can be seen from the circuit design, the RX and TX for USART1 are PA9 and PA10, respectively. However, the default choices are not, so we need to change them manually at the pin configuration at the right hand side of the screen.</p>"},{"location":"MAIN-CONTROL/USART/usart-interactive/#usart1-configuration","title":"USART1 CONFIGURATION","text":""},{"location":"MAIN-CONTROL/USART/usart-interactive/#parameter-setup","title":"PARAMETER SETUP","text":"<p>Select 'Parameter Settings' to setup parameters for USART1. Let's keep the default settings for now.</p>"},{"location":"MAIN-CONTROL/USART/usart-interactive/#generate-and-update-code","title":"GENERATE AND UPDATE CODE","text":"<p>Finally, let's generate the code to save the current progress and to make it ready for following programming steps. Click the 'Generate Code' button at the top right corner of the screen.</p>"},{"location":"MAIN-CONTROL/USART/usart-interactive/#programming-in-keil","title":"PROGRAMMING IN KEIL","text":""},{"location":"MAIN-CONTROL/USART/usart-interactive/#incorporate-the-module-code","title":"INCORPORATE THE MODULE CODE","text":"<p>We have introduced how to transplant and incorporate the BSP code into the project, and that applies to each respective module. For transplantation:</p> <ol> <li>Copy the module codes from the BSP project to the user project.</li> <li>Add the module codes to the user project include path.</li> <li>Add the module codes to the project items.</li> <li>Include the header file of the module code in the user project.</li> <li>Call the module function in the user project.</li> </ol> <p>Tip</p> <p>Do remember to check the 'Use MicroLib' to enable the print out function in the 'Options for Target' -&gt; 'Target' -&gt; 'Code Generation' -&gt; 'Use MicroLib'.</p>"},{"location":"MAIN-CONTROL/USART/usart-interactive/#code-review-usart","title":"CODE REVIEW - USART","text":"<p>Let's review the code for the USART module. </p>"},{"location":"MAIN-CONTROL/USART/usart-interactive/#iusarth","title":"iusart.h","text":"<pre><code>/**\n * @file iusart.h\n * @author SHUAIWEN CUI (shuaiwencui AT gmail DOT com)\n * @brief This is the header file for the iusart.c file\n * @version 1.0\n * @date 2024-06-24\n * \n * @copyright Copyright (c) 2024\n * \n */\n\n#ifndef IUSART_H_\n#define IUSART_H_\n\n/**\n * ! INCLUDES\n */\n\n#include \"stm32h7xx_hal.h\" // HAL library file declaration, replace it with the corresponding file according to the actual situation\n#include &lt;string.h&gt; // Library for string processing\n#include &lt;stdarg.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;stdbool.h&gt;\n#include &lt;stdint.h&gt;\n#include &lt;stdio.h&gt;\n//#include \"iled.h\"\n// #include \"../tim/tim.h\"\n\n\n/**\n * ! MACROS\n * ! Note that TX_BUF_SIZE and RX_BUF_SIZE are the caps for the TX_BUF and RX_BUF arrays, adjust them accordingly.\n * ! Note for receiving, if you use interrupt mode, the interrupt will only be triggered when the buffer RX_BUF is full, assuming you are using the HAL_UART_RxCpltCallback function.\n */\n\n\n// #define TX_MODE 2 // Define the transmission mode: 0 - blocking mode (not recommended), 1 - interrupt mode (* recommended), and 2 - DMA mode (** recommended) !!! note that mode 2 sometimes does not work, not sure about the reason.\n// #define RX_MODE 3 // Define the reception mode: 0 - blocking mode (not recommended), 1 - interrupt mode (recommended), and 2 - DMA mode (recommended); 3 - DMA IDLE mode (recommended) (only when IDLE_MODE is enabled)\n\n// //IDLE mode means non fixed length of data, the data is received until the idle line is detected\n// #if RX_MODE &gt;= 3\n// #define IDLE_MODE \n// #endif\n\n// #define TX_BUF_SIZE 512 // Define the size of the sending buffer\n// #define RX_BUF_SIZE 128 // Define the size of the receiving buffer. \n// #define RX_IDLE_BUF_SIZE 512 // Define the size of the idle receiving buffer (IDEL Mode)\n\n/**\n * ! VARIABLES\n * \n */\nextern UART_HandleTypeDef huart1;// Declare the HAL library structure of USART1\nextern DMA_HandleTypeDef hdma_usart1_rx; // Declare the HAL library structure of DMA for USART1\n// extern char RX_BUF[RX_BUF_SIZE]; // Define the receiving buffer\n// extern char RX_IDLE_BUF[RX_IDLE_BUF_SIZE];\n\n\n/**\n * ! FUNCTION PROTOTYPES\n * \n */\n\n// void MCU_serial_init(void);\n// void MCU_send(uint8_t *pData, uint16_t size); // lower level function wrapped by MCU_printf\n// void MCU_printf(const char *format, ...);\n\n// #ifndef IDLE_MODE\n// void HAL_UART_RxCpltCallback(UART_HandleTypeDef  *huart); \n// #else\n// void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t size);\n// #endif\n\n\n#endif /* IUSART_H_ */\n</code></pre>"},{"location":"MAIN-CONTROL/USART/usart-interactive/#iusartc","title":"iusart.c","text":"<pre><code>/**\n * @file iusart.c\n * @author SHUAIWEN CUI (shuaiwencui@gmail.com)\n * @brief This is the source file for the iusart.c file\n * @version 1.0\n * @date 2024-06-24\n *\n * @copyright Copyright (c) 2024\n *\n */\n\n// #include \"iusart.h\"\n\n// /**\n//  * @name test part\n//  *\n//  */\n\n// char RX_BUF[RX_BUF_SIZE];           // Define the receiving buffer\n// char RX_IDLE_BUF[RX_IDLE_BUF_SIZE]; // Define the idle receiving buffer (IDEL Mode)\n\n// /**\n//  * @name MCU_serial_init\n//  * @brief This function is used to initialize the USART1, and the reception method is according to the reception mode RX_MODE defined in the iusart.h file. The normal mode is the blocking mode, not recommended as it will block the main loop and causes waste of CPU resources; the interrupt mode is recommended; and the DMA mode is the most recommended.\n//  *\n//  */\n// void MCU_serial_init(void)\n// {\n//     // Note the last element in the buffer can be \"\\n\", as every time you send message from PC, a \"\\n\" is appended to the end of your message.\n\n//     if (RX_MODE == 0)\n//     {\n//         HAL_UART_Receive(&amp;huart1, (uint8_t *)&amp;RX_BUF, RX_BUF_SIZE, HAL_MAX_DELAY); // Initial receive\n//         // memset(RX_BUF, 0, sizeof(RX_BUF));\n//     }\n//     else if (RX_MODE == 1)\n//     {\n//         HAL_UART_Receive_IT(&amp;huart1, (uint8_t *)&amp;RX_BUF, RX_BUF_SIZE); // Enable receive interrupt\n//         // memset(RX_BUF, 0, sizeof(RX_BUF));\n//     }\n//     else if (RX_MODE == 2)\n//     {\n//         HAL_UART_Receive_DMA(&amp;huart1, (uint8_t *)&amp;RX_BUF, RX_BUF_SIZE); // Enable receive interrupt\n//         // memset(RX_BUF, 0, sizeof(RX_BUF));\n//     }\n//     else if (RX_MODE == 3)\n//     {\n//         // Enable the idle mode DMA reception\n//         HAL_UARTEx_ReceiveToIdle_DMA(&amp;huart1, (uint8_t *)&amp;RX_IDLE_BUF, sizeof(RX_IDLE_BUF)); // Enable receive interrupt\n//         // memset(RX_IDLE_BUF, 0, sizeof(RX_IDLE_BUF));\n//         // __HAL_DMA_DISABLE_IT(&amp;hdma_usart1_rx, DMA_IT_HT); // Disable the half-transfer interrupt\n//     }\n// }\n\n// /**\n//  * @name MCU_Send\n//  * @brief This function is used to send data through the USART1, and the transmission method is according to the transmission mode TX_MODE defined in the iusart.h file\n//  * @param pData: The pointer to the data to be sent\n//  * @param size: The size of the data to be sent\n//  * @retval None\n//  *\n//  */\n// void MCU_send(uint8_t *pData, uint16_t size)\n// {\n//     if (TX_MODE == 0) // blocking mode - not recommended\n//     {\n//         HAL_UART_Transmit(&amp;huart1, pData, size, HAL_MAX_DELAY);\n//     }\n//     else if (TX_MODE == 1) // interrupt mode - recommended\n//     {\n//         HAL_UART_Transmit_IT(&amp;huart1, pData, size);\n//     }\n//     else if (TX_MODE == 2) // DMA mode - recommended\n//     {\n//         HAL_UART_Transmit_DMA(&amp;huart1, pData, size);\n//     }\n// }\n\n// /**\n//  * @name MCU_printf\n//  * @brief This function is used to send formatted data through the USART1, and the transmission method is according to the transmission mode TX_MODE defined in the iusart.h file\n//  * @param format: The pointer to the formatted string to be sent\n//  * @param ...: The arguments to be formatted\n//  * @retval None\n//  *\n//  */\n// void MCU_printf(const char *format, ...)\n// {\n//     char TX_BUF[TX_BUF_SIZE]; // Define the sending buffer\n//     va_list args;\n//     va_start(args, format);\n//     vsnprintf(TX_BUF, TX_BUF_SIZE, format, args);\n//     va_end(args);\n//     MCU_send((uint8_t *)TX_BUF, strlen(TX_BUF));\n// }\n\n// #ifndef IDLE_MODE\n// /**\n//  * @name HAL_UART_RxCpltCallback\n//  * @brief This function is the callback function for the USART1 receive interrupt, and the received data is stored in the RX_BUF array\n//  *\n//  */\n\n// void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) // Serial port interrupt callback function\n// {\n//     if (huart == &amp;huart1) // Determine the source of the interrupt (serial port 1: USB to serial port)\n//     {\n//         if (RX_MODE == 1)\n//         {\n//             MCU_send((uint8_t *)RX_BUF, strlen(RX_BUF));\n//             HAL_UART_Receive_IT(&amp;huart1, (uint8_t *)&amp;RX_BUF, RX_BUF_SIZE); // Enable receive interrupt\n//         }\n//         else if (RX_MODE == 2)\n//         {\n//             MCU_send((uint8_t *)RX_BUF, strlen(RX_BUF));\n//             HAL_UART_Receive_DMA(&amp;huart1, (uint8_t *)&amp;RX_BUF, RX_BUF_SIZE); // Enable receive interrupt\n//         }\n//     }\n// }\n\n// #else\n\n// /**\n//  * @name HAL_UARTEx_RxEventCallback\n//  * @brief This function is the callback function for the USART1 receive idle interrupt, and the received data is stored in the RX_BUF array\n//  * ! Note: this function has higher priority than HAL_UART_RxCpltCallback, if this function is defined, HAL_UART_RxCpltCallback will not be called\n//  *\n//  */\n// void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t size)\n// {\n//     if (huart == &amp;huart1) // Determine the source of the interrupt (serial port 1: USB to serial port)\n//     {\n//         if (RX_MODE == 3)\n//         {\n//             MCU_send((uint8_t *)RX_IDLE_BUF, size);                                              //! the size here is provided by the passed parameter size\n//             HAL_UARTEx_ReceiveToIdle_DMA(&amp;huart1, (uint8_t *)&amp;RX_IDLE_BUF, sizeof(RX_IDLE_BUF)); // Enable receive interrupt\n//             // __HAL_DMA_DISABLE_IT(&amp;hdma_usart1_rx, DMA_IT_HT);                                    // Disable the half-transfer interrupt\n//             //    memset(RX_IDLE_BUF, 0, sizeof(RX_IDLE_BUF));\n//         }\n//     }\n// }\n// #endif\n</code></pre>"},{"location":"MAIN-CONTROL/USART/usart/","title":"USART","text":"<p>USART can be used for many different purposes, and for now, only USART1 is used for serial communication.</p> <p>Alert</p> <p>This version is used for non-interactive version, as interruption and DMA features are enabled, kind of difficult to do interactive menu. For interactive version, please refer to the 'interactive' version.</p>"},{"location":"MAIN-CONTROL/USART/usart/#usart1-circuit","title":"USART1 CIRCUIT","text":"<p>As can be seen from the circuit design, the RX and TX for USART1 are PA9 and PA10, respectively. However, the default choices are not, so we need to change them manually at the pin configuration at the right hand side of the screen.</p>"},{"location":"MAIN-CONTROL/USART/usart/#usart1-configuration","title":"USART1 CONFIGURATION","text":""},{"location":"MAIN-CONTROL/USART/usart/#parameter-setup","title":"PARAMETER SETUP","text":"<p>Select 'Parameter Settings' to setup parameters for USART1. Let's keep the default settings for now.</p>"},{"location":"MAIN-CONTROL/USART/usart/#dma-setup","title":"DMA SETUP","text":"<p>Info</p> <p>DMA stands for Direct Memory Access. It is a feature that allows peripherals to access memory without involving the CPU. This can greatly reduce the CPU load and improve the system performance.</p> <p></p> <p>Let's create two DMA channels for USART1. One for transmitting data and the other for receiving data.</p>"},{"location":"MAIN-CONTROL/USART/usart/#nvic-setup","title":"NVIC SETUP","text":"<p>Info</p> <p>NVIC stands for Nested Vectored Interrupt Controller. It is a feature that allows the MCU to prioritize interrupts and manage them efficiently.</p> <p></p> <p>Here, let's enable the USART1 global interrupt. Note that for DMA, the interrupts are by default enabled once you enable the DMA channels.</p>"},{"location":"MAIN-CONTROL/USART/usart/#generate-and-update-code","title":"GENERATE AND UPDATE CODE","text":"<p>Finally, let's generate the code to save the current progress and to make it ready for following programming steps. Click the 'Generate Code' button at the top right corner of the screen.</p>"},{"location":"MAIN-CONTROL/USART/usart/#programming-in-keil","title":"PROGRAMMING IN KEIL","text":""},{"location":"MAIN-CONTROL/USART/usart/#incorporate-the-module-code","title":"INCORPORATE THE MODULE CODE","text":"<p>We have introduced how to transplant and incorporate the BSP code into the project, and that applies to each respective module. For transplantation:</p> <ol> <li>Copy the module codes from the BSP project to the user project.</li> <li>Add the module codes to the user project include path.</li> <li>Add the module codes to the project items.</li> <li>Include the header file of the module code in the user project.</li> <li>Call the module function in the user project.</li> </ol> <p>Tip</p> <p>Do remember to check the 'Use MicroLib' to enable the print out function in the 'Options for Target' -&gt; 'Target' -&gt; 'Code Generation' -&gt; 'Use MicroLib'.</p>"},{"location":"MAIN-CONTROL/USART/usart/#code-review-usart","title":"CODE REVIEW - USART","text":"<p>Let's review the code for the USART module. </p>"},{"location":"MAIN-CONTROL/USART/usart/#bsp_usarth","title":"bsp_usart.h","text":"<pre><code>/**\n * @file bsp_usart.h\n * @author SHUAIWEN CUI (shuaiwencui AT gmail DOT com)\n * @brief This is the header file for the bsp_usart.c file\n * @version 1.0\n * @date 2024-06-24\n * \n * @copyright Copyright (c) 2024\n * \n */\n\n#ifndef _BSP_USART_H_\n#define _BSP_USART_H_\n\n/**\n * ! INCLUDES\n */\n\n#include \"stm32h7xx_hal.h\" // HAL library file declaration, replace it with the corresponding file according to the actual situation\n#include &lt;string.h&gt; // Library for string processing\n#include &lt;stdarg.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;stdbool.h&gt;\n#include &lt;stdint.h&gt;\n#include &lt;stdio.h&gt;\n//#include \"iled.h\"\n// #include \"../tim/tim.h\"\n\n\n/**\n * ! MACROS\n * ! Note that TX_BUF_SIZE and RX_BUF_SIZE are the caps for the TX_BUF and RX_BUF arrays, adjust them accordingly.\n * ! Note for receiving, if you use interrupt mode, the interrupt will only be triggered when the buffer RX_BUF is full, assuming you are using the HAL_UART_RxCpltCallback function.\n */\n\n\n#define TX_MODE 2 // Define the transmission mode: 0 - blocking mode (not recommended), 1 - interrupt mode (* recommended), and 2 - DMA mode (** recommended) !!! note that mode 2 sometimes does not work, not sure about the reason.\n#define RX_MODE 3 // Define the reception mode: 0 - blocking mode (not recommended), 1 - interrupt mode (recommended), and 2 - DMA mode (recommended); 3 - DMA IDLE mode (recommended) (only when IDLE_MODE is enabled)\n\n//IDLE mode means non fixed length of data, the data is received until the idle line is detected\n#if RX_MODE &gt;= 3\n#define IDLE_MODE \n#endif\n\n#define TX_BUF_SIZE 512 // Define the size of the sending buffer\n#define RX_BUF_SIZE 128 // Define the size of the receiving buffer. \n#define RX_IDLE_BUF_SIZE 512 // Define the size of the idle receiving buffer (IDEL Mode)\n\n/**\n * ! VARIABLES\n * \n */\nextern UART_HandleTypeDef huart1;// Declare the HAL library structure of USART1\nextern DMA_HandleTypeDef hdma_usart1_rx; // Declare the HAL library structure of DMA for USART1\nextern char RX_BUF[RX_BUF_SIZE]; // Define the receiving buffer\nextern char RX_IDLE_BUF[RX_IDLE_BUF_SIZE];\n\n\n/**\n * ! FUNCTION PROTOTYPES\n * \n */\n\nvoid MCU_serial_init(void);\nvoid MCU_send(uint8_t *pData, uint16_t size); // lower level function wrapped by MCU_printf\nvoid MCU_printf(const char *format, ...);\n\n#ifndef IDLE_MODE\nvoid HAL_UART_RxCpltCallback(UART_HandleTypeDef  *huart); \n#else\nvoid HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t size);\n#endif\n\n\n#endif /* _BSP_USART_H_ */\n</code></pre>"},{"location":"MAIN-CONTROL/USART/usart/#bsp_usartc","title":"bsp_usart.c","text":"<pre><code>/**\n * @file bsp_usart.c\n * @author SHUAIWEN CUI (shuaiwencui@gmail.com)\n * @brief This is the source file for the bsp_usart.c file\n * @version 1.0\n * @date 2024-06-24\n *\n * @copyright Copyright (c) 2024\n *\n */\n\n#include \"bsp_usart.h\"\n\n/**\n * @name test part\n *\n */\n\nchar RX_BUF[RX_BUF_SIZE];           // Define the receiving buffer\nchar RX_IDLE_BUF[RX_IDLE_BUF_SIZE]; // Define the idle receiving buffer (IDEL Mode)\n\n/**\n * @name MCU_serial_init\n * @brief This function is used to initialize the USART1, and the reception method is according to the reception mode RX_MODE defined in the bsp_usart.h file. The normal mode is the blocking mode, not recommended as it will block the main loop and causes waste of CPU resources; the interrupt mode is recommended; and the DMA mode is the most recommended.\n *\n */\nvoid MCU_serial_init(void)\n{\n    // Note the last element in the buffer can be \"\\n\", as every time you send message from PC, a \"\\n\" is appended to the end of your message.\n\n    if (RX_MODE == 0)\n    {\n        HAL_UART_Receive(&amp;huart1, (uint8_t *)&amp;RX_BUF, RX_BUF_SIZE, HAL_MAX_DELAY); // Initial receive\n        // memset(RX_BUF, 0, sizeof(RX_BUF));\n    }\n    else if (RX_MODE == 1)\n    {\n        HAL_UART_Receive_IT(&amp;huart1, (uint8_t *)&amp;RX_BUF, RX_BUF_SIZE); // Enable receive interrupt\n        // memset(RX_BUF, 0, sizeof(RX_BUF));\n    }\n    else if (RX_MODE == 2)\n    {\n        HAL_UART_Receive_DMA(&amp;huart1, (uint8_t *)&amp;RX_BUF, RX_BUF_SIZE); // Enable receive interrupt\n        // memset(RX_BUF, 0, sizeof(RX_BUF));\n    }\n    else if (RX_MODE == 3)\n    {\n        // Enable the idle mode DMA reception\n        HAL_UARTEx_ReceiveToIdle_DMA(&amp;huart1, (uint8_t *)&amp;RX_IDLE_BUF, sizeof(RX_IDLE_BUF)); // Enable receive interrupt\n        // memset(RX_IDLE_BUF, 0, sizeof(RX_IDLE_BUF));\n        // __HAL_DMA_DISABLE_IT(&amp;hdma_usart1_rx, DMA_IT_HT); // Disable the half-transfer interrupt\n    }\n}\n\n/**\n * @name MCU_Send\n * @brief This function is used to send data through the USART1, and the transmission method is according to the transmission mode TX_MODE defined in the bsp_usart.h file\n * @param pData: The pointer to the data to be sent\n * @param size: The size of the data to be sent\n * @retval None\n *\n */\nvoid MCU_send(uint8_t *pData, uint16_t size)\n{\n    if (TX_MODE == 0) // blocking mode - not recommended\n    {\n        HAL_UART_Transmit(&amp;huart1, pData, size, HAL_MAX_DELAY);\n    }\n    else if (TX_MODE == 1) // interrupt mode - recommended\n    {\n        HAL_UART_Transmit_IT(&amp;huart1, pData, size);\n    }\n    else if (TX_MODE == 2) // DMA mode - recommended\n    {\n        HAL_UART_Transmit_DMA(&amp;huart1, pData, size);\n    }\n}\n\n/**\n * @name MCU_printf\n * @brief This function is used to send formatted data through the USART1, and the transmission method is according to the transmission mode TX_MODE defined in the bsp_usart.h file\n * @param format: The pointer to the formatted string to be sent\n * @param ...: The arguments to be formatted\n * @retval None\n *\n */\nvoid MCU_printf(const char *format, ...)\n{\n    char TX_BUF[TX_BUF_SIZE]; // Define the sending buffer\n    va_list args;\n    va_start(args, format);\n    vsnprintf(TX_BUF, TX_BUF_SIZE, format, args);\n    va_end(args);\n    MCU_send((uint8_t *)TX_BUF, strlen(TX_BUF));\n}\n\n#ifndef IDLE_MODE\n/**\n * @name HAL_UART_RxCpltCallback\n * @brief This function is the callback function for the USART1 receive interrupt, and the received data is stored in the RX_BUF array\n *\n */\n\nvoid HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) // Serial port interrupt callback function\n{\n    if (huart == &amp;huart1) // Determine the source of the interrupt (serial port 1: USB to serial port)\n    {\n        if (RX_MODE == 1)\n        {\n            MCU_send((uint8_t *)RX_BUF, strlen(RX_BUF));\n            HAL_UART_Receive_IT(&amp;huart1, (uint8_t *)&amp;RX_BUF, RX_BUF_SIZE); // Enable receive interrupt\n        }\n        else if (RX_MODE == 2)\n        {\n            MCU_send((uint8_t *)RX_BUF, strlen(RX_BUF));\n            HAL_UART_Receive_DMA(&amp;huart1, (uint8_t *)&amp;RX_BUF, RX_BUF_SIZE); // Enable receive interrupt\n        }\n    }\n}\n\n#else\n\n/**\n * @name HAL_UARTEx_RxEventCallback\n * @brief This function is the callback function for the USART1 receive idle interrupt, and the received data is stored in the RX_BUF array\n * ! Note: this function has higher priority than HAL_UART_RxCpltCallback, if this function is defined, HAL_UART_RxCpltCallback will not be called\n *\n */\nvoid HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t size)\n{\n    if (huart == &amp;huart1) // Determine the source of the interrupt (serial port 1: USB to serial port)\n    {\n        if (RX_MODE == 3)\n        {\n            MCU_send((uint8_t *)RX_IDLE_BUF, size);                                              //! the size here is provided by the passed parameter size\n            HAL_UARTEx_ReceiveToIdle_DMA(&amp;huart1, (uint8_t *)&amp;RX_IDLE_BUF, sizeof(RX_IDLE_BUF)); // Enable receive interrupt\n            // __HAL_DMA_DISABLE_IT(&amp;hdma_usart1_rx, DMA_IT_HT);                                    // Disable the half-transfer interrupt\n            //    memset(RX_IDLE_BUF, 0, sizeof(RX_IDLE_BUF));\n        }\n    }\n}\n#endif\n</code></pre>"},{"location":"MAIN-CONTROL/USART/usart/#explanation-of-the-code","title":"EXPLANATION OF THE CODE","text":"<p>Tip</p> <p>Sometimes the 'MCU_printf' is not working well, but 'printf' works well. So, we can use 'printf' instead of 'MCU_printf'.</p>"},{"location":"PERCEPTION/perception/","title":"PERCEPTION","text":"<p>Please refer to the respective subsections for more information.</p>"},{"location":"PERCEPTION/ADXL355/adxl355/","title":"ADXL355 Accelerometer","text":""},{"location":"PERCEPTION/ADXL355/adxl355/#introduction-to-adxl355","title":"INTRODUCTION TO ADXL355","text":"<p>The ADXL355 is a high-precision, low-noise, three-axis MEMS accelerometer from Analog Devices. It is designed for applications requiring high accuracy and low noise, such as seismic monitoring, tilt sensing, and vibration analysis. The ADXL355 offers excellent stability with low drift over time and temperature, making it suitable for long-term monitoring applications.</p> <p>This accelerometer has a selectable measurement range of \u00b12g, \u00b14g, or \u00b18g and provides 20-bit output resolution. It features a low noise density of 25 \u00b5g/\u221aHz and operates with very low power consumption, typically around 200 \u00b5A in measurement mode. The ADXL355 communicates via an SPI or I\u00b2C interface and includes features like a digital temperature sensor, FIFO buffer, and configurable bandwidth. Its robust design ensures reliability in harsh environments, making it ideal for industrial and scientific applications.</p> <p> </p> <ul> <li> <p> product link on Taobao</p> <p>Product link on Taobao</p> <p>  Purchase Link </p> </li> </ul>"},{"location":"PERCEPTION/ADXL355/adxl355/#key-parameters","title":"KEY PARAMETERS","text":"Parameter Value Operating Current 200 \u00b5A (measurement mode) Measurement Range \u00b12g, \u00b14g, \u00b18g Resolution 20-bit Noise Density 25 \u00b5g/\u221aHz Communication SPI, I\u00b2C Supply Voltage 2.0V to 3.6V Built-in Features Digital Temperature Sensor, FIFO Buffer"},{"location":"PERCEPTION/ADXL355/adxl355/#dev-reference","title":"DEV REFERENCE","text":"<ul> <li> <p> SPI</p> <p>  Portal </p> </li> </ul>"},{"location":"PERCEPTION/ADXL362/adxl362/","title":"ADXL362 Accelerometer","text":""},{"location":"PERCEPTION/ADXL362/adxl362/#introduction-to-adxl362","title":"INTRODUCTION TO ADXL362","text":"<p>The ADXL362 is an ultra-low-power, three-axis digital accelerometer from Analog Devices. It is designed for applications requiring minimal power consumption, such as wearable devices, portable electronics, and wireless sensor networks. The ADXL362 operates on as little as 1.8 \u00b5A in measurement mode and 270 nA in standby mode, making it highly energy-efficient.</p> <p>The sensor offers a wide measurement range from \u00b12g to \u00b18g and provides high-resolution output with a 12-bit digital resolution. It communicates via a SPI interface, and includes features like a programmable activity/inactivity sensing, wake-up, and a built-in temperature sensor. The ADXL362 is also known for its noise performance, ensuring accurate and reliable motion detection in low-power applications.</p> <p> </p> <ul> <li> <p> product link on Taobao</p> <p>Product link on Taobao</p> <p>  Purchase Link </p> </li> </ul>"},{"location":"PERCEPTION/ADXL362/adxl362/#key-parameters","title":"KEY PARAMETERS","text":"Parameter Value Operating Current 1.8 \u00b5A (measurement mode) Standby Current 270 nA Measurement Range \u00b12g, \u00b14g, \u00b18g Resolution 12-bit Communication SPI Supply Voltage 1.6V to 3.5V Noise Performance 550 \u00b5g/\u221aHz (typical) Built-in Features Activity/Inactivity Detection, Temperature Sensor"},{"location":"PERCEPTION/ADXL362/adxl362/#dev-reference","title":"DEV REFERENCE","text":"<ul> <li> <p> STM32 ADXL362</p> <p>  Portal </p> </li> </ul>"},{"location":"PERCEPTION/ADXL362/adxl362/#dev-procedures","title":"DEV PROCEDURES","text":""},{"location":"PERCEPTION/MPU6050/mpu6050/","title":"MPU6050 Inertial Measurement Unit","text":""},{"location":"PERCEPTION/MPU6050/mpu6050/#introduction-to-imu","title":"Introduction to IMU","text":"<p>An IMU (Inertial Measurement Unit) is a sensor device primarily used for detecting and measuring the acceleration and rotational movement of an object. The core components of an IMU typically include a three-axis accelerometer and a three-axis gyroscope, and sometimes a magnetometer is also integrated to enhance its functionality.</p> <p>Accelerometer: This measures linear acceleration along three orthogonal axes (X, Y, Z), including accelerations due to gravity. It helps determine whether the device is stationary and the direction and speed of its motion.</p> <p>Gyroscope: This measures angular velocity or the rate of rotation around the three axes. It is crucial for understanding changes in the orientation of the device.</p> <p>Magnetometer: While not all IMUs contain a magnetometer, it can measure magnetic field strength, which helps determine the direction of the device relative to the Earth's magnetic field, thus improving the accuracy of dead reckoning.</p> <p>IMUs are widely applied in various fields such as automotive, aviation, maritime, consumer electronics (like smartphones and tablets), robotics, and motion capture systems. They provide information about the dynamic state of a device and are particularly useful in environments where GPS signals are unavailable or limited, such as indoor navigation or during short periods of signal loss, where IMUs can continue to offer relatively accurate position and orientation data.</p>"},{"location":"PERCEPTION/MPU6050/mpu6050/#introduction-to-mpu6050","title":"Introduction to MPU6050","text":"<p>MPU6050 is a 6-axis motion tracking device that combines a 3-axis gyroscope, 3-axis accelerometer, and a Digital Motion Processor (DMP) all in a small package. The MPU6050 is a commonly used sensor in many projects and applications. It is widely used in drones, robotics, and other motion sensing applications.</p> <p></p> <p></p>"},{"location":"PERCEPTION/MPU6050/mpu6050/#dev-prcedures","title":"DEV PRCEDURES","text":"<ul> <li> <p> MPU6050 DEV</p> <p>MPU6050 DEV PROCEDURES</p> <p>  Portal </p> </li> <li> <p> MPU6050 DRIVER</p> <p>MPU6050 DRIVER</p> <p>  Portal </p> </li> </ul>"},{"location":"PERCEPTION/MPU6050/mpu6050/#source-code","title":"Source Code","text":""},{"location":"PERCEPTION/MPU6050/mpu6050/#mpu6050h","title":"mpu6050.h","text":"<pre><code>/*\n * mpu6050.h\n *\n *  Created on: Nov 13, 2019\n *  Author: Bulanov Konstantin\n */\n\n#ifndef _INC_GY521_H_\n#define _INC_GY521_H_\n\n#include &lt;stdint.h&gt;\n#include \"i2c.h\"\n\n// MPU6050 structure\ntypedef struct\n{\n\n    int16_t Accel_X_RAW;\n    int16_t Accel_Y_RAW;\n    int16_t Accel_Z_RAW;\n    double Ax;\n    double Ay;\n    double Az;\n\n    int16_t Gyro_X_RAW;\n    int16_t Gyro_Y_RAW;\n    int16_t Gyro_Z_RAW;\n    double Gx;\n    double Gy;\n    double Gz;\n\n    float Temperature;\n\n    double KalmanAngleX;\n    double KalmanAngleY;\n} MPU6050_t;\n\n// Kalman structure\ntypedef struct\n{\n    double Q_angle;\n    double Q_bias;\n    double R_measure;\n    double angle;\n    double bias;\n    double P[2][2];\n} Kalman_t;\n\n// char array for acc_x, acc_y, acc_z\nextern char acc_x_str[13];\nextern char acc_y_str[13];\nextern char acc_z_str[13];\nextern char IMU_Temp[13];\n\n// MPU6050\nextern MPU6050_t MPU6050;\n\nuint8_t MPU6050_Init(I2C_HandleTypeDef *I2Cx);\n\nvoid MPU6050_Read_Accel(I2C_HandleTypeDef *I2Cx, MPU6050_t *DataStruct);\n\nvoid MPU6050_Read_Gyro(I2C_HandleTypeDef *I2Cx, MPU6050_t *DataStruct);\n\nvoid MPU6050_Read_Temp(I2C_HandleTypeDef *I2Cx, MPU6050_t *DataStruct);\n\nvoid MPU6050_Read_All(I2C_HandleTypeDef *I2Cx, MPU6050_t *DataStruct);\n\ndouble Kalman_getAngle(Kalman_t *Kalman, double newAngle, double newRate, double dt);\n\n#endif /* _INC_GY521_H_ */\n</code></pre>"},{"location":"PERCEPTION/MPU6050/mpu6050/#mpu6050c","title":"mpu6050.c","text":"<pre><code>/*\n * mpu6050.c\n *\n *  Created on: Nov 13, 2019\n *  Author: Bulanov Konstantin\n *\n *  Contact information\n *  -------------------\n *\n * e-mail   :  leech001@gmail.com\n */\n\n/*\n * |---------------------------------------------------------------------------------\n * | Copyright (C) Bulanov Konstantin,2021\n * |\n * | This program is free software: you can redistribute it and/or modify\n * | it under the terms of the GNU General Public License as published by\n * | the Free Software Foundation, either version 3 of the License, or\n * | any later version.\n * |\n * | This program is distributed in the hope that it will be useful,\n * | but WITHOUT ANY WARRANTY; without even the implied warranty of\n * | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * | GNU General Public License for more details.\n * |\n * | You should have received a copy of the GNU General Public License\n * | along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.\n * |\n * | Kalman filter algorithm used from https://github.com/TKJElectronics/KalmanFilter\n * |---------------------------------------------------------------------------------\n */\n\n#include &lt;math.h&gt;\n#include \"mpu6050.h\"\n\n#define RAD_TO_DEG 57.295779513082320876798154814105\n\n#define WHO_AM_I_REG 0x75\n#define PWR_MGMT_1_REG 0x6B\n#define SMPLRT_DIV_REG 0x19\n#define ACCEL_CONFIG_REG 0x1C\n#define ACCEL_XOUT_H_REG 0x3B\n#define TEMP_OUT_H_REG 0x41\n#define GYRO_CONFIG_REG 0x1B\n#define GYRO_XOUT_H_REG 0x43\n\n// char array for acc_x, acc_y, acc_z\nchar acc_x_str[13];\nchar acc_y_str[13];\nchar acc_z_str[13];\nchar IMU_Temp[13];\n\n// MPU6050\nMPU6050_t MPU6050;\n\n// Setup MPU6050\n#define MPU6050_ADDR 0xD0\nconst uint16_t i2c_timeout = 100;\nconst double Accel_Z_corrector = 14418.0;\n\nuint32_t timer;\n\nKalman_t KalmanX = {\n    .Q_angle = 0.001f,\n    .Q_bias = 0.003f,\n    .R_measure = 0.03f};\n\nKalman_t KalmanY = {\n    .Q_angle = 0.001f,\n    .Q_bias = 0.003f,\n    .R_measure = 0.03f,\n};\n\nuint8_t MPU6050_Init(I2C_HandleTypeDef *I2Cx)\n{\n    uint8_t check;\n    uint8_t Data;\n\n    // check device ID WHO_AM_I\n\n    HAL_I2C_Mem_Read(I2Cx, MPU6050_ADDR, WHO_AM_I_REG, 1, &amp;check, 1, i2c_timeout);\n\n    if (check == 104) // 0x68 will be returned by the sensor if everything goes well\n    {\n        // power management register 0X6B we should write all 0's to wake the sensor up\n        Data = 0;\n        HAL_I2C_Mem_Write(I2Cx, MPU6050_ADDR, PWR_MGMT_1_REG, 1, &amp;Data, 1, i2c_timeout);\n\n        // Set DATA RATE of 1KHz by writing SMPLRT_DIV register\n        Data = 0x07;\n        HAL_I2C_Mem_Write(I2Cx, MPU6050_ADDR, SMPLRT_DIV_REG, 1, &amp;Data, 1, i2c_timeout);\n\n        // Set accelerometer configuration in ACCEL_CONFIG Register\n        // XA_ST=0,YA_ST=0,ZA_ST=0, FS_SEL=0 -&gt; \ufffd 2g\n        Data = 0x00;\n        HAL_I2C_Mem_Write(I2Cx, MPU6050_ADDR, ACCEL_CONFIG_REG, 1, &amp;Data, 1, i2c_timeout);\n\n        // Set Gyroscopic configuration in GYRO_CONFIG Register\n        // XG_ST=0,YG_ST=0,ZG_ST=0, FS_SEL=0 -&gt; \ufffd 250 \ufffd/s\n        Data = 0x00;\n        HAL_I2C_Mem_Write(I2Cx, MPU6050_ADDR, GYRO_CONFIG_REG, 1, &amp;Data, 1, i2c_timeout);\n        return 0;\n    }\n    return 1;\n}\n\nvoid MPU6050_Read_Accel(I2C_HandleTypeDef *I2Cx, MPU6050_t *DataStruct)\n{\n    uint8_t Rec_Data[6];\n\n    // Read 6 BYTES of data starting from ACCEL_XOUT_H register\n\n    HAL_I2C_Mem_Read(I2Cx, MPU6050_ADDR, ACCEL_XOUT_H_REG, 1, Rec_Data, 6, i2c_timeout);\n\n    DataStruct-&gt;Accel_X_RAW = (int16_t)(Rec_Data[0] &lt;&lt; 8 | Rec_Data[1]);\n    DataStruct-&gt;Accel_Y_RAW = (int16_t)(Rec_Data[2] &lt;&lt; 8 | Rec_Data[3]);\n    DataStruct-&gt;Accel_Z_RAW = (int16_t)(Rec_Data[4] &lt;&lt; 8 | Rec_Data[5]);\n\n    /*** convert the RAW values into acceleration in 'g'\n         we have to divide according to the Full scale value set in FS_SEL\n         I have configured FS_SEL = 0. So I am dividing by 16384.0\n         for more details check ACCEL_CONFIG Register              ****/\n\n    DataStruct-&gt;Ax = DataStruct-&gt;Accel_X_RAW / 16384.0;\n    DataStruct-&gt;Ay = DataStruct-&gt;Accel_Y_RAW / 16384.0;\n    DataStruct-&gt;Az = DataStruct-&gt;Accel_Z_RAW / Accel_Z_corrector;\n}\n\nvoid MPU6050_Read_Gyro(I2C_HandleTypeDef *I2Cx, MPU6050_t *DataStruct)\n{\n    uint8_t Rec_Data[6];\n\n    // Read 6 BYTES of data starting from GYRO_XOUT_H register\n\n    HAL_I2C_Mem_Read(I2Cx, MPU6050_ADDR, GYRO_XOUT_H_REG, 1, Rec_Data, 6, i2c_timeout);\n\n    DataStruct-&gt;Gyro_X_RAW = (int16_t)(Rec_Data[0] &lt;&lt; 8 | Rec_Data[1]);\n    DataStruct-&gt;Gyro_Y_RAW = (int16_t)(Rec_Data[2] &lt;&lt; 8 | Rec_Data[3]);\n    DataStruct-&gt;Gyro_Z_RAW = (int16_t)(Rec_Data[4] &lt;&lt; 8 | Rec_Data[5]);\n\n    /*** convert the RAW values into dps (\ufffd/s)\n         we have to divide according to the Full scale value set in FS_SEL\n         I have configured FS_SEL = 0. So I am dividing by 131.0\n         for more details check GYRO_CONFIG Register              ****/\n\n    DataStruct-&gt;Gx = DataStruct-&gt;Gyro_X_RAW / 131.0;\n    DataStruct-&gt;Gy = DataStruct-&gt;Gyro_Y_RAW / 131.0;\n    DataStruct-&gt;Gz = DataStruct-&gt;Gyro_Z_RAW / 131.0;\n}\n\nvoid MPU6050_Read_Temp(I2C_HandleTypeDef *I2Cx, MPU6050_t *DataStruct)\n{\n    uint8_t Rec_Data[2];\n    int16_t temp;\n\n    // Read 2 BYTES of data starting from TEMP_OUT_H_REG register\n\n    HAL_I2C_Mem_Read(I2Cx, MPU6050_ADDR, TEMP_OUT_H_REG, 1, Rec_Data, 2, i2c_timeout);\n\n    temp = (int16_t)(Rec_Data[0] &lt;&lt; 8 | Rec_Data[1]);\n    DataStruct-&gt;Temperature = (float)((int16_t)temp / (float)340.0 + (float)36.53);\n}\n\nvoid MPU6050_Read_All(I2C_HandleTypeDef *I2Cx, MPU6050_t *DataStruct)\n{\n    uint8_t Rec_Data[14];\n    int16_t temp;\n\n    // Read 14 BYTES of data starting from ACCEL_XOUT_H register\n\n    HAL_I2C_Mem_Read(I2Cx, MPU6050_ADDR, ACCEL_XOUT_H_REG, 1, Rec_Data, 14, i2c_timeout);\n\n    DataStruct-&gt;Accel_X_RAW = (int16_t)(Rec_Data[0] &lt;&lt; 8 | Rec_Data[1]);\n    DataStruct-&gt;Accel_Y_RAW = (int16_t)(Rec_Data[2] &lt;&lt; 8 | Rec_Data[3]);\n    DataStruct-&gt;Accel_Z_RAW = (int16_t)(Rec_Data[4] &lt;&lt; 8 | Rec_Data[5]);\n    temp = (int16_t)(Rec_Data[6] &lt;&lt; 8 | Rec_Data[7]);\n    DataStruct-&gt;Gyro_X_RAW = (int16_t)(Rec_Data[8] &lt;&lt; 8 | Rec_Data[9]);\n    DataStruct-&gt;Gyro_Y_RAW = (int16_t)(Rec_Data[10] &lt;&lt; 8 | Rec_Data[11]);\n    DataStruct-&gt;Gyro_Z_RAW = (int16_t)(Rec_Data[12] &lt;&lt; 8 | Rec_Data[13]);\n\n    DataStruct-&gt;Ax = DataStruct-&gt;Accel_X_RAW / 16384.0;\n    DataStruct-&gt;Ay = DataStruct-&gt;Accel_Y_RAW / 16384.0;\n    DataStruct-&gt;Az = DataStruct-&gt;Accel_Z_RAW / Accel_Z_corrector;\n    DataStruct-&gt;Temperature = (float)((int16_t)temp / (float)340.0 + (float)36.53);\n    DataStruct-&gt;Gx = DataStruct-&gt;Gyro_X_RAW / 131.0;\n    DataStruct-&gt;Gy = DataStruct-&gt;Gyro_Y_RAW / 131.0;\n    DataStruct-&gt;Gz = DataStruct-&gt;Gyro_Z_RAW / 131.0;\n\n    // Kalman angle solve\n    double dt = (double)(HAL_GetTick() - timer) / 1000;\n    timer = HAL_GetTick();\n    double roll;\n    double roll_sqrt = sqrt(\n        DataStruct-&gt;Accel_X_RAW * DataStruct-&gt;Accel_X_RAW + DataStruct-&gt;Accel_Z_RAW * DataStruct-&gt;Accel_Z_RAW);\n    if (roll_sqrt != 0.0)\n    {\n        roll = atan(DataStruct-&gt;Accel_Y_RAW / roll_sqrt) * RAD_TO_DEG;\n    }\n    else\n    {\n        roll = 0.0;\n    }\n    double pitch = atan2(-DataStruct-&gt;Accel_X_RAW, DataStruct-&gt;Accel_Z_RAW) * RAD_TO_DEG;\n    if ((pitch &lt; -90 &amp;&amp; DataStruct-&gt;KalmanAngleY &gt; 90) || (pitch &gt; 90 &amp;&amp; DataStruct-&gt;KalmanAngleY &lt; -90))\n    {\n        KalmanY.angle = pitch;\n        DataStruct-&gt;KalmanAngleY = pitch;\n    }\n    else\n    {\n        DataStruct-&gt;KalmanAngleY = Kalman_getAngle(&amp;KalmanY, pitch, DataStruct-&gt;Gy, dt);\n    }\n    if (fabs(DataStruct-&gt;KalmanAngleY) &gt; 90)\n        DataStruct-&gt;Gx = -DataStruct-&gt;Gx;\n    DataStruct-&gt;KalmanAngleX = Kalman_getAngle(&amp;KalmanX, roll, DataStruct-&gt;Gx, dt);\n}\n\ndouble Kalman_getAngle(Kalman_t *Kalman, double newAngle, double newRate, double dt)\n{\n    double rate = newRate - Kalman-&gt;bias;\n    Kalman-&gt;angle += dt * rate;\n\n    Kalman-&gt;P[0][0] += dt * (dt * Kalman-&gt;P[1][1] - Kalman-&gt;P[0][1] - Kalman-&gt;P[1][0] + Kalman-&gt;Q_angle);\n    Kalman-&gt;P[0][1] -= dt * Kalman-&gt;P[1][1];\n    Kalman-&gt;P[1][0] -= dt * Kalman-&gt;P[1][1];\n    Kalman-&gt;P[1][1] += Kalman-&gt;Q_bias * dt;\n\n    double S = Kalman-&gt;P[0][0] + Kalman-&gt;R_measure;\n    double K[2];\n    K[0] = Kalman-&gt;P[0][0] / S;\n    K[1] = Kalman-&gt;P[1][0] / S;\n\n    double y = newAngle - Kalman-&gt;angle;\n    Kalman-&gt;angle += K[0] * y;\n    Kalman-&gt;bias += K[1] * y;\n\n    double P00_temp = Kalman-&gt;P[0][0];\n    double P01_temp = Kalman-&gt;P[0][1];\n\n    Kalman-&gt;P[0][0] -= K[0] * P00_temp;\n    Kalman-&gt;P[0][1] -= K[0] * P01_temp;\n    Kalman-&gt;P[1][0] -= K[1] * P00_temp;\n    Kalman-&gt;P[1][1] -= K[1] * P01_temp;\n\n    return Kalman-&gt;angle;\n};\n</code></pre>"},{"location":"POWER/power/","title":"POWER","text":"<p>Under primitive development, we use USB cable to power the MCU. In future, battery power will be used and power management will be implemented.</p>"},{"location":"RELEASES/releases/","title":"RELEASES","text":"<p>To faciliate different use cases, this project provides various releases. The following table lists the available releases and their respective features.</p> Release (Folder Name) Description Features Status Notes NODE-CORE-BUILDING This release focuses on the computational core development, showing the development progress of the core components. Computaitonal Core Development - Progress View \u2705 Ready Theoretically equivalent to NODE-CORE-BUILT, but not fully tested. NODE-CORE-BUILT This release focuses on the computational core development, showing the developed computational core. Computaitonal Core Development - Built View \u2705 Stable \ud83c\udfc6 Recommended NODE-CORE-INTERACTION-BUILT This release focuses on the computational core development, showing the developed computational core. Compared to the non-interactive version, this version removes the interrupt and DMA functions of the serial port, only retains the basic serial port input and output, and supports user input (single character) for interactive menu functions. Computaitonal Core Development - Interaction View \u2705 Stable \ud83c\udfc6 Recommended"},{"location":"blog/","title":"Blog","text":""}]}