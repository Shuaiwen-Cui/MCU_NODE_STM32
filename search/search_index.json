{"config":{"lang":["en","zh"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"STM32 MCU EDGE INTELLIGENCE NODE","text":"<p>This project dedicates to the development of a MCU edge intelligence node based on STM32. If you are interested in this project, please star it and stay tuned.</p> <p></p>"},{"location":"ABOUT/about/","title":"STM32 MCU EDGE INTELLIGENCE NODE","text":"<p>This project dedicates to the development of a MCU edge intelligence node based on STM32. If you are interested in this project, please star it and stay tuned.</p> <p></p>"},{"location":"ARCHITECTURE/architecture/","title":"ARCHITECTURE","text":""},{"location":"ARCHITECTURE/architecture/#hardware-architecture","title":"HARDWARE ARCHITECTURE","text":"<p>MAIN CONTROL + PERCEPTION + COMMUNICATION + INTERFACING</p>"},{"location":"ARCHITECTURE/architecture/#software-architecture","title":"SOFTWARE ARCHITECTURE","text":"<p>PHYSICAL LAYER -&gt; DRIVER LAYER -&gt; MIDWARE LAYER -&gt; APPLICATION LAYER</p>"},{"location":"ARCHITECTURE/architecture/#dev-toolchain","title":"DEV TOOLCHAIN","text":"<p>INITIALIZATION: STM32CUBEMX</p> <p>PROGRAMMING: KEIL5/VSCODE</p>"},{"location":"COMMUNICATION/communication/","title":"COMMUNICATION","text":""},{"location":"COMPUTATION/computation/","title":"COMPUTATION","text":"<p>This section is dedicated for onboard computation and intelligence.</p>"},{"location":"COMPUTATION/CMSIS-DSP/cmsis-dsp/","title":"CMSIS-DSP FOR DIGITAL SIGNAL PROCESSING","text":"<p>In this section, let's talk about how to incorporate the CMSIS-DSP library to facilitate onboard digital signal processing. Note that, though it is named as \"DSP\", it is not limited to digital signal processing. It also includes functions for matrix operations, statistics, and so on.</p>"},{"location":"COMPUTATION/CMSIS-DSP/cmsis-dsp/#preparation","title":"PREPARATION","text":"<p>As our project is generated by STM32CubeMX, the CMSIS-DSP library is already included in the project. If you are not using STM32CubeMX, you can download the library from the official website of ARM.</p>"},{"location":"COMPUTATION/CMSIS-DSP/cmsis-dsp/#incorporate-the-library","title":"INCORPORATE THE LIBRARY","text":"<p>There are two forms for the library, source codes and compiled libraries. You can choose either one according to your preference. Here we will use the compiled library for simplicity.</p> <p>In Keil, open 'Manage Project Items', add a branch with a customized name, and then click add file and navigate to the library folder. Select the library file and click 'Add'. (Refer to the picture below)</p> <p></p>"},{"location":"COMPUTATION/CMSIS-DSP/cmsis-dsp/#include-the-header-file","title":"INCLUDE THE HEADER FILE","text":"<p>Similar to the above procedures, the header files are located in the 'Include' folder. Add the folder to the project and include the header file in the source code.</p>"},{"location":"COMPUTATION/CMSIS-DSP/cmsis-dsp/#update-the-include-path","title":"UPDATE THE INCLUDE PATH","text":"<p>Open the 'Options for Target' and add the path of the 'Include' folder to the 'Include Paths' in 'C/C++' tab.</p>"},{"location":"COMPUTATION/CMSIS-DSP/cmsis-dsp/#end","title":"END","text":"<p>Now, the CMSIS-DSP library is successfully incorporated into the project. You can use the functions provided by the library in your project.</p>"},{"location":"COMPUTATION/CMSIS-DSP-LIB/cmsis-dsp-lib/","title":"CMSIS-DSP FOR DIGITAL SIGNAL PROCESSING","text":"<p>In this section, let's talk about how to incorporate the CMSIS-DSP library to facilitate onboard digital signal processing. Note that, though it is named as \"DSP\", it is not limited to digital signal processing. It also includes functions for matrix operations, statistics, and so on.</p>"},{"location":"COMPUTATION/CMSIS-DSP-LIB/cmsis-dsp-lib/#preparation","title":"PREPARATION","text":"<p>As our project is generated by STM32CubeMX, the CMSIS-DSP library is already included in the project. If you are not using STM32CubeMX, you can download the library from the official website of ARM.</p>"},{"location":"COMPUTATION/CMSIS-DSP-LIB/cmsis-dsp-lib/#incorporate-the-library","title":"INCORPORATE THE LIBRARY","text":"<p>There are two forms for the library, source codes and compiled libraries. You can choose either one according to your preference. Here we will use the compiled library for simplicity.</p> <p>In Keil, open 'Manage Project Items', add a branch with a customized name, and then click add file and navigate to the library folder. Select the library file and click 'Add'. (Refer to the picture below)</p> <p></p>"},{"location":"COMPUTATION/CMSIS-DSP-LIB/cmsis-dsp-lib/#include-the-header-file","title":"INCLUDE THE HEADER FILE","text":"<p>Similar to the above procedures, the header files are located in the 'Include' folder. Add the folder to the project and include the header file in the source code.</p>"},{"location":"COMPUTATION/CMSIS-DSP-LIB/cmsis-dsp-lib/#update-the-include-path","title":"UPDATE THE INCLUDE PATH","text":"<p>Open the 'Options for Target' and add the path of the 'Include' folder to the 'Include Paths' in 'C/C++' tab.</p>"},{"location":"COMPUTATION/CMSIS-DSP-LIB/cmsis-dsp-lib/#end","title":"END","text":"<p>Now, the CMSIS-DSP library is successfully incorporated into the project. You can use the functions provided by the library in your project.</p>"},{"location":"COMPUTATION/CMSIS-NN/cmsis-nn/","title":"CMSIS-NN FOR NEURAL NETWORKS","text":"<p>This section we introduce the CMSIS-NN library for onboard NN.</p> <p>Tip</p> <p>Personally, I think X-CUBE-AI is more user-friendly than CMSIS-NN. You can simply import your model and generate the code.</p>"},{"location":"COMPUTATION/CMSIS-NN/cmsis-nn/#preparation","title":"PREPARATION","text":"<p>As we are using STM32CubeMX to generate the project, the CMSIS-NN library is already included in the project. If you are not using STM32CubeMX, you can download the library from the official website of ARM. Note that the CMSIS-NN library comes along with CUBEMX is a bit behind the latest version. You can download the latest version from the official website. But there may be compatibility issues.</p>"},{"location":"COMPUTATION/CMSIS-NN/cmsis-nn/#incorporate-the-source-code","title":"INCORPORATE THE SOURCE CODE","text":"<p>There is no compiled library for CMSIS-NN. You need to incorporate the source code into your project.</p> <p>In Keil, open 'Manage Project Items', add a branch with a customized name, and then click add file and navigate to the NN source code folder. Select the source files and click 'Add'. (Refer to the picture below)</p> <p></p>"},{"location":"COMPUTATION/CMSIS-NN/cmsis-nn/#include-the-header-file","title":"INCLUDE THE HEADER FILE","text":"<p>Similar to the above procedures, the header files are located in the 'Include' folder. Add the folder to the project and include the header file in the source code.</p>"},{"location":"COMPUTATION/CMSIS-NN/cmsis-nn/#update-the-include-path","title":"UPDATE THE INCLUDE PATH","text":"<p>Open the 'Options for Target' and add the path of the 'Include' folder to the 'Include Paths' in 'C/C++' tab.</p> <p></p>"},{"location":"COMPUTATION/CMSIS-NN/cmsis-nn/#end","title":"END","text":"<p>Now, the CMSIS-NN library is successfully incorporated into the project. You can use the functions provided by the library in your project.</p>"},{"location":"COMPUTATION/CMSIS-NN-LIB/cmsis-nn-lib/","title":"CMSIS-NN FOR NEURAL NETWORKS","text":"<p>This section we introduce the CMSIS-NN library for onboard NN.</p> <p>Tip</p> <p>Personally, I think X-CUBE-AI is more user-friendly than CMSIS-NN. You can simply import your model and generate the code.</p>"},{"location":"COMPUTATION/CMSIS-NN-LIB/cmsis-nn-lib/#preparation","title":"PREPARATION","text":"<p>As we are using STM32CubeMX to generate the project, the CMSIS-NN library is already included in the project. If you are not using STM32CubeMX, you can download the library from the official website of ARM. Note that the CMSIS-NN library comes along with CUBEMX is a bit behind the latest version. You can download the latest version from the official website. But there may be compatibility issues.</p>"},{"location":"COMPUTATION/CMSIS-NN-LIB/cmsis-nn-lib/#incorporate-the-source-code","title":"INCORPORATE THE SOURCE CODE","text":"<p>There is no compiled library for CMSIS-NN. You need to incorporate the source code into your project.</p> <p>In Keil, open 'Manage Project Items', add a branch with a customized name, and then click add file and navigate to the NN source code folder. Select the source files and click 'Add'. (Refer to the picture below)</p> <p></p>"},{"location":"COMPUTATION/CMSIS-NN-LIB/cmsis-nn-lib/#include-the-header-file","title":"INCLUDE THE HEADER FILE","text":"<p>Similar to the above procedures, the header files are located in the 'Include' folder. Add the folder to the project and include the header file in the source code.</p>"},{"location":"COMPUTATION/CMSIS-NN-LIB/cmsis-nn-lib/#update-the-include-path","title":"UPDATE THE INCLUDE PATH","text":"<p>Open the 'Options for Target' and add the path of the 'Include' folder to the 'Include Paths' in 'C/C++' tab.</p> <p></p>"},{"location":"COMPUTATION/CMSIS-NN-LIB/cmsis-nn-lib/#end","title":"END","text":"<p>Now, the CMSIS-NN library is successfully incorporated into the project. You can use the functions provided by the library in your project.</p>"},{"location":"INTERFACING/interfacing/","title":"INTERFACING","text":"<p>This section is dedicated to interfacing with the MCU. Currently, it covers the following topic(s):</p> <ul> <li>OLED Display</li> </ul> <p>Please refer to the respective sub-sections for more information.</p>"},{"location":"INTERFACING/OLED/oled/","title":"OLED","text":""},{"location":"INTERFACING/OLED/oled/#oled-introduction","title":"OLED INTRODUCTION","text":"<p>OLED (Organic Light Emitting Diode) is a type of display technology that uses organic compounds to produce light. It is a self-emissive display, which means that it does not require a backlight to function. OLED displays are known for their high contrast ratio, wide viewing angles, and fast response times. They are commonly used in smartphones, tablets, and other portable devices.</p>"},{"location":"INTERFACING/OLED/oled/#oled-module","title":"OLED MODULE","text":"<ul> <li>OLED CONTROL - CH1116</li> <li>OLED SIZE - 1.3 INCH</li> <li>OLED RESOLUTION - 128x64</li> </ul> <ul> <li> <p> product link on Taobao</p> <p>Product link on Taobao</p> <p>  Purchase Link </p> </li> </ul>"},{"location":"INTERFACING/OLED/oled/#driver-reference","title":"DRIVER REFERENCE","text":"<ul> <li>KEYSKING DRIVER</li> </ul> <ul> <li> <p> BAUD DANCE</p> <p>BAUD DANCE</p> <p>  Portal </p> </li> </ul>"},{"location":"MAIN-CONTROL/main-control/","title":"MAIN CONTROL","text":""},{"location":"MAIN-CONTROL/main-control/#main-control-overview","title":"MAIN CONTROL OVERVIEW","text":"<ul> <li> <p> product link on Taobao</p> <p>Product link on Taobao</p> <p>  Purchase Link </p> </li> </ul>"},{"location":"MAIN-CONTROL/main-control/#onboard-resources","title":"ONBOARD RESOURCES","text":"<ul> <li>MAIN FREQUENCY: 480MHz</li> <li>RAM: 1MB (BUILT-IN)</li> <li>ROM: 2MB (BUILT-IN)</li> <li>SDRAM: 32MB (16BIT) WINBOND W9825G6KH-6I</li> <li>FLASH: 8MB (QSPI) WINBOND W25Q64</li> <li>TF CARD: 32GB (MAXIMUM) (BY TEST, LARGER CAPACITY IS SUPPORTED)</li> <li>LED: 1 PWR; 1 PROGRAMMABLE</li> <li>BUTTON: 1 RESET; 1 BOOT</li> <li>USB: TYPE-C</li> <li>PINS: 2.54MM PITCH, 2x2x28PINS</li> </ul>"},{"location":"MAIN-CONTROL/main-control/#mechanical-dimensions","title":"MECHANICAL DIMENSIONS","text":""},{"location":"MAIN-CONTROL/main-control/#circuit-diagram","title":"CIRCUIT DIAGRAM","text":""},{"location":"MAIN-CONTROL/BSP/bsp/","title":"BOARD SUPPORT PACKAGE (BSP)","text":""},{"location":"MAIN-CONTROL/BSP/bsp/#introduction-of-the-bsp","title":"INTRODUCTION OF THE BSP","text":"<p>To facilitate the development and transplantation of the main control board, I have prepared a BSP consisting a series of useful drivers and libraries. The BSP is based on the STM32Cube HAL library and is compatible with STM32H7 series microcontrollers, if you want you can modify it to fit other series. The BSP includes the following modules:</p> <ul> <li>bsp_init: The controlling module for all BSP modules.</li> <li>iled: The driver for the LED.</li> <li>iusart: The driver for the USART, mainly for serial communication.</li> <li>isdram: The low-level driver for the SDRAM.</li> <li>imemory: The memory management module.</li> <li>isdcard: The driver for the SD card.</li> <li>ifile: The file system module.</li> <li>...</li> </ul> <p>Tip</p> <p>The tutorial is written in a section-by-section manner, but in practice, the users can set up all required configuration in STM32CUBEMX in one go and then move forward to Keil or VSCode programming. Users can transplant the BSP from the library (link attached below) and incorporate it into their projects accordingly.</p> <ul> <li> <p> MCU_BSP</p> <p>MCU BSP BASED ON STM32</p> <p>  Github Repo </p> </li> </ul>"},{"location":"MAIN-CONTROL/BSP/bsp/#setup-your-keil-for-better-experience","title":"SETUP YOUR KEIL FOR BETTER EXPERIENCE","text":"<p>Open 'Options for Target' and conduct the following settings:</p>"},{"location":"MAIN-CONTROL/BSP/bsp/#use-ac6-compiler","title":"USE AC6 COMPILER","text":"<p>Since this is a new project, every thing is started with the AC6 compiler. We can use AC6 for compiling and debugging, which is much faster than the AC5 compiler.</p>"},{"location":"MAIN-CONTROL/BSP/bsp/#reset-and-run","title":"RESET AND RUN","text":"<p>Select the 'Debug' tab, and at the right upper corner, select 'Settings'. In the 'Flash and Download' tab, select 'Reset and Run' to automatically reset and run the program after downloading the program to the board. This is very handy for programming and debugging.</p>"},{"location":"MAIN-CONTROL/BSP/bsp/#how-to-integrate-the-bsp-into-your-project","title":"HOW TO INTEGRATE THE BSP INTO YOUR PROJECT","text":""},{"location":"MAIN-CONTROL/BSP/bsp/#setp1-download-the-bsp","title":"SETP1: DOWNLOAD THE BSP","text":"<p>Clone the BSP git repository to your local workspace.</p> <pre><code>git clone https://github.com/Shuaiwen-Cui/MCU_BSP.git\n</code></pre>"},{"location":"MAIN-CONTROL/BSP/bsp/#step2-move-the-bsp-to-your-project","title":"STEP2: MOVE THE BSP TO YOUR PROJECT","text":"<p>Only pick the ''STM32-HAL-CUBEMX' folder and move it to your project directory.</p>"},{"location":"MAIN-CONTROL/BSP/bsp/#step3-include-the-bsp-in-your-project","title":"STEP3: INCLUDE THE BSP IN YOUR PROJECT","text":"<p>Open Keil, select 'Options for Target' -&gt; 'C/C++' -&gt; 'Include Paths', add each respective path of the BSP modules into your project include paths.</p>"},{"location":"MAIN-CONTROL/BSP/bsp/#step4-add-the-bsp-modules-to-your-project","title":"STEP4: ADD THE BSP MODULES TO YOUR PROJECT","text":"<p>Open 'Manage Project Items', add respective modules into your project. </p> <p>Tip</p> <p>When you add them files, change the file type to 'All Types' to incorporate both the '.h' and '.c' files into the project for convenience.</p>"},{"location":"MAIN-CONTROL/BSP/bsp/#setp5-include-the-header-files-and-call-the-bsp_init-function","title":"SETP5: INCLUDE THE HEADER FILES AND CALL THE BSP_INIT FUNCTION","text":"<p>In the main function, include the 'bsp_init.h' file and call the 'BSP_Init()' function in the main function to initialize all the BSP modules. </p> <p>Tip</p> <p>When modifying the code, do remember to place your codes between the 'USER CODE BEGIN' and 'USER CODE END' tags to avoid being overwritten by the STM32CubeMX.</p>"},{"location":"MAIN-CONTROL/BSP/bsp/#introduction-for-bsp_init","title":"INTRODUCTION FOR BSP_INIT","text":"<p>Note</p> <p>To efficiently manage the BSP modules, I have created a controlling module called 'bsp_init'. The 'bsp_init' module is responsible for initializing all the BSP modules and setting up the necessary configurations. The 'bsp_init' module is the first user module to be called in the main function. </p> <p>Let's take a look at the 'bsp_init' module:</p>"},{"location":"MAIN-CONTROL/BSP/bsp/#bsp_inith","title":"bsp_init.h","text":"<pre><code>/**\n * @file bsp_init.h\n * @author SHUAIWEN CUI (SHUAIWEN001 AT e DOT ntu DOT edu DOT sg)\n * @brief This file contains the headers of the BSP initialization functions.\n * @version 1.0\n * @date 2024-07-12\n *\n * @copyright Copyright (c) 2024\n *\n */\n#ifndef BSP_INIT_H\n#define BSP_INIT_H\n\n#define BSP_INIT_SUCCESS 0\n#define BSP_INIT_FAIL 1\n\n#define BSP_INIT_TEST // test required for the BSP initialization, comment this out to disable the test\n\n/**\n * @name Modules To Be Enabled\n * @brief This section is to determine the modules to be included in the project\n * ! This is where you configure the modules to be included in the project\n * @param MODULE_ENABLE_LED //! Enable LED module\n * @param MODULE_ENABLE_KEY //! Enable Key module (No use in this project, do not enable it)\n * @param MODULE_ENABLE_USART1 //! Enable USART1 module for serial communication\n * @param MODULE_ENABLE_SDRAM //! Enable SDRAM module to use external RAM for computation\n * @param MODULE_ENABLE_MEMORY //! Enable Memory module - for memory management on SDRAM\n * @param MODULE_ENABLE_SDCARD //! Enable SD Card module test - for SD Card basic io. !!! This module can not be used together with MODULE_ENABLE_FILE\n * @param MODULE_ENABLE_FILE //! Enable File module test - for file operations on SD Card !!! This module can not be used together with MODULE_ENABLE_SDCARD\n */\n\n#define MODULE_ENABLE_LED // Enable LED module\n// #define MODULE_ENABLE_KEY  // Enable Key module\n#define MODULE_ENABLE_USART1 // Enable USART1 module\n#define MODULE_ENABLE_SDRAM  // Enable SDRAM module\n#define MODULE_ENABLE_MEMORY // Enable Memory module - for memory management on SDRAM\n// #define MODULE_ENABLE_SDCARD // Enable SD Card module\n#define MODULE_ENABLE_FILE   // Enable File module - for file operations on SD Card\n\n/**\n * @name Include Files\n *\n */\n#include &lt;stdio.h&gt;\n#ifdef MODULE_ENABLE_LED\n\n#include \"iled.h\"\n\n#endif\n\n#ifdef MODULE_ENABLE_KEY\n\n#include \"ikey.h\"\n\n#endif\n\n#ifdef MODULE_ENABLE_USART1 //! Note - Do rember to check the MicroLib option in the project settings\n\n#include &lt;stdio.h&gt;\n#include \"iusart.h\"\n\n#endif\n\n#ifdef MODULE_ENABLE_SDRAM\n\n#include \"isdram.h\"\n\n#endif\n\n#ifdef MODULE_ENABLE_MEMORY\n\n#include \"imemory.h\"\n\n#endif\n\n#ifdef MODULE_ENABLE_SDCARD\n\n#include \"isdcard.h\"\n\n#endif\n\n#ifdef MODULE_ENABLE_FILE\n\n#include \"ifile.h\"\n\n#endif\n\n/**\n * @name Function Prototypes\n *\n */\n\n// The BSP initialization function - including all the initialization functions\nint BSP_Init();\n\n#ifdef MODULE_ENABLE_USART1\n// IO retargetting\nint fputc(int ch, FILE *f);\nint fgetc(FILE *f);\n#endif\n\n#endif /* BSP_INIT_H */\n</code></pre>"},{"location":"MAIN-CONTROL/BSP/bsp/#bsp_initc","title":"bsp_init.c","text":"<pre><code>/**\n * @file bsp_init.c\n * @author SHUAIWEN CUI (SHUAIWEN001 AT e DOT ntu DOT edu DOT sg)\n * @brief\n * @version 1.0\n * @date 2024-07-12\n *\n * @copyright Copyright (c) 2024\n *\n */\n#include \"bsp_init.h\"\n\n/**\n * @name VARIABLES\n * \n */\n// The gap between the initialization of each module, in ms.\nint Init_Gap = 500;\n\n/**\n * @name BSP_Init\n * @brief board support package initialization\n * @param None\n * @retval 0\n *\n */\nint BSP_Init(void)\n{\n    // Variables\n    int i;\n#ifdef MODULE_ENABLE_LED\n    // BSP Initialization - LED - flash once to indicate OK\n    LED(0); // for deployment, switch off the LED to save power\n#ifdef BSP_INIT_TEST // for debugging, flash the LED to indicate status\n    LED(1);\n    HAL_Delay(200);\n    LED(0);\n    HAL_Delay(200);\n    LED(1);\n#endif\n#endif\n\n#ifdef MODULE_ENABLE_KEY\n    // BSP Initialization - Key\n    // nothing required\n#endif\n\n    HAL_Delay(2*Init_Gap); // to give the user enough time to connect to the serial terminal\n\n#ifdef MODULE_ENABLE_USART1\n#ifdef BSP_INIT_TEST\n    // Initialization - Count Down\n    for (i = 0; i &lt; 5; i++)\n    {\n        printf(\"[INITIALIZATION] Count Down for Upcoming Testing: %d \\n\\r\", 5 - i);\n        HAL_Delay(1000);\n    }\n    printf(\"\\n\\r\");\n#endif\n    // BSP Initialization - Serial Communication\n    MCU_serial_init();\n    printf(\"[INITIALIZATION] Serial Communication - SUCCESS\\n\\r\\n\\r\");\n    // MCU_printf(\"Serial Communication - SUCCESS\\n\\r\"); // not working\n#endif\n\n    HAL_Delay(Init_Gap);\n\n#ifdef MODULE_ENABLE_SDRAM\n    // BSP Initialization - SDRAM\n    printf(\"[INITIALIZATION] SDRAM Initialization - START\\n\\r\");\n    SDRAM_InitSequence();\n    printf(\"[INITIALIZATION] SDRAM Initialization - FINISHED\\r\\n\\n\\r\");\n#ifdef BSP_INIT_TEST\n    if (SDRAM_Test() == 0)\n    {\n        printf(\"[INITIALIZATION] SDRAM TEST - SUCCESS\\r\\n\\n\\r\");\n    }\n    else\n    {\n        printf(\"[INITIALIZATION] SDRAM TEST - FAIL\\r\\n\\n\\r\");\n    }\n#endif\n#endif\n\n    HAL_Delay(Init_Gap);\n\n#ifdef MODULE_ENABLE_MEMORY\n    // BSP Initialization - Memory Management\n    printf(\"[INITIALIZATION] Memory Management Initialization - START\\n\\r\");\n    memory_init();\n    printf(\"[INITIALIZATION] Memory Management Initialization - FINISHED\\n\\r\\n\\r\");\n#ifdef BSP_INIT_TEST\n    printf(\"[INITIALIZATION] Memory Management Test - START\\n\\r\");\n    if (memory_management_test() == 0)\n    {\n        printf(\"[INITIALIZATION] Memory Management Test - SUCCESS\\n\\r\\n\\r\");\n    }\n    else\n    {\n        printf(\"[INITIALIZATION] Memory Management Test - FAIL\\n\\r\\n\\r\");\n    }\n#endif\n#endif\n\n    HAL_Delay(Init_Gap);\n\n#ifdef MODULE_ENABLE_SDCARD\n\n    // BSP Initialization - SD Card\n    printf(\"[INITIALIZATION] SD Card Initialization - START.\\n\\r\");\n    SD_Init();\n#ifdef BSP_INIT_TEST\n    // SD Card Test\n    printf(\"[INITIALIZATION] SD Card Test - START.\\n\\r\");\n    SD_Test();\n    printf(\"[INITIALIZATION] SD Card Test - FINISHED.\\n\\r\");\n#endif\n    printf(\"[INITIALIZATION] SD CARD Initialization - FINISHED.\\n\\r\");\n#endif\n\n    HAL_Delay(Init_Gap);\n\n#ifdef MODULE_ENABLE_FILE // the test is kept outside the test zone, as sd card hard conenction is not quite stable, and we need the test to ensure the connection is okay\n\n    printf(\"[INITIALIZATION] SD Card File IO Initialization and Test - START.\\n\\r\");\n    printf(\"\\n\\r\");\n\n    // mount the file system\n    printf(\"[INITIALIZATION] Mounting the file system.\\n\\r\");\n    Mount_FatFs();\n    printf(\"\\n\\r\");\n\n    // get disk information\n    printf(\"[INITIALIZATION] Getting disk information.\\n\\r\");\n    FatFs_GetDiskInfo();\n    printf(\"\\n\\r\");\n\n    // scan the directory\n    printf(\"[INITIALIZATION] Scanning the directory.\\n\\r\");\n    FatFs_ScanDir(\"0:/\");\n    printf(\"\\n\\r\");\n\n    // write a text file\n    printf(\"[INITIALIZATION] Writing a text file.\\n\\r\");\n    FatFs_WriteTXTFile(\"test.txt\", 2016, 11, 15);\n    printf(\"\\n\\r\");\n\n    // read a text file\n    printf(\"[INITIALIZATION] Reading a text file.\\n\\r\");\n    FatFs_ReadTXTFile(\"test.txt\");\n    printf(\"\\n\\r\");\n\n    // get file information\n    printf(\"[INITIALIZATION] Getting file information.\\n\\r\");\n    FatFs_GetFileInfo(\"test.txt\");\n    printf(\"\\n\\r\");\n\n    // delete a file\n    printf(\"[INITIALIZATION] Deleting a file.\\n\\r\");\n    FatFs_DeleteFile(\"test.txt\");\n    printf(\"\\n\\r\");\n\n#ifdef BSP_INIT_TEST\n\n#endif\n    printf(\"[INITIALIZATION] SD Card File IO Initialization and Test - FINISHED.\\n\\r\\n\\r\");\n    HAL_Delay(Init_Gap);\n\n#endif\n\n\n#ifdef MODULE_ENABLE_USART1\n    printf(\"[INITIALIZATION] BSP Initialization - FINISHED\\n\\r\");\n    printf(\"\\n\\r\");\n#endif\n\n    return BSP_INIT_SUCCESS;\n}\n\n#ifdef MODULE_ENABLE_USART1\n\n// MicroLib needed for retargetting\n// retarget fputc for printf\nint fputc(int ch, FILE *f)\n{\n    uint8_t temp = (uint8_t)ch;\n    HAL_UART_Transmit(&amp;huart1, &amp;temp, 1, HAL_MAX_DELAY);\n    return ch;\n}\n\n// retarget fgetc for scanf\nint fgetc(FILE *f)\n{\n    while (__HAL_UART_GET_FLAG(&amp;huart1, UART_FLAG_RXNE) == RESET)\n        ;                                      // Wait until the data is received\n    return (int)(huart1.Instance-&gt;RDR &amp; 0xFF); // Read the received data\n}\n#endif\n</code></pre>"},{"location":"MAIN-CONTROL/BSP/bsp/#explanation-of-the-bsp_init-module","title":"EXPLANATION OF THE BSP_INIT MODULE","text":"<p>As can be seen, almost all bsp modules are configured in this module.  You can determine which module to activate or deactivate by commenting out the respective module:</p> <ul> <li>MODULE_ENABLE_LED: Enable the LED module.</li> <li>MODULE_ENABLE_KEY: Enable the Key module. Note that this module is not used in this project as there is no programmable key on this board. Do not enable it.</li> <li>MODULE_ENABLE_USART1: Enable the USART1 module for serial communication. If you enable this, the retargetting functions for printf and scanf will be activated automatically as defined in the module.</li> <li>MODULE_ENABLE_SDRAM: Enable the SDRAM module to use external RAM for computation.</li> <li>MODULE_ENABLE_MEMORY: Enable the Memory module for memory management on SDRAM.</li> <li>MODULE_ENABLE_SDCARD: Enable the SD Card module test for SD Card basic IO. Note that this module cannot be used together with MODULE_ENABLE_FILE. </li> <li>MODULE_ENABLE_FILE: Enable the File module test for file operations on the SD Card. Note that this module cannot be used together with MODULE_ENABLE_SDCARD.</li> </ul>"},{"location":"MAIN-CONTROL/BSP/bsp/#recommended-configuration-for-bsp_init-module","title":"RECOMMENDED CONFIGURATION FOR BSP_INIT MODULE","text":"<p>The following table is the recommended configuration for the BSP_INIT module:</p> Module Name Configuration MODULE_ENABLE_LED \u2705Enable MODULE_ENABLE_KEY \u274cDisable MODULE_ENABLE_USART1 \u2705Enable MODULE_ENABLE_SDRAM \u2705Enable MODULE_ENABLE_MEMORY \u2705Enable MODULE_ENABLE_SDCARD \u274cDisable MODULE_ENABLE_FILE \u2705Enable"},{"location":"MAIN-CONTROL/BSP/bsp/#module-test","title":"MODULE TEST","text":"<p>To facilitate the assessment of the configured modules, there is a MICRO 'BSP_INIT_TEST' defined in the .h file. This test is used to test the initialization of each module. If you want to disable the test to save time, you can comment out the 'BSP_INIT_TEST' in the .h file.</p>"},{"location":"MAIN-CONTROL/FILE-SYS/file-sys/","title":"FILE SYSTEM","text":"<p>Info</p> <p>File system is a method of storing and organizing computer files and their data. Here, we will use the FatFs library to interface with the SD card.</p>"},{"location":"MAIN-CONTROL/FILE-SYS/file-sys/#file-system-as-a-middleware","title":"FILE SYSTEM AS A MIDDLEWARE","text":"<p>In STM32CUBEMX, FATFS is already incorporated into the software as a middleware. To enable FATFS, go to the 'Middleware' tab and enable the 'FATFS' middleware.</p>"},{"location":"MAIN-CONTROL/FILE-SYS/file-sys/#file-system-configuration","title":"FILE SYSTEM CONFIGURATION","text":"<p>As shown, select FATFS for SD card, and enable the long file name support. </p> <p></p> <p>Then, under the Advanced Settings, select the DMA template for the SD card.</p>"},{"location":"MAIN-CONTROL/FILE-SYS/file-sys/#generate-and-update-code","title":"GENERATE AND UPDATE CODE","text":"<p>Finally, let's generate the code to save the current progress and to make it ready for following programming steps. Click the 'Generate Code' button at the top right corner of the screen.</p>"},{"location":"MAIN-CONTROL/FILE-SYS/file-sys/#programming-in-keil","title":"PROGRAMMING IN KEIL","text":""},{"location":"MAIN-CONTROL/FILE-SYS/file-sys/#modify-the-configuration-in-sd_diskioc","title":"MODIFY THE CONFIGURATION IN SD_DISKIO.C","text":"<p>As shown above, modify the code in the sd_diskio.c file to configure the SD card and FATFS.</p>"},{"location":"MAIN-CONTROL/FILE-SYS/file-sys/#incorporate-the-module-code-ifile","title":"INCORPORATE THE MODULE CODE - IFILE","text":"<p>We have introduced how to transplant and incorporate the BSP code into the project, and that applies to each respective module. For transplantation:</p> <ol> <li>Copy the module codes from the BSP project to the user project.</li> <li>Add the module codes to the user project include path.</li> <li>Add the module codes to the project items.</li> <li>Include the header file of the module code in the user project.</li> <li>Call the module function in the user project.</li> </ol> <p>Warning</p> <p>Since we are using FATFS here, and FATFS has a built-in SDCARD driver, it will conflict with our own isdcard driver. Therefore, in the <code>bsp_init</code>, if we want to use the FATFS file system, we should not include the isdcard driver; otherwise, it will cause a conflict.</p>"},{"location":"MAIN-CONTROL/FILE-SYS/file-sys/#code-review-file-sys","title":"CODE REVIEW - FILE-SYS","text":""},{"location":"MAIN-CONTROL/FILE-SYS/file-sys/#ifileh","title":"ifile.h","text":"<pre><code>/**\n * @file ifile.h\n * @author SHUAIWEN CUI (shuaiwencui AT gmail DOT com)\n * @brief This is the header file for the ifile.c file\n * @version 1.0\n * @date 2024-07-17\n * @ref https://blog.csdn.net/Mculover666/article/details/102688285\uff1bhttps://blog.csdn.net/qq_36561846/article/details/133808890\n * @copyright Copyright (c) 2024\n *\n */\n#ifndef __IFILE_H\n#define __IFILE_H\n\n/**\n * @name INCLUDES\n */\n\n#include \"stm32h7xx.h\"\n#include \"main.h\"\n#include \"ff.h\"         // FATFS main header file\n#include \"diskio.h\"     // Disk I/O header file\n#include \"fatfs.h\"      // FATFS configuration header file (if using STM32CubeMX)\n#include \"ff_gen_drv.h\" // Generic driver header file\n#include \"ffconf.h\"\n#include \"stdio.h\"\n\n/* Define custom storage device */\n/* Number of bytes per sector for user storage device */\n#define User_Sector 512\n/* FatFs object for user storage device */\n#define User_FatFs SDFatFS\n/* Volume path for user storage device */\n#define User_SDPath SDPath\n\n/*functions*/\nvoid Mount_FatFs(void);\nvoid FatFs_GetDiskInfo(void);\nvoid FatFs_ScanDir(const TCHAR* PathName);\nvoid FatFs_ReadTXTFile(TCHAR *filename);\nvoid FatFs_WriteTXTFile(TCHAR *filename,uint16_t year, uint8_t month, uint8_t day);\nvoid FatFs_GetFileInfo(TCHAR *filename);\nvoid FatFs_DeleteFile(TCHAR *filename);\nvoid FatFs_PrintfFileDate(WORD date, WORD time);\n\nuint8_t BSP_SD_ReadBlocks_DMA(uint32_t *pData, uint32_t ReadAddr, uint32_t NumOfBlocks);\nuint8_t BSP_SD_WriteBlocks_DMA(uint32_t *pData, uint32_t WriteAddr, uint32_t NumOfBlocks);\n#endif /* __IFILE_H */\n</code></pre>"},{"location":"MAIN-CONTROL/FILE-SYS/file-sys/#ifilec","title":"ifile.c","text":"<pre><code>/**\n * @file ifile.c\n * @author SHUAIWEN CUI (shuaiwencui AT gmail DOT com)\n * @brief This is the source file for the ifile.c file\n * @version 1.0\n * @date 2024-07-17\n * @ref https://blog.csdn.net/Mculover666/article/details/102688285\uff1bhttps://blog.csdn.net/qq_36561846/article/details/133808890\n * @copyright Copyright (c) 2024\n *\n */\n\n#include \"ifile.h\"\n#include \"iusart.h\"\n#include \"sdmmc.h\"\n\n// Define a work buffer for formatting\nBYTE workBuffer[4 * User_Sector];\n\n/**\n * @name Mount_FatFs\n * @brief Mount FatFs file system\n * @param None\n * @retval None\n * @note Working\n */\n/* Mount FatFs file system */\nvoid Mount_FatFs(void)\n{\n    // Mount file system\n    FRESULT retUSER = f_mount(&amp;User_FatFs, User_SDPath, 1);\n    // Error occurred\n    if (retUSER != FR_OK)\n    {\n        // No file system, need to format\n        if (retUSER == FR_NO_FILESYSTEM)\n        {\n            printf(\"\\r\\nNo file system, start formatting\\r\\n\");\n            // Create file system\n            retUSER = f_mkfs(User_SDPath, FM_FAT32, 0, workBuffer, 4 * User_Sector);\n            // Formatting failed\n            if (retUSER != FR_OK)\n            {\n                printf(\"Formatting failed, error code = %d\\r\\n\", retUSER);\n            }\n            // Formatting succeeded\n            else\n            {\n                printf(\"Formatting succeeded, remounting\\r\\n\");\n                // Remount after creating file system\n                retUSER = f_mount(&amp;User_FatFs, User_SDPath, 1);\n                // Mounting failed\n                if (retUSER != FR_OK)\n                {\n                    printf(\"Error occurred, error code = %d\\r\\n\", retUSER);\n                }\n                // Mounting succeeded\n                else\n                {\n                    printf(\"*** File system mounted successfully ***\\r\\n\");\n                }\n            }\n        }\n        // Other error occurred\n        else\n        {\n            printf(\"Other error occurred, error code = %d\\r\\n\", retUSER);\n        }\n    }\n    // File system already exists, mounted successfully\n    else\n    {\n        printf(\"File system mounted successfully\\r\\n\");\n    }\n}\n\n/**\n * @name FatFs_GetDiskInfo\n * @brief Get disk information and display on LCD\n * @param None\n * @retval None\n * @note Working\n */\n/* Get disk information and display on LCD */\nvoid FatFs_GetDiskInfo(void)\n{\n    FATFS *fs;\n\n    // Define variable for remaining clusters\n    DWORD fre_clust;\n\n    // Get remaining clusters\n    FRESULT res = f_getfree(\"0:\", &amp;fre_clust, &amp;fs);\n\n    // Getting failed\n    if (res != FR_OK)\n    {\n        printf(\"f_getfree() error\\r\\n\");\n        return;\n    }\n    printf(\"\\r\\n*** FAT disk info ***\\r\\n\");\n\n    // Total number of sectors\n    DWORD tot_sect = (fs-&gt;n_fatent - 2) * fs-&gt;csize;\n\n    // Remaining number of sectors = remaining clusters * sectors per cluster\n    DWORD fre_sect = fre_clust * fs-&gt;csize;\n\n    // For SD card and USB flash drive, _MIN_SS=512 bytes\n#if _MAX_SS == _MIN_SS\n    // SD card's _MIN_SS is fixed at 512, right shift 11 bits equals dividing by 2048\n    // Remaining space size, unit: MB, for SD card and USB flash drive\n    DWORD freespace = (fre_sect &gt;&gt; 11);\n    // Total space size, unit: MB, for SD card and USB flash drive\n    DWORD totalSpace = (tot_sect &gt;&gt; 11);\n#else\n    // Flash storage, small capacity\n    // Remaining space size, unit: KB\n    DWORD freespace = (fre_sect * fs-&gt;ssize) &gt;&gt; 10;\n    // Total space size, unit: KB\n    DWORD totalSpace = (tot_sect * fs-&gt;ssize) &gt;&gt; 10;\n#endif\n\n    // FAT type\n    printf(\"FAT type = %d \", fs-&gt;fs_type);\n    printf(\"[1=FAT12, 2=FAT16, 3=FAT32, 4=exFAT]\\r\\n\");\n\n    // Sector size in bytes\n    printf(\"Sector size(bytes) = \");\n    // SD card fixed 512 bytes\n#if _MAX_SS == _MIN_SS\n    printf(\"%d\\r\\n\", _MIN_SS);\n#else\n    // Flash storage\n    printf(\"%d\\r\\n\", fs-&gt;ssize);\n#endif\n\n    printf(\"Cluster size(sectors) = %d\\r\\n\", fs-&gt;csize);\n    printf(\"Total cluster count = %ld\\r\\n\", fs-&gt;n_fatent - 2);\n    printf(\"Total sector count = %ld\\r\\n\", tot_sect);\n\n    // Total space\n#if _MAX_SS == _MIN_SS\n    printf(\"Total space = %ld(MB) = %ld(GB)\\r\\n\", totalSpace, totalSpace &gt;&gt; 10);\n#else\n    printf(\"Total space = %ld(KB) = %ld(MB)\\r\\n\", totalSpace, totalSpace &gt;&gt; 10);\n#endif\n\n    // Free cluster count\n    printf(\"Free cluster count = %ld\\r\\n\", fre_clust);\n    // Free sector count\n    printf(\"Free sector count = %ld\\r\\n\", fre_sect);\n\n    // Free space\n#if _MAX_SS == _MIN_SS\n    printf(\"Free space = %ld(MB) = %ld(GB)\\r\\n\", freespace, freespace &gt;&gt; 10);\n#else\n    printf(\"Free space = %ld(KB) = %ld(MB)\\r\\n\", freespace, freespace &gt;&gt; 10);\n#endif\n\n    printf(\"Get FAT disk info OK\\r\\n\");\n}\n\n/* Create a text file */\nvoid FatFs_WriteTXTFile(TCHAR *filename, uint16_t year, uint8_t month, uint8_t day)\n{\n    FIL file;\n    printf(\"\\r\\n*** Creating TXT file: %s ***\\r\\n\", filename);\n\n    FRESULT res = f_open(&amp;file, filename, FA_CREATE_ALWAYS | FA_WRITE);\n    // File opened/created successfully\n    if (res == FR_OK)\n    {\n        // String must have a newline character \"\\n\"\n        TCHAR str[] = \"Line1: Hello, FatFs***\\n\";\n        // Does not write the end character \"\\0\"\n        f_puts(str, &amp;file);\n\n        printf(\"Write file OK: %s\\r\\n\", filename);\n    }\n    else\n    {\n        printf(\"Open file error, error code: %d\\r\\n\", res);\n    }\n    // Close the file after use\n    f_close(&amp;file);\n}\n\n/* Read the content of a text file */\nvoid FatFs_ReadTXTFile(TCHAR *filename)\n{\n    printf(\"\\r\\n*** Reading TXT file: %s ***\\r\\n\", filename);\n\n    FIL file;\n    // Open file in read-only mode\n    FRESULT res = f_open(&amp;file, filename, FA_READ);\n    // Opened successfully\n    if (res == FR_OK)\n    {\n        // Read buffer\n        TCHAR str[100];\n        // Not reached the end of file\n        while (!f_eof(&amp;file))\n        {\n            // Read 1 string, automatically add end character \"\\0\"\n            f_gets(str, 100, &amp;file);\n            printf(\"%s\", str);\n        }\n        printf(\"\\r\\n\");\n    }\n    // File does not exist\n    else if (res == FR_NO_FILE)\n        printf(\"File does not exist\\r\\n\");\n    // Opening failed\n    else\n        printf(\"f_open() error, error code: %d\\r\\n\", res);\n    // Close the file\n    f_close(&amp;file);\n}\n\n/* Scan and display files and directories in the specified directory */\nvoid FatFs_ScanDir(const TCHAR *PathName)\n{\n    DIR dir;     // Directory object\n    FILINFO fno; // File information\n    // Open directory\n    FRESULT res = f_opendir(&amp;dir, PathName);\n    // Opening failed\n    if (res != FR_OK)\n    {\n        // Close directory and exit function\n        f_closedir(&amp;dir);\n        printf(\"\\r\\nf_opendir() error, error code: %d\\r\\n\", res);\n        return;\n    }\n\n    printf(\"\\r\\n*** All entries in dir: %s ***\\r\\n\", PathName);\n    // Read files in the directory sequentially\n    while (1)\n    {\n        // Read one item in the directory\n        res = f_readdir(&amp;dir, &amp;fno);\n        // If file name is empty, no more items to read\n        if (res != FR_OK || fno.fname[0] == 0)\n            break;\n        // If it is a directory\n        if (fno.fattrib &amp; AM_DIR)\n        {\n            printf(\"DIR: %s\\r\\n\", fno.fname);\n        }\n        // If it is a file\n        else\n        {\n            printf(\"FILE: %s\\r\\n\", fno.fname);\n        }\n    }\n    // Scanning finished, close directory\n    printf(\"Scan dir OK\\r\\n\");\n    f_closedir(&amp;dir);\n}\n\n/* Get information of a file */\nvoid FatFs_GetFileInfo(TCHAR *filename)\n{\n    printf(\"\\r\\n*** File info of: %s ***\\r\\n\", filename);\n\n    FILINFO fno;\n    // Check if file or subdirectory exists\n    FRESULT fr = f_stat(filename, &amp;fno);\n    // If exists, read file information from fno\n    if (fr == FR_OK)\n    {\n        printf(\"File size(bytes) = %ld\\r\\n\", fno.fsize);\n        printf(\"File attribute = 0x%x\\r\\n\", fno.fattrib);\n        printf(\"File Name = %s\\r\\n\", fno.fname);\n        // Output the timestamp of file creation/modification\n        FatFs_PrintfFileDate(fno.fdate, fno.ftime);\n    }\n    // If file does not exist\n    else if (fr == FR_NO_FILE)\n        printf(\"File does not exist\\r\\n\");\n    // Other error occurred\n    else\n        printf(\"f_stat() error, error code: %d\\r\\n\", fr);\n}\n\n/* Delete a file */\nvoid FatFs_DeleteFile(TCHAR *filename)\n{\n    printf(\"\\r\\n*** Delete File: %s***\\r\\n\", filename);\n    FIL file;\n    // Open file\n    FRESULT res = f_open(&amp;file, filename, FA_OPEN_EXISTING);\n    if (res == FR_OK)\n    {\n        // Close file\n        f_close(&amp;file);\n        printf(\"Open successfully!\\r\\n\");\n    }\n    // Delete file\n    res = f_unlink(filename);\n    // Delete successfully\n    if (res == FR_OK)\n    {\n        printf(\"The file was deleted successfully!\\r\\n\");\n    }\n    // Delete failed\n    else\n    {\n        printf(\"File deletion failed, error code: %d\\r\\n\", res);\n    }\n}\n\n/* Print file date */\nvoid FatFs_PrintfFileDate(WORD date, WORD time)\n{\n    printf(\"File date = %d/%d/%d\\r\\n\", ((date &gt;&gt; 9) &amp; 0x7F) + 1980, (date &gt;&gt; 5) &amp; 0xF, date &amp; 0x1F);\n    printf(\"File time = %d:%d:%d\\r\\n\", (time &gt;&gt; 11) &amp; 0x1F, (time &gt;&gt; 5) &amp; 0x3F, time &amp; 0x1F);\n}\n\n\n// to over write BSP_SD_ReadBlocks_DMA &amp; BSP_SD_WriteBlocks_DMA in bsp_driver_sd.c\nuint8_t BSP_SD_ReadBlocks_DMA(uint32_t *pData, uint32_t ReadAddr, uint32_t NumOfBlocks)\n{\n  uint8_t sd_state = MSD_OK;\n\n  SCB_CleanDCache();\n\n  /* Read block(s) in DMA transfer mode */\n  if (HAL_SD_ReadBlocks_DMA(&amp;hsd1, (uint8_t *)pData, ReadAddr, NumOfBlocks) != HAL_OK)\n  {\n    sd_state = MSD_ERROR;\n  }\n\n  return sd_state;\n}\n\nuint8_t BSP_SD_WriteBlocks_DMA(uint32_t *pData, uint32_t WriteAddr, uint32_t NumOfBlocks)\n{\n  uint8_t sd_state = MSD_OK;\n\n  SCB_CleanDCache();\n\n  /* Write block(s) in DMA transfer mode */\n  if (HAL_SD_WriteBlocks_DMA(&amp;hsd1, (uint8_t *)pData, WriteAddr, NumOfBlocks) != HAL_OK)\n  {\n    sd_state = MSD_ERROR;\n  }\n\n  return sd_state;\n}\n</code></pre>"},{"location":"MAIN-CONTROL/FMC/fmc/","title":"FMC","text":"<p>Info</p> <p>FMC stands for Flexible Memory Controller. It is a feature that allows the MCU to interface with external memory devices such as SDRAM, SRAM, and NOR Flash. </p>"},{"location":"MAIN-CONTROL/FMC/fmc/#fmc-setup","title":"FMC SETUP","text":"<p>As shown, in the 'Connectivity' tab, enable FMC, and then enable the SDRAM device in FMC configuration zone, and set the parameters according to the datasheet of the SDRAM device.</p>"},{"location":"MAIN-CONTROL/FMC/fmc/#sdram","title":"SDRAM","text":"<p>SDRAM is one of the most common types of external memory devices that can be interfaced with the MCU using the FMC. It is a type of volatile memory that is used in computers and other electronic devices. Here, since the built-in RAM is only 1MB, and not enough for some applications, we need to use external SDRAM to expand the memory capacity.</p>"},{"location":"MAIN-CONTROL/FMC/fmc/#generate-and-update-code","title":"GENERATE AND UPDATE CODE","text":"<p>Finally, let's generate the code to save the current progress and to make it ready for following programming steps. Click the 'Generate Code' button at the top right corner of the screen.</p>"},{"location":"MAIN-CONTROL/LED/led/","title":"LED","text":""},{"location":"MAIN-CONTROL/LED/led/#led-circuit-design","title":"LED CIRCUIT DESIGN","text":""},{"location":"MAIN-CONTROL/LED/led/#configure-the-pin","title":"CONFIGURE THE PIN","text":""},{"location":"MAIN-CONTROL/LED/led/#select-and-set-pin-mode","title":"SELECT AND SET PIN MODE","text":"<p>According to the circuit design, select the corresponding pin PH7 and set the mode to \"GPIO Output\".</p>"},{"location":"MAIN-CONTROL/LED/led/#gpio-setting","title":"GPIO SETTING","text":"<p>In the leftmost pane, select the \"GPIO\" tab and set the parameters for PH7 as shown in the figure below.</p> <ul> <li>GPIO OUTPUT LEVEL: LOW</li> </ul> <p>Info</p> <p>As can be seen from the circuit design, low level output can light up the LED and high level output can turn off the LED.</p> <ul> <li>GPIO MODE: Output</li> </ul> <p>Here, we set the pin mode to \"Output\" as we use it as a control for LED.</p> <ul> <li>GPIO PULL-UP/PULL-DOWN: PULL-UP</li> </ul> <p>Info</p> <p>The pull-up resistor is used to ensure that the pin is in a high state when it is not connected to the ground.</p> <ul> <li>GPIO SPEED: Very High</li> </ul> <p>Info</p> <p>The speed of the GPIO pin means the speed at which the pin changes from one state to another. Here, we set it to \"Very High\" to ensure that the LED can be turned on and off quickly. This is no strict requirement for the speed setting of the LED pin, but it is recommended to set it to \"Very High\" for better performance.</p> <ul> <li>USER LABEL: LED</li> </ul> <p>Info</p> <p>The user label is used to mark the pin for easy identification. Here, we set it to \"LED\" to indicate that this pin is used to control the LED.</p>"},{"location":"MAIN-CONTROL/LED/led/#generate-and-update-code","title":"GENERATE AND UPDATE CODE","text":"<p>Finally, let's generate the code to save the current progress and to make it ready for following programming steps. Click the 'Generate Code' button at the top right corner of the screen.</p>"},{"location":"MAIN-CONTROL/LED/led/#programming-in-keil","title":"PROGRAMMING IN KEIL","text":""},{"location":"MAIN-CONTROL/LED/led/#incorporate-the-module-code","title":"INCORPORATE THE MODULE CODE","text":"<p>We have introduced how to transplant and incorporate the BSP code into the project, and that applies to each respective module. For transplantation:</p> <ol> <li>Copy the module codes from the BSP project to the user project.</li> <li>Add the module codes to the user project include path.</li> <li>Add the module codes to the project items.</li> <li>Include the header file of the module code in the user project.</li> <li>Call the module function in the user project.</li> </ol>"},{"location":"MAIN-CONTROL/LED/led/#code-review-led","title":"CODE REVIEW - LED","text":"<p>Let's review the code for the LED module. This module is actually very simple, readers can refer to the code below for details.</p>"},{"location":"MAIN-CONTROL/LED/led/#iledh","title":"iled.h","text":"<pre><code>/*\n * iled.h\n *\n *  Created on: June 07, 2024\n *      Author: SHUAIWEN CUI\n */\n\n#ifndef ILED_H_\n#define ILED_H_\n\n#include \"stm32h7xx_hal.h\" // HAL library file declaration, replace it with the corresponding file according to the actual situation\n#include \"main.h\" // IO definition and initialization function are in the main.c file, must be referenced\n\nvoid LED(uint8_t state);// LED independent control function (0 is off, other values are on)\nvoid LED_Toggle(void);// LED Toggle\n\n#endif /* ILED_H_ */\n</code></pre>"},{"location":"MAIN-CONTROL/LED/led/#iledc","title":"iled.c","text":"<pre><code>/*\n * iled.c\n *\n *  Created on: June 07, 2024\n *      Author: SHUAIWEN CUI\n */\n\n#include \"iled.h\"\n\nvoid LED(uint8_t state) // LED R independent control function (0 is off, other values are on)\n{\n\n    if (state)\n    {\n        HAL_GPIO_WritePin(LED_GPIO_Port, LED_Pin, GPIO_PIN_RESET);\n    }\n    else\n    {\n        HAL_GPIO_WritePin(LED_GPIO_Port, LED_Pin, GPIO_PIN_SET);\n    }\n}\n\nvoid LED_Toggle(void)\n{\n    int state = HAL_GPIO_ReadPin(LED_GPIO_Port, LED_Pin);\n    HAL_GPIO_WritePin(LED_GPIO_Port, LED_Pin, 1 - state);\n}\n</code></pre>"},{"location":"MAIN-CONTROL/MEMORY/memory/","title":"MEMORY MANAGEMENT","text":""},{"location":"MAIN-CONTROL/RTOS/rtos/","title":"REAL TIME OPERATING SYSTEM (RTOS)","text":"<p>To be updated.</p>"},{"location":"MAIN-CONTROL/SDCARD/sdcard/","title":"SDCARD","text":"<p>Info</p> <p>SDCARD is the abbreviation of Secure Digital Memory Card. It is a type of non-volatile memory card used in computers and other electronic devices. Here, we will use the SDMMC peripheral to interface with the SD card.</p>"},{"location":"MAIN-CONTROL/SDCARD/sdcard/#sdcard-circuit","title":"SDCARD CIRCUIT","text":""},{"location":"MAIN-CONTROL/SDCARD/sdcard/#sdcard-configuration","title":"SDCARD CONFIGURATION","text":"<p>To enable SDCARD, we need to enable SDMMC for this development board. For some other development boards, you may need to enable the SDMMC peripheral.</p> <p>For SDMMC configuration, refer to SDMMC tab.</p>"},{"location":"MAIN-CONTROL/SDCARD/sdcard/#sdcard-gpio","title":"SDCARD GPIO","text":"<p>For SD card, we can use the default GPIO pins. However, you can change the GPIO pins according to your requirements.</p>"},{"location":"MAIN-CONTROL/SDCARD/sdcard/#generate-and-update-code","title":"GENERATE AND UPDATE CODE","text":"<p>Finally, let's generate the code to save the current progress and to make it ready for following programming steps. Click the 'Generate Code' button at the top right corner of the screen.</p>"},{"location":"MAIN-CONTROL/SDCARD/sdcard/#programming-in-keil","title":"PROGRAMMING IN KEIL","text":""},{"location":"MAIN-CONTROL/SDCARD/sdcard/#incorporate-the-module-code","title":"INCORPORATE THE MODULE CODE","text":"<p>We have introduced how to transplant and incorporate the BSP code into the project, and that applies to each respective module. For transplantation:</p> <ol> <li>Copy the module codes from the BSP project to the user project.</li> <li>Add the module codes to the user project include path.</li> <li>Add the module codes to the project items.</li> <li>Include the header file of the module code in the user project.</li> <li>Call the module function in the user project.</li> </ol>"},{"location":"MAIN-CONTROL/SDCARD/sdcard/#code-review-sdcard","title":"CODE REVIEW - SDCARD","text":""},{"location":"MAIN-CONTROL/SDCARD/sdcard/#isdcardh","title":"isdcard.h","text":"<pre><code>/**\n * @file isdcard.h\n * @author SHUAIWEN CUI (shuaiwencui AT gmail DOT com)\n * @brief This is the header file for the isdcard.c file\n * @version 1.0\n * @date 2024-07-16\n * @ref https://blog.csdn.net/mculover666/article/details/100555620\n * @copyright Copyright (c) 2024\n *\n */\n#ifndef __ISDCARD_H\n#define __ISDCARD_H\n\n/**\n * @name INCLUDES\n */\n\n#include \"stm32h7xx.h\"\n\n/**\n * @name MACROS\n */\n\n\n/**\n * @name VARIABLES\n *\n */\nextern uint8_t read_buf[512];\nextern uint8_t write_buf[512];\n\n/**\n * @name FUNCTION PROTOTYPES\n */\n/**\n * @name SD_Init\n * @brief SD card initialization, this function handles the part that not processed by CUBEMX.\n */\nint SD_Init(void);\n\n/**\n * @name SD_Test\n * @brief Display the SD card information for SD card testing\n * \n */\nint SD_Test(void);\n\n#endif /* __ISDCARD_H */\n</code></pre>"},{"location":"MAIN-CONTROL/SDCARD/sdcard/#isdcardc","title":"isdcard.c","text":"<pre><code>/**\n * @file isdcard.c\n * @author SHUAIWEN CUI (shuaiwencui AT gmail DOT com)\n * @brief This is the source file for the isdcard.c file\n * @version 1.0\n * @date 2024-07-16\n * @ref https://blog.csdn.net/mculover666/article/details/100555620\n * @copyright Copyright (c) 2024\n *\n */\n\n/**\n * @name INCLUDES\n *\n */\n#include \"sdmmc.h\"\n#include \"iusart.h\"\n\n/**\n * @name MACROS\n *\n */\n\n/**\n * @name VARIABLES\n *\n */\nuint8_t read_buf[512];\nuint8_t write_buf[512];\n/**\n * @name FUNCTIONS\n * @brief SD card info struct\n * @param None\n * @retval int 0: success, -1: error\n */\n\n/**\n * @name SD_Init\n * @brief SD card initialization, this function handles the part that not processed by CUBEMX.\n */\nint SD_Init(void)\n{\n    HAL_SD_MspInit(&amp;hsd1);\n    if (HAL_SD_Init(&amp;hsd1) != HAL_OK)\n    {\n        printf(\"[Initialization] SD card initialization failed - HAL_SD_Init().\\n\\r\");\n        return -1;\n    }\n    if (HAL_SD_ConfigWideBusOperation(&amp;hsd1, SDMMC_BUS_WIDE_4B) != HAL_OK)\n    {\n        printf(\"[Initialization] SD card initialization failed - HAL_SD_ConfigWideBusOperation().\\n\\r\");\n        return -1;\n    }\n    return 0;\n}\n\n/**\n * @name SD_Test\n * @brief Display the SD card information for SD card testing\n *\n */\nint SD_Test(void)\n{\n    int i;\n\n    int sdcard_status = 0;\n    HAL_SD_CardCIDTypeDef sdcard_cid;\n\n    printf(\"[INITIALIZATION] Micro SD Card Test...\\r\\n\");\n\n    /* Check if the SD card is operating correctly (in transfer mode) */\n    sdcard_status = HAL_SD_GetCardState(&amp;hsd1);\n    if (sdcard_status == HAL_SD_CARD_TRANSFER)\n    {\n        printf(\"[INITIALIZATION] SD card init ok!\\r\\n\\r\\n\");\n\n        // Print basic SD card information\n        printf(\"[INITIALIZATION] SD card information:\\r\\n\");\n        printf(\"[INITIALIZATION] Card Capacity: %llu MB\\r\\n\", ((unsigned long long)hsd1.SdCard.BlockSize * hsd1.SdCard.BlockNbr/1024/1024));\n        printf(\"[INITIALIZATION] Card BlockSize: %d \\r\\n\", hsd1.SdCard.BlockSize);\n        printf(\"[INITIALIZATION] Relative Card Address: %d \\r\\n\", hsd1.SdCard.RelCardAdd);\n        printf(\"[INITIALIZATION] Card Type: %d \\r\\n\", hsd1.SdCard.CardType);\n\n        // Read and print the SD card CID information\n        HAL_SD_GetCardCID(&amp;hsd1, &amp;sdcard_cid);\n        printf(\"[INITIALIZATION] ManufacturerID: %d \\r\\n\", sdcard_cid.ManufacturerID);\n    }\n    else\n    {\n        printf(\"[INITIALIZATION] SD card init fail!\\r\\n\");\n        return 0;\n    }\n\n    /* Erase SD card block */\n    printf(\"[INITIALIZATION] ------------------- Block Erase ------------------------------\\r\\n\");\n    sdcard_status = HAL_SD_Erase(&amp;hsd1, 0, 512);\n    if (sdcard_status == 0)\n    {\n        printf(\"[INITIALIZATION] Erase block ok!\\r\\n\");\n    }\n    else\n    {\n        printf(\"[INITIALIZATION] Erase block fail!\\r\\n\");\n    }\n\n    /* Read data before any operation */\n    printf(\"[INITIALIZATION] ------------------- Read SD card block data Test -------------\\r\\n\");\n    sdcard_status = HAL_SD_ReadBlocks(&amp;hsd1, (uint8_t *)read_buf, 0, 1, 0xffff);\n    if (sdcard_status == 0)\n    {\n        printf(\"[INITIALIZATION] Read block data ok!\\r\\n\");\n        for (i = 0; i &lt; 512; i++)\n        {\n            printf(\"0x%02x \", read_buf[i]);\n            if ((i + 1) % 16 == 0)\n            {\n                printf(\"\\r\\n\");\n            }\n        }\n    }\n    else\n    {\n        printf(\"[INITIALIZATION] Read block data fail!\\r\\n \");\n    }\n\n    /* Fill buffer with data */\n    for (i = 0; i &lt; 512; i++)\n    {\n        write_buf[i] = i % 256;\n    }\n\n    /* Write data to SD card block */\n    printf(\"[INITIALIZATION] ------------------- Write SD card block data Test ------------\\r\\n\");\n    sdcard_status = HAL_SD_WriteBlocks(&amp;hsd1, (uint8_t *)write_buf, 0, 1, 0xffff);\n    if (sdcard_status == 0)\n    {\n        printf(\"[INITIALIZATION] Write block data ok!\\r\\n\");\n    }\n    else\n    {\n        printf(\"[INITIALIZATION] Write block data fail!\\r\\n \");\n    }\n\n    /* Read data after write operation */\n    printf(\"[INITIALIZATION] ------------------- Read SD card block data after Write ------\\r\\n\");\n    sdcard_status = HAL_SD_ReadBlocks(&amp;hsd1, (uint8_t *)read_buf, 0, 1, 0xffff);\n    if (sdcard_status == 0)\n    {\n        printf(\"[INITIALIZATION] Read block data ok!\\r\\n\");\n        for (i = 0; i &lt; 512; i++)\n        {\n            printf(\"0x%02x \", read_buf[i]);\n            if ((i + 1) % 16 == 0)\n            {\n                printf(\"\\r\\n\");\n            }\n        }\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"MAIN-CONTROL/SDMMC/sdmmc/","title":"SDMMC","text":"<p>Info</p> <p>SDMMC stands for Secure Digital Memory Card. It is a type of non-volatile memory card that is used in computers and other electronic devices. Here, we will use the SDMMC peripheral to interface with an SD card.</p>"},{"location":"MAIN-CONTROL/SDMMC/sdmmc/#enable-sdmmc","title":"ENABLE SDMMC","text":"<p>As shown, in the 'Connectivity' tab, enable the SDMMC peripheral. Note that, the divider is set to 2. Note that, at this time, you may need to reconfigure the clock settings in the 'Clock Configuration' tab.</p>"},{"location":"MAIN-CONTROL/SDMMC/sdmmc/#enable-mdma","title":"ENABLE MDMA","text":"<p>Info</p> <p>MDMA stands for Memory Direct Memory Access. It is a type of DMA that is used to transfer data between memory and memory. Here, we will use MDMA to transfer data between the SD card and the SDRAM.</p>"},{"location":"MAIN-CONTROL/SDMMC/sdmmc/#enable-nvic","title":"ENABLE NVIC","text":"<p>As shown, in the 'NVIC Settings' tab, enable the SDMMC interrupt.</p>"},{"location":"MAIN-CONTROL/SDMMC/sdmmc/#nvic-configuration","title":"NVIC CONFIGURATION","text":"<p>So far, the NVIC settings are as shown. </p>"},{"location":"MAIN-CONTROL/SDMMC/sdmmc/#generate-and-update-code","title":"GENERATE AND UPDATE CODE","text":"<p>Finally, let's generate the code to save the current progress and to make it ready for following programming steps. Click the 'Generate Code' button at the top right corner of the screen.</p>"},{"location":"MAIN-CONTROL/SDRAM/sdram/","title":"SDRAM","text":"<p>Info</p> <p>SDRAM stands for Synchronous Dynamic Random Access Memory. It is a type of volatile memory that is used in computers and other electronic devices. Here, since the built-in RAM is only 1MB, and not enough for some applications, we need to use external SDRAM to expand the memory capacity.</p>"},{"location":"MAIN-CONTROL/SDRAM/sdram/#sdram-circuit","title":"SDRAM CIRCUIT","text":"<p>Please carefully compare the pin design with the pin setup in CUBEMX, ensure that the pin configuration is consistent with the hardware connection. In our case, only PH2, PH3, and PH5 are not consistent, so we can manually set up them in the chip view on the right hand side and set them to their respective functions as designed.</p>"},{"location":"MAIN-CONTROL/SDRAM/sdram/#sdram-parameters","title":"SDRAM PARAMETERS","text":"<p>The SDRAM Module we are using is WINBOND W9825G6KH-6I. You can find the datasheet here. The parameters are calculated according to the datasheet.</p>"},{"location":"MAIN-CONTROL/SDRAM/sdram/#gpio-configuration","title":"GPIO CONFIGURATION","text":"<p>Check the pin configuration. Compare the setup in CUBEMX with the pin design.</p>"},{"location":"MAIN-CONTROL/SDRAM/sdram/#generate-and-update-code","title":"GENERATE AND UPDATE CODE","text":"<p>Finally, let's generate the code to save the current progress and to make it ready for following programming steps. Click the 'Generate Code' button at the top right corner of the screen.</p>"},{"location":"MAIN-CONTROL/SDRAM/sdram/#programming-in-keil","title":"PROGRAMMING IN KEIL","text":""},{"location":"MAIN-CONTROL/SDRAM/sdram/#incorporate-the-module-code","title":"INCORPORATE THE MODULE CODE","text":"<p>We have introduced how to transplant and incorporate the BSP code into the project, and that applies to each respective module. For transplantation:</p> <ol> <li>Copy the module codes from the BSP project to the user project.</li> <li>Add the module codes to the user project include path.</li> <li>Add the module codes to the project items.</li> <li>Include the header file of the module code in the user project.</li> <li>Call the module function in the user project.</li> </ol>"},{"location":"MAIN-CONTROL/SDRAM/sdram/#code-review-sdram","title":"CODE REVIEW - SDRAM","text":"<p>Let's review the code for the SDRAM module. </p>"},{"location":"MAIN-CONTROL/SDRAM/sdram/#isdramh","title":"isdram.h","text":"<pre><code>/**\n * @file isdram.h\n * @author SHUAIWEN CUI (shuaiwencui AT gmail DOT com)\n * @brief This file is the header file for the isdram.c file\n * @version 1.0\n * @date 2024-07-16\n * @ref https://blog.csdn.net/Believeziwo/article/details/131372421\n */\n#ifndef __ISDRAM_H\n#define __ISDRAM_H\n\n/**\n * @name INCLUDES\n *\n */\n#include \"stm32h7xx.h\"\n#include &lt;stdio.h&gt;\n\n/**\n * @name MACROS\n *\n */\n#define W9825G6KH_SIZE (32 * 1024 * 1024) // 32M Bytes W9825G6\n#define FMC_BANK_SDRAM FMC_Bank1_SDRAM\n#define FMC_COMMAND_TARGET_BANK FMC_SDRAM_CMD_TARGET_BANK1\n#define SDRAM_BANK_ADDR ((uint32_t)0xC0000000)\n#define SDRAM_TIMEOUT ((uint32_t)0xFFFF)\n#define SDRAM_MODEREG_BURST_LENGTH_1 ((uint16_t)0x0000)\n#define SDRAM_MODEREG_BURST_LENGTH_2 ((uint16_t)0x0001)\n#define SDRAM_MODEREG_BURST_LENGTH_4 ((uint16_t)0x0002)\n#define SDRAM_MODEREG_BURST_LENGTH_8 ((uint16_t)0x0004)\n#define SDRAM_MODEREG_BURST_TYPE_SEQUENTIAL ((uint16_t)0x0000)\n#define SDRAM_MODEREG_BURST_TYPE_INTERLEAVED ((uint16_t)0x0008)\n#define SDRAM_MODEREG_CAS_LATENCY_2 ((uint16_t)0x0020)\n#define SDRAM_MODEREG_CAS_LATENCY_3 ((uint16_t)0x0030)\n#define SDRAM_MODEREG_OPERATING_MODE_STANDARD ((uint16_t)0x0000)\n#define SDRAM_MODEREG_WRITEBURST_MODE_PROGRAMMED ((uint16_t)0x0000)\n#define SDRAM_MODEREG_WRITEBURST_MODE_SINGLE ((uint16_t)0x0200)\n\n#define SDRAM_DEBUG_ON 1\n#define SDRAM_INFO(fmt, arg...) printf(\"[INITIALIZATION] \" fmt \"\\n\", ##arg)\n#define SDRAM_ERROR(fmt, arg...) printf(\"[INITIALIZATION] \" fmt \"\\n\", ##arg)\n#define SDRAM_DEBUG(fmt, arg...)                                       \\\n    do                                                                 \\\n    {                                                                  \\\n        if (SDRAM_DEBUG_ON)                                            \\\n            printf(\"[INITIALIZATION] [%d]\" fmt \"\\n\", __LINE__, ##arg); \\\n    } while (0)\n\n/**\n * @name FUNCTION PROTOTYPES\n *\n */\nvoid SDRAM_InitSequence(void);\nvoid SDRAM_WriteBuffer(uint32_t *pBuffer, uint32_t uwWriteAddress, uint32_t uwBufferSize);\nvoid SDRAM_ReadBuffer(uint32_t *pBuffer, uint32_t uwReadAddress, uint32_t uwBufferSize);\nuint8_t SDRAM_Test(void);\n\n#endif /* __ISDRAM_H */\n</code></pre>"},{"location":"MAIN-CONTROL/SDRAM/sdram/#isdramc","title":"isdram.c","text":"<pre><code>/**\n * @file isdram.c\n * @author SHUAIWEN CUI (shuaiwencui AT gmail DOT com)\n * @brief This file is the source file for the isdram.c file\n * @version 1.0\n * @date 2024-07-16\n * @ref https://blog.csdn.net/Believeziwo/article/details/131372421\n */\n\n/**\n * @name INCLUDES\n *\n */\n#include \"isdram.h\"\n#include \"fmc.h\"\n\n/**\n * @name VARIABLES\n *\n */\nstatic FMC_SDRAM_CommandTypeDef Command;\n#define sdramHandle hsdram1 // defined in fmc.c\n\n/**\n * @name FUNCTIONS\n *\n */\n\n/**\n  * @brief  initialize SDRAM in 6 steps\n  * @param  None. \n  * @retval None.\n  * ! This is the core for SDRAM initialization. CubeMX will do FMC initialization, then we need this function to do SDRAM initialization. After that, we can use SDRAM in the application layer.\n  */\nvoid SDRAM_InitSequence(void)\n{\n    uint32_t temp = 0;\n\n    /* Step 1 ----------------------------------------------------------------*/\n    /* CONFIGURE COMMAND: enable the clock for sdram */\n    Command.CommandMode = FMC_SDRAM_CMD_CLK_ENABLE;\n    Command.CommandTarget = FMC_COMMAND_TARGET_BANK;\n    Command.AutoRefreshNumber = 1;\n    Command.ModeRegisterDefinition = 0;\n    /* send command */\n    HAL_SDRAM_SendCommand(&amp;sdramHandle, &amp;Command, SDRAM_TIMEOUT);\n\n    /* delay for a while at least 200us */\n    HAL_Delay(1); // 1ms&gt;200us\n\n    /* Step 3 ----------------------------------------------------------------*/\n    /* CONFIGURE COMMAND: precharge all bank */\n    Command.CommandMode = FMC_SDRAM_CMD_PALL;\n    Command.CommandTarget = FMC_COMMAND_TARGET_BANK;\n    Command.AutoRefreshNumber = 1;\n    Command.ModeRegisterDefinition = 0;\n    /* send command */\n    HAL_SDRAM_SendCommand(&amp;sdramHandle, &amp;Command, SDRAM_TIMEOUT);   \n\n    /* Step 4 ----------------------------------------------------------------*/\n    /* CONFIGURE COMMAND: auto refresh */   \n    Command.CommandMode = FMC_SDRAM_CMD_AUTOREFRESH_MODE;\n    Command.CommandTarget = FMC_COMMAND_TARGET_BANK;\n    Command.AutoRefreshNumber = 8;\n    Command.ModeRegisterDefinition = 0;\n    /* send command */\n    HAL_SDRAM_SendCommand(&amp;sdramHandle, &amp;Command, SDRAM_TIMEOUT);\n\n    /* Step 5 ----------------------------------------------------------------*/\n    /* CONFIGURE SDRAM LOAD MODE register */\n    temp = (uint32_t)SDRAM_MODEREG_BURST_LENGTH_1          |\n                   SDRAM_MODEREG_BURST_TYPE_SEQUENTIAL   |\n                   SDRAM_MODEREG_CAS_LATENCY_3           |\n                   SDRAM_MODEREG_OPERATING_MODE_STANDARD |\n                   SDRAM_MODEREG_WRITEBURST_MODE_SINGLE;\n\n    /* CONFIGURE COMMAND: set SDRAM register */\n    Command.CommandMode = FMC_SDRAM_CMD_LOAD_MODE;\n    Command.CommandTarget = FMC_COMMAND_TARGET_BANK;\n    Command.AutoRefreshNumber = 1;\n    Command.ModeRegisterDefinition = temp;\n    /* send command */\n    HAL_SDRAM_SendCommand(&amp;sdramHandle, &amp;Command, SDRAM_TIMEOUT);\n\n    /* Step 6 ----------------------------------------------------------------*/\n    /* CONFIGURE REFRESH COUNTER */\n  /*\n    (SDRAM refresh period / Number of rows\uff09*SDRAM Clock Speed \u2013 20\n    = 64000(64 ms) / 8192*120MHz - 20\n    = 917.2 ~ 918\n\n    note: 64 / 8192 = 7.81us\n  */\n    /* CONFIGURE REFRESH RATE */\n    HAL_SDRAM_ProgramRefreshRate(&amp;sdramHandle, 918); \n}\n\n/**\n  * @brief  write data to SDRAM in \"word\" format\n  * @param  pBuffer:  pointer to data\n  * @param  uwWriteAddress: address to write in SDRAM\n  * @param  uwBufferSize: size of data to write\n  * @retval None.\n  */\nvoid SDRAM_WriteBuffer(uint32_t* pBuffer, uint32_t uwWriteAddress, uint32_t uwBufferSize)\n{\n  __IO uint32_t write_pointer = (uint32_t)uwWriteAddress;\n\n  /* Disable write protection */\n  HAL_SDRAM_WriteProtection_Disable(&amp;hsdram1);\n  /* Check the SDRAM state */\n  while(HAL_SDRAM_GetState(&amp;hsdram1) != RESET)\n  {\n  }\n\n  /* write data to SDRAM by loops*/\n  for (; uwBufferSize != 0; uwBufferSize--) \n  {\n    /* write data to SDRAM */\n    *(uint32_t *) (SDRAM_BANK_ADDR + write_pointer) = *pBuffer++;\n\n    /* address increment */\n    write_pointer += 4;\n  }\n\n}\n\n/**\n  * @brief  read data from SDRAM\n  * @param  pBuffer: pointer to data\n  * @param  ReadAddress: address to read in SDRAM\n  * @param  uwBufferSize: size of data to read\n  * @retval None.\n  */\nvoid SDRAM_ReadBuffer(uint32_t* pBuffer, uint32_t uwReadAddress, uint32_t uwBufferSize)\n{\n  __IO uint32_t write_pointer = (uint32_t)uwReadAddress;\n\n\n  /* Check the SDRAM state */\n  while ( HAL_SDRAM_GetState(&amp;hsdram1) != RESET)\n  {\n  }\n\n  /* read data from SDRAM */\n  for(; uwBufferSize != 0x00; uwBufferSize--)\n  {\n   *pBuffer++ = *(__IO uint32_t *)(SDRAM_BANK_ADDR + write_pointer );\n\n   /* address increment */\n    write_pointer += 4;\n  } \n}\n\n\n/**\n  * @brief  Test SDRAM\n  * @param  None\n  * @retval normal as 1, abnormal as 0\n  */\nuint8_t SDRAM_Test(void)\n{\n  /* counter for write data */\n  uint32_t counter=0;\n\n  /* 8 bit data */\n  uint8_t ubWritedata_8b = 0, ubReaddata_8b = 0;  \n\n  /* 16 bit data */\n  uint16_t uhWritedata_16b = 0, uhReaddata_16b = 0; \n\n  /* 32 bit data */\n  uint32_t uwWritedata_32b = 0, uwReaddata_32b = 0;\n\n  SDRAM_INFO(\"TESTING SDRAM..., WRITE AND READ AS 8/16/32 BIT...\");\n\n\n  /* 8 bit data read and write*/\n\n  /* reset SDRAM data to 0, W9825G6KH_SIZE is in 8 bit */\n  for (counter = 0x00; counter &lt; W9825G6KH_SIZE; counter++)\n  {\n    *(__IO uint8_t*) (SDRAM_BANK_ADDR + counter) = (uint8_t)0x0;\n  }\n\n  /* write data to SDRAM */\n  for (counter = 0; counter &lt; W9825G6KH_SIZE; counter++)\n  {\n    *(__IO uint8_t*) (SDRAM_BANK_ADDR + counter) = (uint8_t)(ubWritedata_8b + counter);\n  }\n\n  /* read data from SDRAM and check */\n  for(counter = 0; counter&lt;W9825G6KH_SIZE;counter++ )\n  {\n    ubReaddata_8b = *(__IO uint8_t*)(SDRAM_BANK_ADDR + counter);  // read data from SDRAM\n\n    if(ubReaddata_8b != (uint8_t)(ubWritedata_8b + counter))      // check data, if not equal, return 0\n    {\n      SDRAM_ERROR(\"8 BIT DATA READ AND WRITE ERROR!\");\n      return -1;\n    }\n  }\n\n\n  /* 16 bit data read and write*/\n\n  /* reset SDRAM data to 0 */\n  for (counter = 0x00; counter &lt; W9825G6KH_SIZE/2; counter++)\n  {\n    *(__IO uint16_t*) (SDRAM_BANK_ADDR + 2*counter) = (uint16_t)0x00;\n  }\n\n  /* write data to SDRAM */\n  for (counter = 0; counter &lt; W9825G6KH_SIZE/2; counter++)\n  {\n    *(__IO uint16_t*) (SDRAM_BANK_ADDR + 2*counter) = (uint16_t)(uhWritedata_16b + counter);\n  }\n\n  /* read data from SDRAM and check */\n  for(counter = 0; counter&lt;W9825G6KH_SIZE/2;counter++ )\n  {\n    uhReaddata_16b = *(__IO uint16_t*)(SDRAM_BANK_ADDR + 2*counter);  // read data from SDRAM\n\n    if(uhReaddata_16b != (uint16_t)(uhWritedata_16b + counter))      // check data, if not equal, return 0\n    {\n      SDRAM_ERROR(\"16 BIT DATA READ AND WRITE ERROR!\");\n\n      return -1;\n    }\n  }\n\n  /* 32 bit data read and write*/\n  /* reset SDRAM data to 0 */\n  for (counter = 0x00; counter &lt; W9825G6KH_SIZE/4; counter++)\n  {\n    *(__IO uint32_t*) (SDRAM_BANK_ADDR + 4*counter) = (uint32_t)0x00;\n  }\n\n  /* write data to SDRAM */\n  for (counter = 0; counter &lt; W9825G6KH_SIZE/4; counter++)\n  {\n    *(__IO uint32_t*) (SDRAM_BANK_ADDR + 4*counter) = (uint32_t)(uwWritedata_32b + counter);\n  }\n\n  /* read data from SDRAM and check */\n  for(counter = 0; counter&lt;W9825G6KH_SIZE/4;counter++ )\n  {\n    uwReaddata_32b = *(__IO uint32_t*)(SDRAM_BANK_ADDR + 4*counter);  // read data from SDRAM\n\n    if(uwReaddata_32b != (uint32_t)(uwWritedata_32b + counter))      // check data, if not equal, return 0\n    {\n      SDRAM_ERROR(\"32 BIT DATA READ AND WRITE ERROR!\");\n      return -1;\n    }\n  }\n\n  SDRAM_INFO(\"SDRAM READ AND WRITE TEST OK!\"); \n  /* normal, return 0 */\n  return 0;\n\n}\n\n\n/*********************************************END OF FILE**********************/\n</code></pre>"},{"location":"MAIN-CONTROL/SDRAM/sdram/#code-review-memory-management","title":"CODE REVIEW - MEMORY MANAGEMENT","text":"<p>Let's review the code for the memory management module. </p>"},{"location":"MAIN-CONTROL/SDRAM/sdram/#imemoryh","title":"imemory.h","text":"<pre><code>/**\n * @file imemory.h\n * @author SHUAIWEN CUI (shuaiwencui AT gmail DOT com)\n * @brief This is the header file for the memory management module.\n * @version 1.0\n * @date 2024-06-30\n * @ref ALIENTEK memory.h &amp; memory.c for STM32H7xx\n * @copyright Copyright (c) 2024\n *\n *\n */\n\n#ifndef __IMEMORY_H\n#define __IMEMORY_H\n\n/**\n * @name INCLUDES\n */\n#include \"stm32h7xx.h\"\n#include &lt;stddef.h&gt;\n#include &lt;stdint.h&gt;\n#include \"iusart.h\"\n#include \"isdram.h\"\n\n/**\n * @name FUNCTION PROTOTYPES\n */\n/**\n * @name memory_init\n * @brief Initialize the memory management module\n * @param None\n * @retval None\n */\nvoid memory_init(void);\n\n/**\n * @name memory_alloc\n * @brief Allocate memory\n * @param size The size of the memory to allocate\n * @return void*\n */\nvoid *memory_alloc(size_t size);\n\n/**\n * @name memory_free\n * @brief Free memory\n * @param ptr The pointer to the memory to free\n * @retval None\n */\nvoid memory_free(void *ptr);\n\n/**\n * @name memory_management_test\n * @brief This function is for memory management test: allocate memory for a given length, set the values, print the values, and free the memory.\n */\nint memory_management_test(void);\n\n\n#endif /* __IMEMORY_H */\n</code></pre>"},{"location":"MAIN-CONTROL/SDRAM/sdram/#imemoryc","title":"imemory.c","text":"<pre><code>/**\n * @file imemory.h\n * @author SHUAIWEN CUI (shuaiwencui AT gmail DOT com)\n * @brief This is the header file for the memory management module.\n * @version 1.0\n * @date 2024-06-30\n * @ref ALIENTEK memory.h &amp; memory.c for STM32H7xx\n * @copyright Copyright (c) 2024\n *\n * ! NOTE:\n * ! The memory management is achieved by using linked lists.\n *\n */\n\n/**\n * @name INCLUDES\n */\n#include \"imemory.h\"\n\n/**\n * @name MACROS\n */\n#define SDRAM_START_ADDR 0xC0000000\n#define SDRAM_SIZE 0x02000000 // 32MB\n\n/**\n * @name list structure for memory management\n */\n// block hearder structure: at the beginning of each block, size indicates the size of the block, next is the pointer to the next free block\ntypedef struct BlockHeader\n{\n    size_t size;              // Block size including header\n    struct BlockHeader *next; // Pointer to the next free block\n} BlockHeader;\n\nstatic BlockHeader *freeList = (BlockHeader *)SDRAM_START_ADDR;\n\n/**\n * @name memory_init\n * @brief Initialize the memory management module\n * @param None\n * @retval None\n */\nvoid memory_init(void)\n{\n    freeList-&gt;size = SDRAM_SIZE;\n    freeList-&gt;next = NULL;\n}\n\n/**\n * @name memory_alloc\n * @brief Allocate memory\n * @param size The size of the memory to allocate\n * @return void*\n */\nvoid *memory_alloc(size_t size)\n{\n    BlockHeader *current = freeList;\n    BlockHeader *previous = NULL;\n\n    // Align size to the size of BlockHeader and to 32-bit boundary\n    size = (size + sizeof(BlockHeader) + sizeof(uint32_t) - 1) &amp; ~(sizeof(uint32_t) - 1);\n\n    while (current)\n    {\n        if (current-&gt;size &gt;= size)\n        {\n            if (current-&gt;size &gt; size + sizeof(BlockHeader))\n            {\n                // Split the block\n                BlockHeader *newBlock = (BlockHeader *)((uint32_t *)current + size / sizeof(uint32_t));\n                newBlock-&gt;size = current-&gt;size - size;\n                newBlock-&gt;next = current-&gt;next;\n                current-&gt;size = size;\n                current-&gt;next = NULL;\n\n                if (previous)\n                {\n                    previous-&gt;next = newBlock;\n                }\n                else\n                {\n                    freeList = newBlock;\n                }\n            }\n            else\n            {\n                // Use the whole block\n                if (previous)\n                {\n                    previous-&gt;next = current-&gt;next;\n                }\n                else\n                {\n                    freeList = current-&gt;next;\n                }\n            }\n            return (void *)((uint32_t *)current + sizeof(BlockHeader) / sizeof(uint32_t));\n        }\n\n        previous = current;\n        current = current-&gt;next;\n    }\n\n    // No suitable block found\n    return NULL;\n}\n\n/**\n * @name memory_free\n * @brief Free memory\n * @param ptr The pointer to the memory to free\n * @retval None\n */\nvoid memory_free(void *ptr)\n{\n    if (!ptr)\n        return;\n\n    BlockHeader *block = (BlockHeader *)((uint32_t *)ptr - sizeof(BlockHeader) / sizeof(uint32_t));\n    BlockHeader *current = freeList;\n    BlockHeader *previous = NULL;\n\n    while (current &amp;&amp; current &lt; block)\n    {\n        previous = current;\n        current = current-&gt;next;\n    }\n\n    if (previous)\n    {\n        previous-&gt;next = block;\n    }\n    else\n    {\n        freeList = block;\n    }\n    block-&gt;next = current;\n\n    // Merge adjacent blocks (optional, for reducing fragmentation)\n    if ((uint32_t *)block + block-&gt;size / sizeof(uint32_t) == (uint32_t *)current)\n    {\n        block-&gt;size += current-&gt;size;\n        block-&gt;next = current-&gt;next;\n    }\n    if (previous &amp;&amp; (uint32_t *)previous + previous-&gt;size / sizeof(uint32_t) == (uint32_t *)block)\n    {\n        previous-&gt;size += block-&gt;size;\n        previous-&gt;next = block-&gt;next;\n    }\n}\n\n/**\n * @name memory_management_test\n * @brief This function is for memory management test: allocate memory for a given length, set the values, print the values, and free the memory.\n */\nint memory_management_test(void)\n{\n    int length = 10;\n\n    int *array = (int *)memory_alloc(length * sizeof(int));\n\n    if (!array)\n    {\n        return -1;\n    }\n\n    for (int i = 0; i &lt; length; i++)\n    {\n        array[i] = i;\n    }\n\n    for (int i = 0; i &lt; length; i++)\n    {\n        printf(\"array[%d] = %d\\n\", i, array[i]);\n    }\n\n    memory_free(array);\n\n    return 0;\n}\n</code></pre>"},{"location":"MAIN-CONTROL/SDRAM/sdram/#explanation","title":"EXPLANATION","text":"<p>The isdram module provides basic SDRAM memory interaction functions, but these drivers alone are not enough. We also need a memory management module to handle memory allocation and deallocation in SDRAM. The imemory module provides memory management functionality by using a linked list to manage the memory in SDRAM. This allows us to allocate, use, and free memory in SDRAM without worrying about specific addresses, greatly simplifying our development.</p>"},{"location":"MAIN-CONTROL/SETUP/setup/","title":"SETUP","text":"<p>Note</p> <p>'SETUP' serves as the first step to set up the main control system, which enables many fundamental functions to facilitate the operation of the system. This section focuses on basic setup for the main control board.</p>"},{"location":"MAIN-CONTROL/SETUP/setup/#hardware-preparation","title":"HARDWARE PREPARATION","text":"<p>To program the main control board, we need three components:</p> <ul> <li>The main control board -  the development board that embeds the MCU</li> <li>A USB-TTL adapter - to connect the main control board to the computer</li> <li>A DEBUGGER (ST-LINK V2, J-LINK, etc.) - to program the main control board</li> </ul>"},{"location":"MAIN-CONTROL/SETUP/setup/#component-1-the-main-control-board-fanke743","title":"COMPONENT 1 - The Main Control Board - FANKE743","text":"<ul> <li> <p> product link</p> <p>Product link</p> <p>  Purchase Link </p> </li> </ul>"},{"location":"MAIN-CONTROL/SETUP/setup/#component-2-usb-ttl-adapter","title":"COMPONENT 2 - USB-TTL Adapter","text":"<ul> <li> <p> product link</p> <p>Product link</p> <p>  Purchase Link </p> </li> </ul>"},{"location":"MAIN-CONTROL/SETUP/setup/#component-3-debugger","title":"COMPONENT 3 - Debugger","text":"<ul> <li> <p> product link</p> <p>Product link</p> <p>  Purchase Link </p> </li> </ul> <p>Info</p> <p>CMSIS-DAP, ST-LINK, and J-LINK are the most commonly used debuggers. Any of these debuggers can be used to program the main control board.</p>"},{"location":"MAIN-CONTROL/SETUP/setup/#hardware-connection","title":"HARDWARE CONNECTION","text":"<p>Connect the three components as shown in the figure above. Then connect the USB-TTL adapter and the debugger to the computer.</p>"},{"location":"MAIN-CONTROL/SETUP/setup/#software-preparation","title":"SOFTWARE PREPARATION","text":""},{"location":"MAIN-CONTROL/SETUP/setup/#stm32cubemx","title":"STM32CUBEMX","text":"<p>STM32CUBEMX is a graphical tool that allows configuring the STM32 microcontroller very easily and generating the corresponding initialization C code through a step-by-step process. Download and install STM32CubeMX from the official website.</p>"},{"location":"MAIN-CONTROL/SETUP/setup/#keil-mdk","title":"KEIL MDK","text":"<p>KEIL MDK is a complete software development environment for a wide range of ARM Cortex-M based microcontroller devices. Download and install KEIL MDK from the official website.</p>"},{"location":"MAIN-CONTROL/SETUP/setup/#software-setup","title":"SOFTWARE SETUP","text":""},{"location":"MAIN-CONTROL/SETUP/setup/#create-a-new-project-in-stm32cubemx","title":"CREATE A NEW PROJECT IN STM32CUBEMX","text":""},{"location":"MAIN-CONTROL/SETUP/setup/#new-project","title":"New Project","text":"<p>Open STM32CubeMX and click the 'File' tab and then click the option 'New Project'.</p>"},{"location":"MAIN-CONTROL/SETUP/setup/#select-mcu-series-and-model","title":"Select MCU Series and Model","text":"<p>Select the MCU series and the MCU model. Then click 'Start Project'.</p>"},{"location":"MAIN-CONTROL/SETUP/setup/#enable-memory-protection-unit-mpu","title":"Enable Memory Protection Unit (MPU)","text":"<p>Enable the 'Memory Protection Unit' and click 'YES'.</p>"},{"location":"MAIN-CONTROL/SETUP/setup/#configure-project-information-and-code-generation","title":"Configure Project Information and Code Generation","text":"<p>Setup the project information and code generation configuration first as shown in the above figures.Then click 'Generate Code'.</p>"},{"location":"MAIN-CONTROL/SETUP/setup/#system-configuration","title":"SYSTEM CONFIGURATION","text":"<p>Let's go back to the Pinout &amp; Configuration tab and configure the system as shown below.</p>"},{"location":"MAIN-CONTROL/SETUP/setup/#system-core-sys-timebase-source","title":"System Core - SYS: Timebase Source","text":"<p>Select the 'SYS' tab and then select the 'Timebase Source' as 'SysTick'.</p>"},{"location":"MAIN-CONTROL/SETUP/setup/#system-core-rcc-high-speed-clock-hse-low-speed-clock-lse","title":"System Core - RCC: High Speed Clock (HSE) &amp; Low Speed Clock (LSE)","text":"<p>Select the 'RCC' tab and configure the 'High Speed Clock (HSE)' and 'Low Speed Clock (LSE)' as shown in the above figure. Both of them are set to 'Crystal/Ceramic Resonator'. Generally speaking, the external crystal oscillators are more accurate than the internal RC oscillators.</p>"},{"location":"MAIN-CONTROL/SETUP/setup/#system-core-coretex_m7-enable-i-cache-d-cache-mpu","title":"System Core - CORETEX_M7: Enable I-Cache &amp; D-Cache &amp; MPU","text":"<p>Select the 'CORETEX_M7' tab and enable the 'I-Cache', 'D-Cache', and 'MPU' as shown in the above figure. Some advanced features require the I-Cache, D-Cache, and MPU to be enabled, e.g., X-CUBE-AI. </p>"},{"location":"MAIN-CONTROL/SETUP/setup/#timer-rtc-enable-rtc","title":"Timer - RTC: Enable RTC","text":"<p>Select the 'RTC' tab and enable the 'RTC' as shown in the above figure. The RTC is a real-time clock that can be used to keep track of the current time and date. Here, we enable RTC for future potential applications.</p>"},{"location":"MAIN-CONTROL/SETUP/setup/#trace-and-debug-debug-enable-serial-wire","title":"Trace and Debug - DEBUG: Enable Serial Wire","text":"<p>Select the 'DEBUG' tab and enable the 'Serial Wire' as shown in the above figure. The Serial Wire is a debug interface that allows the debugger to communicate with the MCU.</p>"},{"location":"MAIN-CONTROL/SETUP/setup/#clock-configuration","title":"Clock Configuration","text":"<p>Configure the clock as shown in the above figure. The clock configuration is crucial for the MCU to operate correctly.</p> <p>Note</p> <p>So far, we have finished the basic setup up for MCU. You can have check of all configuration again and then click 'Generate Code' to generate the initialization code for the MCU. We will continue to set up the software environment in the next section.</p> <p>Tip</p> <p>For simplicity, I did not include all the CubeMX configuration steps in this section. In stead, the configuration is divided into several sections according to the function of the configuration. In practice, one can configure all the settings in one go. </p>"},{"location":"MAIN-CONTROL/SETUP/setup/#generate-and-update-code","title":"GENERATE AND UPDATE CODE","text":"<p>Finally, let's generate the code to save the current progress and to make it ready for following programming steps. Click the 'Generate Code' button at the top right corner of the screen.</p>"},{"location":"MAIN-CONTROL/USART/usart-interactive/","title":"USART","text":"<p>USART can be used for many different purposes, and for now, only USART1 is used for serial communication.</p> <p>Alert</p> <p>This version is used for interactive version, the interruption and DMA for usart1 are not enabled. Therefore, the message input and output are in blocking mode.</p>"},{"location":"MAIN-CONTROL/USART/usart-interactive/#usart1-circuit","title":"USART1 CIRCUIT","text":"<p>As can be seen from the circuit design, the RX and TX for USART1 are PA9 and PA10, respectively. However, the default choices are not, so we need to change them manually at the pin configuration at the right hand side of the screen.</p>"},{"location":"MAIN-CONTROL/USART/usart-interactive/#usart1-configuration","title":"USART1 CONFIGURATION","text":""},{"location":"MAIN-CONTROL/USART/usart-interactive/#parameter-setup","title":"PARAMETER SETUP","text":"<p>Select 'Parameter Settings' to setup parameters for USART1. Let's keep the default settings for now.</p>"},{"location":"MAIN-CONTROL/USART/usart-interactive/#generate-and-update-code","title":"GENERATE AND UPDATE CODE","text":"<p>Finally, let's generate the code to save the current progress and to make it ready for following programming steps. Click the 'Generate Code' button at the top right corner of the screen.</p>"},{"location":"MAIN-CONTROL/USART/usart-interactive/#programming-in-keil","title":"PROGRAMMING IN KEIL","text":""},{"location":"MAIN-CONTROL/USART/usart-interactive/#incorporate-the-module-code","title":"INCORPORATE THE MODULE CODE","text":"<p>We have introduced how to transplant and incorporate the BSP code into the project, and that applies to each respective module. For transplantation:</p> <ol> <li>Copy the module codes from the BSP project to the user project.</li> <li>Add the module codes to the user project include path.</li> <li>Add the module codes to the project items.</li> <li>Include the header file of the module code in the user project.</li> <li>Call the module function in the user project.</li> </ol> <p>Tip</p> <p>Do remember to check the 'Use MicroLib' to enable the print out function in the 'Options for Target' -&gt; 'Target' -&gt; 'Code Generation' -&gt; 'Use MicroLib'.</p>"},{"location":"MAIN-CONTROL/USART/usart-interactive/#code-review-usart","title":"CODE REVIEW - USART","text":"<p>Let's review the code for the USART module. </p>"},{"location":"MAIN-CONTROL/USART/usart-interactive/#iusarth","title":"iusart.h","text":"<pre><code>/**\n * @file iusart.h\n * @author SHUAIWEN CUI (shuaiwencui AT gmail DOT com)\n * @brief This is the header file for the iusart.c file\n * @version 1.0\n * @date 2024-06-24\n * \n * @copyright Copyright (c) 2024\n * \n */\n\n#ifndef IUSART_H_\n#define IUSART_H_\n\n/**\n * ! INCLUDES\n */\n\n#include \"stm32h7xx_hal.h\" // HAL library file declaration, replace it with the corresponding file according to the actual situation\n#include &lt;string.h&gt; // Library for string processing\n#include &lt;stdarg.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;stdbool.h&gt;\n#include &lt;stdint.h&gt;\n#include &lt;stdio.h&gt;\n//#include \"iled.h\"\n// #include \"../tim/tim.h\"\n\n\n/**\n * ! MACROS\n * ! Note that TX_BUF_SIZE and RX_BUF_SIZE are the caps for the TX_BUF and RX_BUF arrays, adjust them accordingly.\n * ! Note for receiving, if you use interrupt mode, the interrupt will only be triggered when the buffer RX_BUF is full, assuming you are using the HAL_UART_RxCpltCallback function.\n */\n\n\n// #define TX_MODE 2 // Define the transmission mode: 0 - blocking mode (not recommended), 1 - interrupt mode (* recommended), and 2 - DMA mode (** recommended) !!! note that mode 2 sometimes does not work, not sure about the reason.\n// #define RX_MODE 3 // Define the reception mode: 0 - blocking mode (not recommended), 1 - interrupt mode (recommended), and 2 - DMA mode (recommended); 3 - DMA IDLE mode (recommended) (only when IDLE_MODE is enabled)\n\n// //IDLE mode means non fixed length of data, the data is received until the idle line is detected\n// #if RX_MODE &gt;= 3\n// #define IDLE_MODE \n// #endif\n\n// #define TX_BUF_SIZE 512 // Define the size of the sending buffer\n// #define RX_BUF_SIZE 128 // Define the size of the receiving buffer. \n// #define RX_IDLE_BUF_SIZE 512 // Define the size of the idle receiving buffer (IDEL Mode)\n\n/**\n * ! VARIABLES\n * \n */\nextern UART_HandleTypeDef huart1;// Declare the HAL library structure of USART1\nextern DMA_HandleTypeDef hdma_usart1_rx; // Declare the HAL library structure of DMA for USART1\n// extern char RX_BUF[RX_BUF_SIZE]; // Define the receiving buffer\n// extern char RX_IDLE_BUF[RX_IDLE_BUF_SIZE];\n\n\n/**\n * ! FUNCTION PROTOTYPES\n * \n */\n\n// void MCU_serial_init(void);\n// void MCU_send(uint8_t *pData, uint16_t size); // lower level function wrapped by MCU_printf\n// void MCU_printf(const char *format, ...);\n\n// #ifndef IDLE_MODE\n// void HAL_UART_RxCpltCallback(UART_HandleTypeDef  *huart); \n// #else\n// void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t size);\n// #endif\n\n\n#endif /* IUSART_H_ */\n</code></pre>"},{"location":"MAIN-CONTROL/USART/usart-interactive/#iusartc","title":"iusart.c","text":"<pre><code>/**\n * @file iusart.c\n * @author SHUAIWEN CUI (shuaiwencui@gmail.com)\n * @brief This is the source file for the iusart.c file\n * @version 1.0\n * @date 2024-06-24\n *\n * @copyright Copyright (c) 2024\n *\n */\n\n// #include \"iusart.h\"\n\n// /**\n//  * @name test part\n//  *\n//  */\n\n// char RX_BUF[RX_BUF_SIZE];           // Define the receiving buffer\n// char RX_IDLE_BUF[RX_IDLE_BUF_SIZE]; // Define the idle receiving buffer (IDEL Mode)\n\n// /**\n//  * @name MCU_serial_init\n//  * @brief This function is used to initialize the USART1, and the reception method is according to the reception mode RX_MODE defined in the iusart.h file. The normal mode is the blocking mode, not recommended as it will block the main loop and causes waste of CPU resources; the interrupt mode is recommended; and the DMA mode is the most recommended.\n//  *\n//  */\n// void MCU_serial_init(void)\n// {\n//     // Note the last element in the buffer can be \"\\n\", as every time you send message from PC, a \"\\n\" is appended to the end of your message.\n\n//     if (RX_MODE == 0)\n//     {\n//         HAL_UART_Receive(&amp;huart1, (uint8_t *)&amp;RX_BUF, RX_BUF_SIZE, HAL_MAX_DELAY); // Initial receive\n//         // memset(RX_BUF, 0, sizeof(RX_BUF));\n//     }\n//     else if (RX_MODE == 1)\n//     {\n//         HAL_UART_Receive_IT(&amp;huart1, (uint8_t *)&amp;RX_BUF, RX_BUF_SIZE); // Enable receive interrupt\n//         // memset(RX_BUF, 0, sizeof(RX_BUF));\n//     }\n//     else if (RX_MODE == 2)\n//     {\n//         HAL_UART_Receive_DMA(&amp;huart1, (uint8_t *)&amp;RX_BUF, RX_BUF_SIZE); // Enable receive interrupt\n//         // memset(RX_BUF, 0, sizeof(RX_BUF));\n//     }\n//     else if (RX_MODE == 3)\n//     {\n//         // Enable the idle mode DMA reception\n//         HAL_UARTEx_ReceiveToIdle_DMA(&amp;huart1, (uint8_t *)&amp;RX_IDLE_BUF, sizeof(RX_IDLE_BUF)); // Enable receive interrupt\n//         // memset(RX_IDLE_BUF, 0, sizeof(RX_IDLE_BUF));\n//         // __HAL_DMA_DISABLE_IT(&amp;hdma_usart1_rx, DMA_IT_HT); // Disable the half-transfer interrupt\n//     }\n// }\n\n// /**\n//  * @name MCU_Send\n//  * @brief This function is used to send data through the USART1, and the transmission method is according to the transmission mode TX_MODE defined in the iusart.h file\n//  * @param pData: The pointer to the data to be sent\n//  * @param size: The size of the data to be sent\n//  * @retval None\n//  *\n//  */\n// void MCU_send(uint8_t *pData, uint16_t size)\n// {\n//     if (TX_MODE == 0) // blocking mode - not recommended\n//     {\n//         HAL_UART_Transmit(&amp;huart1, pData, size, HAL_MAX_DELAY);\n//     }\n//     else if (TX_MODE == 1) // interrupt mode - recommended\n//     {\n//         HAL_UART_Transmit_IT(&amp;huart1, pData, size);\n//     }\n//     else if (TX_MODE == 2) // DMA mode - recommended\n//     {\n//         HAL_UART_Transmit_DMA(&amp;huart1, pData, size);\n//     }\n// }\n\n// /**\n//  * @name MCU_printf\n//  * @brief This function is used to send formatted data through the USART1, and the transmission method is according to the transmission mode TX_MODE defined in the iusart.h file\n//  * @param format: The pointer to the formatted string to be sent\n//  * @param ...: The arguments to be formatted\n//  * @retval None\n//  *\n//  */\n// void MCU_printf(const char *format, ...)\n// {\n//     char TX_BUF[TX_BUF_SIZE]; // Define the sending buffer\n//     va_list args;\n//     va_start(args, format);\n//     vsnprintf(TX_BUF, TX_BUF_SIZE, format, args);\n//     va_end(args);\n//     MCU_send((uint8_t *)TX_BUF, strlen(TX_BUF));\n// }\n\n// #ifndef IDLE_MODE\n// /**\n//  * @name HAL_UART_RxCpltCallback\n//  * @brief This function is the callback function for the USART1 receive interrupt, and the received data is stored in the RX_BUF array\n//  *\n//  */\n\n// void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) // Serial port interrupt callback function\n// {\n//     if (huart == &amp;huart1) // Determine the source of the interrupt (serial port 1: USB to serial port)\n//     {\n//         if (RX_MODE == 1)\n//         {\n//             MCU_send((uint8_t *)RX_BUF, strlen(RX_BUF));\n//             HAL_UART_Receive_IT(&amp;huart1, (uint8_t *)&amp;RX_BUF, RX_BUF_SIZE); // Enable receive interrupt\n//         }\n//         else if (RX_MODE == 2)\n//         {\n//             MCU_send((uint8_t *)RX_BUF, strlen(RX_BUF));\n//             HAL_UART_Receive_DMA(&amp;huart1, (uint8_t *)&amp;RX_BUF, RX_BUF_SIZE); // Enable receive interrupt\n//         }\n//     }\n// }\n\n// #else\n\n// /**\n//  * @name HAL_UARTEx_RxEventCallback\n//  * @brief This function is the callback function for the USART1 receive idle interrupt, and the received data is stored in the RX_BUF array\n//  * ! Note: this function has higher priority than HAL_UART_RxCpltCallback, if this function is defined, HAL_UART_RxCpltCallback will not be called\n//  *\n//  */\n// void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t size)\n// {\n//     if (huart == &amp;huart1) // Determine the source of the interrupt (serial port 1: USB to serial port)\n//     {\n//         if (RX_MODE == 3)\n//         {\n//             MCU_send((uint8_t *)RX_IDLE_BUF, size);                                              //! the size here is provided by the passed parameter size\n//             HAL_UARTEx_ReceiveToIdle_DMA(&amp;huart1, (uint8_t *)&amp;RX_IDLE_BUF, sizeof(RX_IDLE_BUF)); // Enable receive interrupt\n//             // __HAL_DMA_DISABLE_IT(&amp;hdma_usart1_rx, DMA_IT_HT);                                    // Disable the half-transfer interrupt\n//             //    memset(RX_IDLE_BUF, 0, sizeof(RX_IDLE_BUF));\n//         }\n//     }\n// }\n// #endif\n</code></pre>"},{"location":"MAIN-CONTROL/USART/usart/","title":"USART","text":"<p>USART can be used for many different purposes, and for now, only USART1 is used for serial communication.</p> <p>Alert</p> <p>This version is used for non-interactive version, as interruption and DMA features are enabled, kind of difficult to do interactive menu. For interactive version, please refer to the 'interactive' version.</p>"},{"location":"MAIN-CONTROL/USART/usart/#usart1-circuit","title":"USART1 CIRCUIT","text":"<p>As can be seen from the circuit design, the RX and TX for USART1 are PA9 and PA10, respectively. However, the default choices are not, so we need to change them manually at the pin configuration at the right hand side of the screen.</p>"},{"location":"MAIN-CONTROL/USART/usart/#usart1-configuration","title":"USART1 CONFIGURATION","text":""},{"location":"MAIN-CONTROL/USART/usart/#parameter-setup","title":"PARAMETER SETUP","text":"<p>Select 'Parameter Settings' to setup parameters for USART1. Let's keep the default settings for now.</p>"},{"location":"MAIN-CONTROL/USART/usart/#dma-setup","title":"DMA SETUP","text":"<p>Info</p> <p>DMA stands for Direct Memory Access. It is a feature that allows peripherals to access memory without involving the CPU. This can greatly reduce the CPU load and improve the system performance.</p> <p></p> <p>Let's create two DMA channels for USART1. One for transmitting data and the other for receiving data.</p>"},{"location":"MAIN-CONTROL/USART/usart/#nvic-setup","title":"NVIC SETUP","text":"<p>Info</p> <p>NVIC stands for Nested Vectored Interrupt Controller. It is a feature that allows the MCU to prioritize interrupts and manage them efficiently.</p> <p></p> <p>Here, let's enable the USART1 global interrupt. Note that for DMA, the interrupts are by default enabled once you enable the DMA channels.</p>"},{"location":"MAIN-CONTROL/USART/usart/#generate-and-update-code","title":"GENERATE AND UPDATE CODE","text":"<p>Finally, let's generate the code to save the current progress and to make it ready for following programming steps. Click the 'Generate Code' button at the top right corner of the screen.</p>"},{"location":"MAIN-CONTROL/USART/usart/#programming-in-keil","title":"PROGRAMMING IN KEIL","text":""},{"location":"MAIN-CONTROL/USART/usart/#incorporate-the-module-code","title":"INCORPORATE THE MODULE CODE","text":"<p>We have introduced how to transplant and incorporate the BSP code into the project, and that applies to each respective module. For transplantation:</p> <ol> <li>Copy the module codes from the BSP project to the user project.</li> <li>Add the module codes to the user project include path.</li> <li>Add the module codes to the project items.</li> <li>Include the header file of the module code in the user project.</li> <li>Call the module function in the user project.</li> </ol> <p>Tip</p> <p>Do remember to check the 'Use MicroLib' to enable the print out function in the 'Options for Target' -&gt; 'Target' -&gt; 'Code Generation' -&gt; 'Use MicroLib'.</p>"},{"location":"MAIN-CONTROL/USART/usart/#code-review-usart","title":"CODE REVIEW - USART","text":"<p>Let's review the code for the USART module. </p>"},{"location":"MAIN-CONTROL/USART/usart/#iusarth","title":"iusart.h","text":"<pre><code>/**\n * @file iusart.h\n * @author SHUAIWEN CUI (shuaiwencui AT gmail DOT com)\n * @brief This is the header file for the iusart.c file\n * @version 1.0\n * @date 2024-06-24\n * \n * @copyright Copyright (c) 2024\n * \n */\n\n#ifndef IUSART_H_\n#define IUSART_H_\n\n/**\n * ! INCLUDES\n */\n\n#include \"stm32h7xx_hal.h\" // HAL library file declaration, replace it with the corresponding file according to the actual situation\n#include &lt;string.h&gt; // Library for string processing\n#include &lt;stdarg.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;stdbool.h&gt;\n#include &lt;stdint.h&gt;\n#include &lt;stdio.h&gt;\n//#include \"iled.h\"\n// #include \"../tim/tim.h\"\n\n\n/**\n * ! MACROS\n * ! Note that TX_BUF_SIZE and RX_BUF_SIZE are the caps for the TX_BUF and RX_BUF arrays, adjust them accordingly.\n * ! Note for receiving, if you use interrupt mode, the interrupt will only be triggered when the buffer RX_BUF is full, assuming you are using the HAL_UART_RxCpltCallback function.\n */\n\n\n#define TX_MODE 2 // Define the transmission mode: 0 - blocking mode (not recommended), 1 - interrupt mode (* recommended), and 2 - DMA mode (** recommended) !!! note that mode 2 sometimes does not work, not sure about the reason.\n#define RX_MODE 3 // Define the reception mode: 0 - blocking mode (not recommended), 1 - interrupt mode (recommended), and 2 - DMA mode (recommended); 3 - DMA IDLE mode (recommended) (only when IDLE_MODE is enabled)\n\n//IDLE mode means non fixed length of data, the data is received until the idle line is detected\n#if RX_MODE &gt;= 3\n#define IDLE_MODE \n#endif\n\n#define TX_BUF_SIZE 512 // Define the size of the sending buffer\n#define RX_BUF_SIZE 128 // Define the size of the receiving buffer. \n#define RX_IDLE_BUF_SIZE 512 // Define the size of the idle receiving buffer (IDEL Mode)\n\n/**\n * ! VARIABLES\n * \n */\nextern UART_HandleTypeDef huart1;// Declare the HAL library structure of USART1\nextern DMA_HandleTypeDef hdma_usart1_rx; // Declare the HAL library structure of DMA for USART1\nextern char RX_BUF[RX_BUF_SIZE]; // Define the receiving buffer\nextern char RX_IDLE_BUF[RX_IDLE_BUF_SIZE];\n\n\n/**\n * ! FUNCTION PROTOTYPES\n * \n */\n\nvoid MCU_serial_init(void);\nvoid MCU_send(uint8_t *pData, uint16_t size); // lower level function wrapped by MCU_printf\nvoid MCU_printf(const char *format, ...);\n\n#ifndef IDLE_MODE\nvoid HAL_UART_RxCpltCallback(UART_HandleTypeDef  *huart); \n#else\nvoid HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t size);\n#endif\n\n\n#endif /* IUSART_H_ */\n</code></pre>"},{"location":"MAIN-CONTROL/USART/usart/#iusartc","title":"iusart.c","text":"<pre><code>/**\n * @file iusart.c\n * @author SHUAIWEN CUI (shuaiwencui@gmail.com)\n * @brief This is the source file for the iusart.c file\n * @version 1.0\n * @date 2024-06-24\n *\n * @copyright Copyright (c) 2024\n *\n */\n\n#include \"iusart.h\"\n\n/**\n * @name test part\n *\n */\n\nchar RX_BUF[RX_BUF_SIZE];           // Define the receiving buffer\nchar RX_IDLE_BUF[RX_IDLE_BUF_SIZE]; // Define the idle receiving buffer (IDEL Mode)\n\n/**\n * @name MCU_serial_init\n * @brief This function is used to initialize the USART1, and the reception method is according to the reception mode RX_MODE defined in the iusart.h file. The normal mode is the blocking mode, not recommended as it will block the main loop and causes waste of CPU resources; the interrupt mode is recommended; and the DMA mode is the most recommended.\n *\n */\nvoid MCU_serial_init(void)\n{\n    // Note the last element in the buffer can be \"\\n\", as every time you send message from PC, a \"\\n\" is appended to the end of your message.\n\n    if (RX_MODE == 0)\n    {\n        HAL_UART_Receive(&amp;huart1, (uint8_t *)&amp;RX_BUF, RX_BUF_SIZE, HAL_MAX_DELAY); // Initial receive\n        // memset(RX_BUF, 0, sizeof(RX_BUF));\n    }\n    else if (RX_MODE == 1)\n    {\n        HAL_UART_Receive_IT(&amp;huart1, (uint8_t *)&amp;RX_BUF, RX_BUF_SIZE); // Enable receive interrupt\n        // memset(RX_BUF, 0, sizeof(RX_BUF));\n    }\n    else if (RX_MODE == 2)\n    {\n        HAL_UART_Receive_DMA(&amp;huart1, (uint8_t *)&amp;RX_BUF, RX_BUF_SIZE); // Enable receive interrupt\n        // memset(RX_BUF, 0, sizeof(RX_BUF));\n    }\n    else if (RX_MODE == 3)\n    {\n        // Enable the idle mode DMA reception\n        HAL_UARTEx_ReceiveToIdle_DMA(&amp;huart1, (uint8_t *)&amp;RX_IDLE_BUF, sizeof(RX_IDLE_BUF)); // Enable receive interrupt\n        // memset(RX_IDLE_BUF, 0, sizeof(RX_IDLE_BUF));\n        // __HAL_DMA_DISABLE_IT(&amp;hdma_usart1_rx, DMA_IT_HT); // Disable the half-transfer interrupt\n    }\n}\n\n/**\n * @name MCU_Send\n * @brief This function is used to send data through the USART1, and the transmission method is according to the transmission mode TX_MODE defined in the iusart.h file\n * @param pData: The pointer to the data to be sent\n * @param size: The size of the data to be sent\n * @retval None\n *\n */\nvoid MCU_send(uint8_t *pData, uint16_t size)\n{\n    if (TX_MODE == 0) // blocking mode - not recommended\n    {\n        HAL_UART_Transmit(&amp;huart1, pData, size, HAL_MAX_DELAY);\n    }\n    else if (TX_MODE == 1) // interrupt mode - recommended\n    {\n        HAL_UART_Transmit_IT(&amp;huart1, pData, size);\n    }\n    else if (TX_MODE == 2) // DMA mode - recommended\n    {\n        HAL_UART_Transmit_DMA(&amp;huart1, pData, size);\n    }\n}\n\n/**\n * @name MCU_printf\n * @brief This function is used to send formatted data through the USART1, and the transmission method is according to the transmission mode TX_MODE defined in the iusart.h file\n * @param format: The pointer to the formatted string to be sent\n * @param ...: The arguments to be formatted\n * @retval None\n *\n */\nvoid MCU_printf(const char *format, ...)\n{\n    char TX_BUF[TX_BUF_SIZE]; // Define the sending buffer\n    va_list args;\n    va_start(args, format);\n    vsnprintf(TX_BUF, TX_BUF_SIZE, format, args);\n    va_end(args);\n    MCU_send((uint8_t *)TX_BUF, strlen(TX_BUF));\n}\n\n#ifndef IDLE_MODE\n/**\n * @name HAL_UART_RxCpltCallback\n * @brief This function is the callback function for the USART1 receive interrupt, and the received data is stored in the RX_BUF array\n *\n */\n\nvoid HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) // Serial port interrupt callback function\n{\n    if (huart == &amp;huart1) // Determine the source of the interrupt (serial port 1: USB to serial port)\n    {\n        if (RX_MODE == 1)\n        {\n            MCU_send((uint8_t *)RX_BUF, strlen(RX_BUF));\n            HAL_UART_Receive_IT(&amp;huart1, (uint8_t *)&amp;RX_BUF, RX_BUF_SIZE); // Enable receive interrupt\n        }\n        else if (RX_MODE == 2)\n        {\n            MCU_send((uint8_t *)RX_BUF, strlen(RX_BUF));\n            HAL_UART_Receive_DMA(&amp;huart1, (uint8_t *)&amp;RX_BUF, RX_BUF_SIZE); // Enable receive interrupt\n        }\n    }\n}\n\n#else\n\n/**\n * @name HAL_UARTEx_RxEventCallback\n * @brief This function is the callback function for the USART1 receive idle interrupt, and the received data is stored in the RX_BUF array\n * ! Note: this function has higher priority than HAL_UART_RxCpltCallback, if this function is defined, HAL_UART_RxCpltCallback will not be called\n *\n */\nvoid HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t size)\n{\n    if (huart == &amp;huart1) // Determine the source of the interrupt (serial port 1: USB to serial port)\n    {\n        if (RX_MODE == 3)\n        {\n            MCU_send((uint8_t *)RX_IDLE_BUF, size);                                              //! the size here is provided by the passed parameter size\n            HAL_UARTEx_ReceiveToIdle_DMA(&amp;huart1, (uint8_t *)&amp;RX_IDLE_BUF, sizeof(RX_IDLE_BUF)); // Enable receive interrupt\n            // __HAL_DMA_DISABLE_IT(&amp;hdma_usart1_rx, DMA_IT_HT);                                    // Disable the half-transfer interrupt\n            //    memset(RX_IDLE_BUF, 0, sizeof(RX_IDLE_BUF));\n        }\n    }\n}\n#endif\n</code></pre>"},{"location":"MAIN-CONTROL/USART/usart/#explanation-of-the-code","title":"EXPLANATION OF THE CODE","text":"<p>Tip</p> <p>Sometimes the 'MCU_printf' is not working well, but 'printf' works well. So, we can use 'printf' instead of 'MCU_printf'.</p>"},{"location":"PERCEPTION/perception/","title":"PERCEPTION","text":"<p>Please refer to the respective subsections for more information.</p>"},{"location":"PERCEPTION/ADXL355/adxl355/","title":"ADXL355 Accelerometer","text":""},{"location":"PERCEPTION/ADXL355/adxl355/#introduction-to-adxl355","title":"INTRODUCTION TO ADXL355","text":"<p>The ADXL355 is a high-precision, low-noise, three-axis MEMS accelerometer from Analog Devices. It is designed for applications requiring high accuracy and low noise, such as seismic monitoring, tilt sensing, and vibration analysis. The ADXL355 offers excellent stability with low drift over time and temperature, making it suitable for long-term monitoring applications.</p> <p>This accelerometer has a selectable measurement range of \u00b12g, \u00b14g, or \u00b18g and provides 20-bit output resolution. It features a low noise density of 25 \u00b5g/\u221aHz and operates with very low power consumption, typically around 200 \u00b5A in measurement mode. The ADXL355 communicates via an SPI or I\u00b2C interface and includes features like a digital temperature sensor, FIFO buffer, and configurable bandwidth. Its robust design ensures reliability in harsh environments, making it ideal for industrial and scientific applications.</p> <p> </p> <ul> <li> <p> product link on Taobao</p> <p>Product link on Taobao</p> <p>  Purchase Link </p> </li> </ul>"},{"location":"PERCEPTION/ADXL355/adxl355/#key-parameters","title":"KEY PARAMETERS","text":"Parameter Value Operating Current 200 \u00b5A (measurement mode) Measurement Range \u00b12g, \u00b14g, \u00b18g Resolution 20-bit Noise Density 25 \u00b5g/\u221aHz Communication SPI, I\u00b2C Supply Voltage 2.0V to 3.6V Built-in Features Digital Temperature Sensor, FIFO Buffer"},{"location":"PERCEPTION/ADXL355/adxl355/#dev-reference","title":"DEV REFERENCE","text":"<ul> <li> <p> SPI</p> <p>  Portal </p> </li> </ul>"},{"location":"PERCEPTION/ADXL362/adxl362/","title":"ADXL362 Accelerometer","text":""},{"location":"PERCEPTION/ADXL362/adxl362/#introduction-to-adxl362","title":"INTRODUCTION TO ADXL362","text":"<p>The ADXL362 is an ultra-low-power, three-axis digital accelerometer from Analog Devices. It is designed for applications requiring minimal power consumption, such as wearable devices, portable electronics, and wireless sensor networks. The ADXL362 operates on as little as 1.8 \u00b5A in measurement mode and 270 nA in standby mode, making it highly energy-efficient.</p> <p>The sensor offers a wide measurement range from \u00b12g to \u00b18g and provides high-resolution output with a 12-bit digital resolution. It communicates via a SPI interface, and includes features like a programmable activity/inactivity sensing, wake-up, and a built-in temperature sensor. The ADXL362 is also known for its noise performance, ensuring accurate and reliable motion detection in low-power applications.</p> <p> </p> <ul> <li> <p> product link on Taobao</p> <p>Product link on Taobao</p> <p>  Purchase Link </p> </li> </ul>"},{"location":"PERCEPTION/ADXL362/adxl362/#key-parameters","title":"KEY PARAMETERS","text":"Parameter Value Operating Current 1.8 \u00b5A (measurement mode) Standby Current 270 nA Measurement Range \u00b12g, \u00b14g, \u00b18g Resolution 12-bit Communication SPI Supply Voltage 1.6V to 3.5V Noise Performance 550 \u00b5g/\u221aHz (typical) Built-in Features Activity/Inactivity Detection, Temperature Sensor"},{"location":"PERCEPTION/ADXL362/adxl362/#dev-reference","title":"DEV REFERENCE","text":"<ul> <li> <p> STM32 ADXL362</p> <p>  Portal </p> </li> </ul>"},{"location":"PERCEPTION/ADXL362/adxl362/#dev-procedures","title":"DEV PROCEDURES","text":""},{"location":"POWER/power/","title":"POWER","text":"<p>Under primitive development, we use USB cable to power the MCU. In future, battery power will be used and power management will be implemented.</p>"},{"location":"RELEASES/releases/","title":"RELEASES","text":"<p>To faciliate different use cases, this project provides various releases. The following table lists the available releases and their respective features.</p> Release (Folder Name) Description Features Status Notes NODE-CORE-BUILDING This release focuses on the computational core development, showing the development progress of the core components. Computaitonal Core Development - Progress View \u2705 Ready Theoretically equivalent to NODE-CORE-BUILT, but not fully tested. NODE-CORE-BUILT This release focuses on the computational core development, showing the developed computational core. Computaitonal Core Development - Built View \u2705 Stable \ud83c\udfc6 Recommended NODE-CORE-INTERACTION-BUILT This release focuses on the computational core development, showing the developed computational core. Compared to the non-interactive version, this version removes the interrupt and DMA functions of the serial port, only retains the basic serial port input and output, and supports user input (single character) for interactive menu functions. Computaitonal Core Development - Interaction View \u2705 Stable \ud83c\udfc6 Recommended"},{"location":"blog/","title":"Blog","text":""},{"location":"zh/","title":"STM32\u5fae\u63a7\u5236\u5668\u8fb9\u7f18\u667a\u80fd\u8282\u70b9","text":"<p>\u8fd9\u4e2a\u9879\u76ee\u81f4\u529b\u4e8e\u57fa\u4e8eSTM32\u7684\u5fae\u63a7\u5236\u5668\u8fb9\u7f18\u667a\u80fd\u8282\u70b9\u7684\u5f00\u53d1\u3002\u5982\u679c\u4f60\u5bf9\u8fd9\u4e2a\u9879\u76ee\u611f\u5174\u8da3\uff0c\u8bf7\u7ed9\u4e2a\u661f\u5e76\u4fdd\u6301\u5173\u6ce8\u3002</p> <p></p>"},{"location":"zh/ABOUT/about/","title":"STM32\u5fae\u63a7\u5236\u5668\u8fb9\u7f18\u667a\u80fd\u8282\u70b9","text":"<p>\u8fd9\u4e2a\u9879\u76ee\u81f4\u529b\u4e8e\u57fa\u4e8eSTM32\u7684\u5fae\u63a7\u5236\u5668\u8fb9\u7f18\u667a\u80fd\u8282\u70b9\u7684\u5f00\u53d1\u3002\u5982\u679c\u4f60\u5bf9\u8fd9\u4e2a\u9879\u76ee\u611f\u5174\u8da3\uff0c\u8bf7\u7ed9\u4e2a\u661f\u5e76\u4fdd\u6301\u5173\u6ce8\u3002</p> <p></p>"},{"location":"zh/ARCHITECTURE/architecture/","title":"\u67b6\u6784","text":""},{"location":"zh/ARCHITECTURE/architecture/#_2","title":"\u786c\u4ef6\u67b6\u6784","text":"<p>\u4e3b\u63a7 + \u611f\u77e5 + \u901a\u4fe1 + \u4ea4\u4e92</p>"},{"location":"zh/ARCHITECTURE/architecture/#_3","title":"\u8f6f\u4ef6\u67b6\u6784","text":"<p>\u7269\u7406\u5c42 -&gt; \u9a71\u52a8\u5c42 -&gt; \u4e2d\u95f4\u4ef6\u5c42 -&gt; \u5e94\u7528\u5c42 </p>"},{"location":"zh/ARCHITECTURE/architecture/#_4","title":"\u5f00\u53d1\u5de5\u5177\u94fe","text":"<p>\u521d\u59cb\u5316\uff1a STM32CUBEMX</p> <p>\u4ee3\u7801\u7f16\u8f91\uff1a KEIL5/VSCODE</p>"},{"location":"zh/COMMUNICATION/communication/","title":"\u901a\u4fe1","text":""},{"location":"zh/COMPUTATION/computation/","title":"\u8ba1\u7b97","text":"<p>\u672c\u8282\u81f4\u529b\u4e8e\u5982\u4f55\u5728MCU\u4e0a\u8fdb\u884c\u8ba1\u7b97\u4e0e\u677f\u8f7d\u667a\u80fd\u5b9e\u73b0\u3002</p>"},{"location":"zh/COMPUTATION/CMSIS-DSP/cmsis-dsp/","title":"CMSIS-DSP \u6570\u5b57\u4fe1\u53f7\u5904\u7406\u5e93","text":""},{"location":"zh/COMPUTATION/CMSIS-DSP/cmsis-dsp/#_1","title":"\u51c6\u5907\u5de5\u4f5c","text":"<p>\u7531\u4e8e\u6211\u4eec\u7684\u9879\u76ee\u662f\u901a\u8fc7STM32CubeMX\u751f\u6210\u7684\uff0c\u6240\u4ee5CMSIS-DSP\u5e93\u5df2\u7ecf\u5305\u542b\u5728\u9879\u76ee\u4e2d\u3002\u5982\u679c\u4f60\u6ca1\u6709\u4f7f\u7528STM32CubeMX\uff0c\u4f60\u53ef\u4ee5\u4eceARM\u7684\u5b98\u65b9\u7f51\u7ad9\u4e0b\u8f7d\u8be5\u5e93\u3002</p>"},{"location":"zh/COMPUTATION/CMSIS-DSP/cmsis-dsp/#_2","title":"\u96c6\u6210\u5e93","text":"<p>\u8be5\u5e93\u6709\u4e24\u79cd\u5f62\u5f0f\uff1a\u6e90\u7801\u548c\u5df2\u7f16\u8bd1\u5e93\u3002\u4f60\u53ef\u4ee5\u6839\u636e\u81ea\u5df1\u7684\u559c\u597d\u9009\u62e9\u5176\u4e2d\u4e00\u79cd\u3002\u8fd9\u91cc\u6211\u4eec\u4e3a\u4e86\u7b80\u4fbf\uff0c\u4f7f\u7528\u5df2\u7f16\u8bd1\u7684\u5e93\u3002</p> <p>\u5728Keil\u4e2d\uff0c\u6253\u5f00\u201cManage Project Items\u201d\uff0c\u6dfb\u52a0\u4e00\u4e2a\u81ea\u5b9a\u4e49\u540d\u79f0\u7684\u5206\u652f\uff0c\u7136\u540e\u70b9\u51fb\u201cAdd file\u201d\u5e76\u5bfc\u822a\u5230\u5e93\u6587\u4ef6\u5939\u3002\u9009\u62e9\u5e93\u6587\u4ef6\u5e76\u70b9\u51fb\u201cAdd\u201d\u3002\uff08\u53c2\u89c1\u4e0b\u56fe\uff09</p> <p></p>"},{"location":"zh/COMPUTATION/CMSIS-DSP/cmsis-dsp/#_3","title":"\u5305\u542b\u5934\u6587\u4ef6","text":"<p>\u4e0e\u4e0a\u8ff0\u6b65\u9aa4\u7c7b\u4f3c\uff0c\u5934\u6587\u4ef6\u4f4d\u4e8e\u201cInclude\u201d\u6587\u4ef6\u5939\u4e2d\u3002\u5c06\u8be5\u6587\u4ef6\u5939\u6dfb\u52a0\u5230\u9879\u76ee\u4e2d\uff0c\u5e76\u5728\u6e90\u4ee3\u7801\u4e2d\u5305\u542b\u5934\u6587\u4ef6\u3002</p>"},{"location":"zh/COMPUTATION/CMSIS-DSP/cmsis-dsp/#_4","title":"\u66f4\u65b0\u5305\u542b\u8def\u5f84","text":"<p>\u6253\u5f00\u201cOptions for Target\u201d\uff0c\u5e76\u5728\u201cC/C++\u201d\u9009\u9879\u5361\u4e2d\u7684\u201cInclude Paths\u201d\u4e2d\u6dfb\u52a0\u201cInclude\u201d\u6587\u4ef6\u5939\u7684\u8def\u5f84\u3002</p>"},{"location":"zh/COMPUTATION/CMSIS-DSP/cmsis-dsp/#_5","title":"\u7ed3\u675f","text":"<p>\u73b0\u5728\uff0cCMSIS-DSP\u5e93\u5df2\u7ecf\u6210\u529f\u96c6\u6210\u5230\u9879\u76ee\u4e2d\u3002\u4f60\u53ef\u4ee5\u5728\u9879\u76ee\u4e2d\u4f7f\u7528\u8be5\u5e93\u63d0\u4f9b\u7684\u51fd\u6570\u3002</p>"},{"location":"zh/COMPUTATION/CMSIS-DSP-LIB/cmsis-dsp-lib/","title":"CMSIS-DSP \u6570\u5b57\u4fe1\u53f7\u5904\u7406\u5e93","text":""},{"location":"zh/COMPUTATION/CMSIS-DSP-LIB/cmsis-dsp-lib/#_1","title":"\u51c6\u5907\u5de5\u4f5c","text":"<p>\u7531\u4e8e\u6211\u4eec\u7684\u9879\u76ee\u662f\u901a\u8fc7STM32CubeMX\u751f\u6210\u7684\uff0c\u6240\u4ee5CMSIS-DSP\u5e93\u5df2\u7ecf\u5305\u542b\u5728\u9879\u76ee\u4e2d\u3002\u5982\u679c\u4f60\u6ca1\u6709\u4f7f\u7528STM32CubeMX\uff0c\u4f60\u53ef\u4ee5\u4eceARM\u7684\u5b98\u65b9\u7f51\u7ad9\u4e0b\u8f7d\u8be5\u5e93\u3002</p>"},{"location":"zh/COMPUTATION/CMSIS-DSP-LIB/cmsis-dsp-lib/#_2","title":"\u96c6\u6210\u5e93","text":"<p>\u8be5\u5e93\u6709\u4e24\u79cd\u5f62\u5f0f\uff1a\u6e90\u7801\u548c\u5df2\u7f16\u8bd1\u5e93\u3002\u4f60\u53ef\u4ee5\u6839\u636e\u81ea\u5df1\u7684\u559c\u597d\u9009\u62e9\u5176\u4e2d\u4e00\u79cd\u3002\u8fd9\u91cc\u6211\u4eec\u4e3a\u4e86\u7b80\u4fbf\uff0c\u4f7f\u7528\u5df2\u7f16\u8bd1\u7684\u5e93\u3002</p> <p>\u5728Keil\u4e2d\uff0c\u6253\u5f00\u201cManage Project Items\u201d\uff0c\u6dfb\u52a0\u4e00\u4e2a\u81ea\u5b9a\u4e49\u540d\u79f0\u7684\u5206\u652f\uff0c\u7136\u540e\u70b9\u51fb\u201cAdd file\u201d\u5e76\u5bfc\u822a\u5230\u5e93\u6587\u4ef6\u5939\u3002\u9009\u62e9\u5e93\u6587\u4ef6\u5e76\u70b9\u51fb\u201cAdd\u201d\u3002\uff08\u53c2\u89c1\u4e0b\u56fe\uff09</p> <p></p>"},{"location":"zh/COMPUTATION/CMSIS-DSP-LIB/cmsis-dsp-lib/#_3","title":"\u5305\u542b\u5934\u6587\u4ef6","text":"<p>\u4e0e\u4e0a\u8ff0\u6b65\u9aa4\u7c7b\u4f3c\uff0c\u5934\u6587\u4ef6\u4f4d\u4e8e\u201cInclude\u201d\u6587\u4ef6\u5939\u4e2d\u3002\u5c06\u8be5\u6587\u4ef6\u5939\u6dfb\u52a0\u5230\u9879\u76ee\u4e2d\uff0c\u5e76\u5728\u6e90\u4ee3\u7801\u4e2d\u5305\u542b\u5934\u6587\u4ef6\u3002</p>"},{"location":"zh/COMPUTATION/CMSIS-DSP-LIB/cmsis-dsp-lib/#_4","title":"\u66f4\u65b0\u5305\u542b\u8def\u5f84","text":"<p>\u6253\u5f00\u201cOptions for Target\u201d\uff0c\u5e76\u5728\u201cC/C++\u201d\u9009\u9879\u5361\u4e2d\u7684\u201cInclude Paths\u201d\u4e2d\u6dfb\u52a0\u201cInclude\u201d\u6587\u4ef6\u5939\u7684\u8def\u5f84\u3002</p>"},{"location":"zh/COMPUTATION/CMSIS-DSP-LIB/cmsis-dsp-lib/#_5","title":"\u7ed3\u675f","text":"<p>\u73b0\u5728\uff0cCMSIS-DSP\u5e93\u5df2\u7ecf\u6210\u529f\u96c6\u6210\u5230\u9879\u76ee\u4e2d\u3002\u4f60\u53ef\u4ee5\u5728\u9879\u76ee\u4e2d\u4f7f\u7528\u8be5\u5e93\u63d0\u4f9b\u7684\u51fd\u6570\u3002</p>"},{"location":"zh/COMPUTATION/CMSIS-NN/cmsis-nn/","title":"CMSIS-NN \u795e\u7ecf\u7f51\u7edc\u5e93","text":""},{"location":"zh/COMPUTATION/CMSIS-NN/cmsis-nn/#cmsis-nn_1","title":"\u4ecb\u7ecdCMSIS-NN\u5e93\u4ee5\u7528\u4e8e\u5d4c\u5165\u5f0f\u795e\u7ecf\u7f51\u7edc","text":"<p>\u63d0\u793a</p> <p>\u4e2a\u4eba\u8ba4\u4e3a\uff0cX-CUBE-AI\u6bd4CMSIS-NN\u66f4\u6613\u4e8e\u4f7f\u7528\u3002\u4f60\u53ef\u4ee5\u7b80\u5355\u5730\u5bfc\u5165\u6a21\u578b\u5e76\u751f\u6210\u4ee3\u7801\u3002</p>"},{"location":"zh/COMPUTATION/CMSIS-NN/cmsis-nn/#_1","title":"\u51c6\u5907\u5de5\u4f5c","text":"<p>\u7531\u4e8e\u6211\u4eec\u4f7f\u7528STM32CubeMX\u751f\u6210\u9879\u76ee\uff0cCMSIS-NN\u5e93\u5df2\u7ecf\u5305\u542b\u5728\u9879\u76ee\u4e2d\u3002\u5982\u679c\u4f60\u6ca1\u6709\u4f7f\u7528STM32CubeMX\uff0c\u4f60\u53ef\u4ee5\u4eceARM\u7684\u5b98\u65b9\u7f51\u7ad9\u4e0b\u8f7d\u8be5\u5e93\u3002\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0cCUBEMX\u9644\u5e26\u7684CMSIS-NN\u5e93\u53ef\u80fd\u6bd4\u6700\u65b0\u7248\u672c\u7a0d\u6709\u6ede\u540e\u3002\u4f60\u53ef\u4ee5\u4ece\u5b98\u7f51\u4e0b\u8f7d\u6700\u65b0\u7248\u672c\uff0c\u4f46\u53ef\u80fd\u4f1a\u9047\u5230\u517c\u5bb9\u6027\u95ee\u9898\u3002</p>"},{"location":"zh/COMPUTATION/CMSIS-NN/cmsis-nn/#_2","title":"\u96c6\u6210\u6e90\u7801","text":"<p>CMSIS-NN\u6ca1\u6709\u7f16\u8bd1\u597d\u7684\u5e93\uff0c\u4f60\u9700\u8981\u5c06\u6e90\u7801\u96c6\u6210\u5230\u4f60\u7684\u9879\u76ee\u4e2d\u3002</p> <p>\u5728Keil\u4e2d\uff0c\u6253\u5f00\u201cManage Project Items\u201d\uff0c\u6dfb\u52a0\u4e00\u4e2a\u81ea\u5b9a\u4e49\u540d\u79f0\u7684\u5206\u652f\uff0c\u7136\u540e\u70b9\u51fb\u201cAdd file\u201d\u5e76\u5bfc\u822a\u5230NN\u6e90\u7801\u6587\u4ef6\u5939\u3002\u9009\u62e9\u6e90\u6587\u4ef6\u5e76\u70b9\u51fb\u201cAdd\u201d\u3002\uff08\u53c2\u89c1\u4e0b\u56fe\uff09</p> <p></p>"},{"location":"zh/COMPUTATION/CMSIS-NN/cmsis-nn/#_3","title":"\u5305\u542b\u5934\u6587\u4ef6","text":"<p>\u4e0e\u4e0a\u8ff0\u6b65\u9aa4\u7c7b\u4f3c\uff0c\u5934\u6587\u4ef6\u4f4d\u4e8e\u201cInclude\u201d\u6587\u4ef6\u5939\u4e2d\u3002\u5c06\u8be5\u6587\u4ef6\u5939\u6dfb\u52a0\u5230\u9879\u76ee\u4e2d\uff0c\u5e76\u5728\u6e90\u4ee3\u7801\u4e2d\u5305\u542b\u5934\u6587\u4ef6\u3002</p>"},{"location":"zh/COMPUTATION/CMSIS-NN/cmsis-nn/#_4","title":"\u66f4\u65b0\u5305\u542b\u8def\u5f84","text":"<p>\u6253\u5f00\u201cOptions for Target\u201d\uff0c\u5e76\u5728\u201cC/C++\u201d\u9009\u9879\u5361\u4e2d\u7684\u201cInclude Paths\u201d\u4e2d\u6dfb\u52a0\u201cInclude\u201d\u6587\u4ef6\u5939\u7684\u8def\u5f84\u3002</p> <p></p>"},{"location":"zh/COMPUTATION/CMSIS-NN/cmsis-nn/#_5","title":"\u7ed3\u675f","text":"<p>\u73b0\u5728\uff0cCMSIS-NN\u5e93\u5df2\u7ecf\u6210\u529f\u96c6\u6210\u5230\u9879\u76ee\u4e2d\u3002\u4f60\u53ef\u4ee5\u5728\u9879\u76ee\u4e2d\u4f7f\u7528\u8be5\u5e93\u63d0\u4f9b\u7684\u51fd\u6570\u3002</p>"},{"location":"zh/COMPUTATION/CMSIS-NN-LIB/cmsis-nn-lib/","title":"CMSIS-NN \u795e\u7ecf\u7f51\u7edc\u5e93","text":""},{"location":"zh/COMPUTATION/CMSIS-NN-LIB/cmsis-nn-lib/#cmsis-nn_1","title":"\u4ecb\u7ecdCMSIS-NN\u5e93\u4ee5\u7528\u4e8e\u5d4c\u5165\u5f0f\u795e\u7ecf\u7f51\u7edc","text":"<p>\u63d0\u793a</p> <p>\u4e2a\u4eba\u8ba4\u4e3a\uff0cX-CUBE-AI\u6bd4CMSIS-NN\u66f4\u6613\u4e8e\u4f7f\u7528\u3002\u4f60\u53ef\u4ee5\u7b80\u5355\u5730\u5bfc\u5165\u6a21\u578b\u5e76\u751f\u6210\u4ee3\u7801\u3002</p>"},{"location":"zh/COMPUTATION/CMSIS-NN-LIB/cmsis-nn-lib/#_1","title":"\u51c6\u5907\u5de5\u4f5c","text":"<p>\u7531\u4e8e\u6211\u4eec\u4f7f\u7528STM32CubeMX\u751f\u6210\u9879\u76ee\uff0cCMSIS-NN\u5e93\u5df2\u7ecf\u5305\u542b\u5728\u9879\u76ee\u4e2d\u3002\u5982\u679c\u4f60\u6ca1\u6709\u4f7f\u7528STM32CubeMX\uff0c\u4f60\u53ef\u4ee5\u4eceARM\u7684\u5b98\u65b9\u7f51\u7ad9\u4e0b\u8f7d\u8be5\u5e93\u3002\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0cCUBEMX\u9644\u5e26\u7684CMSIS-NN\u5e93\u53ef\u80fd\u6bd4\u6700\u65b0\u7248\u672c\u7a0d\u6709\u6ede\u540e\u3002\u4f60\u53ef\u4ee5\u4ece\u5b98\u7f51\u4e0b\u8f7d\u6700\u65b0\u7248\u672c\uff0c\u4f46\u53ef\u80fd\u4f1a\u9047\u5230\u517c\u5bb9\u6027\u95ee\u9898\u3002</p>"},{"location":"zh/COMPUTATION/CMSIS-NN-LIB/cmsis-nn-lib/#_2","title":"\u96c6\u6210\u6e90\u7801","text":"<p>CMSIS-NN\u6ca1\u6709\u7f16\u8bd1\u597d\u7684\u5e93\uff0c\u4f60\u9700\u8981\u5c06\u6e90\u7801\u96c6\u6210\u5230\u4f60\u7684\u9879\u76ee\u4e2d\u3002</p> <p>\u5728Keil\u4e2d\uff0c\u6253\u5f00\u201cManage Project Items\u201d\uff0c\u6dfb\u52a0\u4e00\u4e2a\u81ea\u5b9a\u4e49\u540d\u79f0\u7684\u5206\u652f\uff0c\u7136\u540e\u70b9\u51fb\u201cAdd file\u201d\u5e76\u5bfc\u822a\u5230NN\u6e90\u7801\u6587\u4ef6\u5939\u3002\u9009\u62e9\u6e90\u6587\u4ef6\u5e76\u70b9\u51fb\u201cAdd\u201d\u3002\uff08\u53c2\u89c1\u4e0b\u56fe\uff09</p> <p></p>"},{"location":"zh/COMPUTATION/CMSIS-NN-LIB/cmsis-nn-lib/#_3","title":"\u5305\u542b\u5934\u6587\u4ef6","text":"<p>\u4e0e\u4e0a\u8ff0\u6b65\u9aa4\u7c7b\u4f3c\uff0c\u5934\u6587\u4ef6\u4f4d\u4e8e\u201cInclude\u201d\u6587\u4ef6\u5939\u4e2d\u3002\u5c06\u8be5\u6587\u4ef6\u5939\u6dfb\u52a0\u5230\u9879\u76ee\u4e2d\uff0c\u5e76\u5728\u6e90\u4ee3\u7801\u4e2d\u5305\u542b\u5934\u6587\u4ef6\u3002</p>"},{"location":"zh/COMPUTATION/CMSIS-NN-LIB/cmsis-nn-lib/#_4","title":"\u66f4\u65b0\u5305\u542b\u8def\u5f84","text":"<p>\u6253\u5f00\u201cOptions for Target\u201d\uff0c\u5e76\u5728\u201cC/C++\u201d\u9009\u9879\u5361\u4e2d\u7684\u201cInclude Paths\u201d\u4e2d\u6dfb\u52a0\u201cInclude\u201d\u6587\u4ef6\u5939\u7684\u8def\u5f84\u3002</p> <p></p>"},{"location":"zh/COMPUTATION/CMSIS-NN-LIB/cmsis-nn-lib/#_5","title":"\u7ed3\u675f","text":"<p>\u73b0\u5728\uff0cCMSIS-NN\u5e93\u5df2\u7ecf\u6210\u529f\u96c6\u6210\u5230\u9879\u76ee\u4e2d\u3002\u4f60\u53ef\u4ee5\u5728\u9879\u76ee\u4e2d\u4f7f\u7528\u8be5\u5e93\u63d0\u4f9b\u7684\u51fd\u6570\u3002</p>"},{"location":"zh/INTERFACING/interfacing/","title":"\u4ea4\u4e92","text":"<p>\u8fd9\u4e00\u90e8\u5206\u81f4\u529b\u4e8e\u4ecb\u7ecd\u5982\u4f55\u4e0eMCU\u8fdb\u884c\u4ea4\u4e92\u3002\u5f53\u524d\uff0c\u5b83\u6db5\u76d6\u4e86\u4ee5\u4e0b\u4e3b\u9898\uff1a</p> <ul> <li>OLED\u663e\u793a\u5668</li> </ul> <p>\u8bf7\u53c2\u9605\u76f8\u5e94\u7684\u5b50\u7ae0\u8282\u4ee5\u83b7\u53d6\u66f4\u591a\u4fe1\u606f\u3002</p>"},{"location":"zh/INTERFACING/OLED/oled/#oled_1","title":"OLED\u4ecb\u7ecd","text":"<p>OLED\uff08\u6709\u673a\u53d1\u5149\u4e8c\u6781\u7ba1\uff09\u662f\u4e00\u79cd\u4f7f\u7528\u6709\u673a\u5316\u5408\u7269\u4ea7\u751f\u5149\u7684\u663e\u793a\u6280\u672f\u3002\u5b83\u662f\u4e00\u79cd\u81ea\u53d1\u5149\u663e\u793a\u5668\uff0c\u8fd9\u610f\u5473\u7740\u5b83\u4e0d\u9700\u8981\u80cc\u5149\u706f\u6765\u5de5\u4f5c\u3002OLED\u663e\u793a\u5668\u4ee5\u9ad8\u5bf9\u6bd4\u5ea6\u3001\u5e7f\u89c6\u89d2\u548c\u5feb\u54cd\u5e94\u65f6\u95f4\u800c\u95fb\u540d\u3002\u5b83\u4eec\u901a\u5e38\u7528\u4e8e\u667a\u80fd\u624b\u673a\u3001\u5e73\u677f\u7535\u8111\u548c\u5176\u4ed6\u4fbf\u643a\u8bbe\u5907\u3002</p>"},{"location":"zh/INTERFACING/OLED/oled/#oled_2","title":"OLED\u6a21\u5757","text":"<ul> <li>OLED\u63a7\u5236 - CH1116</li> <li>OLED\u5c3a\u5bf8 - 1.3\u82f1\u5bf8</li> <li>OLED\u5206\u8fa8\u7387 - 128x64</li> </ul> <ul> <li> <p> \u6dd8\u5b9d\u8d2d\u4e70\u94fe\u63a5</p> <p>\u6dd8\u5b9d\u8d2d\u4e70\u94fe\u63a5</p> <p>  \u5546\u54c1\u94fe\u63a5 </p> </li> </ul>"},{"location":"zh/INTERFACING/OLED/oled/#_1","title":"\u9a71\u52a8\u5668\u53c2\u8003","text":"<ul> <li>KEYSKING\u9a71\u52a8\u5668</li> </ul> <ul> <li> <p> \u6ce2\u7279\u5f8b\u52a8</p> <p>\u6ce2\u7279\u5f8b\u52a8</p> <p>  \u95e8\u6237 </p> </li> </ul>"},{"location":"zh/MAIN-CONTROL/main-control/","title":"\u4e3b\u63a7","text":""},{"location":"zh/MAIN-CONTROL/main-control/#_2","title":"\u4e3b\u63a7\u6982\u89c8","text":"<ul> <li> <p> \u6dd8\u5b9d\u94fe\u63a5</p> <p>\u5546\u54c1\u6dd8\u5b9d\u94fe\u63a5</p> <p>  \u8d2d\u4e70\u94fe\u63a5 </p> </li> </ul>"},{"location":"zh/MAIN-CONTROL/main-control/#_3","title":"\u677f\u8f7d\u8d44\u6e90","text":"<ul> <li>\u4e3b\u9891: 480MHz</li> <li>RAM: 1MB (\u5185\u7f6e)</li> <li>ROM: 2MB (\u5185\u7f6e)</li> <li>SDRAM: 32MB (16\u4f4d) WINBOND W9825G6KH-6I</li> <li>FLASH: 8MB (QSPI) WINBOND W25Q64</li> <li>TF\u5361: 32GB (\u6700\u5927) (\u7ecf\u6d4b\u8bd5, \u652f\u6301\u66f4\u5927\u5bb9\u91cf)</li> <li>LED: 1 PWR; 1 \u53ef\u7f16\u7a0b</li> <li>\u6309\u94ae: 1 RESET; 1 BOOT</li> <li>USB: TYPE-C</li> <li>\u5f15\u811a: 2.54mm \u95f4\u8ddd, 2x2x28\u5f15\u811a</li> </ul>"},{"location":"zh/MAIN-CONTROL/main-control/#_4","title":"\u673a\u68b0\u5c3a\u5bf8","text":""},{"location":"zh/MAIN-CONTROL/main-control/#_5","title":"\u7535\u8def\u56fe","text":""},{"location":"zh/MAIN-CONTROL/BSP/bsp/","title":"\u677f\u7ea7\u652f\u6301\u5305\uff08BSP\uff09","text":""},{"location":"zh/MAIN-CONTROL/BSP/bsp/#bsp_1","title":"BSP \u7b80\u4ecb","text":"<p>\u4e3a\u4e86\u65b9\u4fbf\u4e3b\u63a7\u677f\u7684\u5f00\u53d1\u548c\u79fb\u690d\uff0c\u6211\u51c6\u5907\u4e86\u4e00\u4e2a BSP\uff0c\u5176\u4e2d\u5305\u542b\u4e00\u7cfb\u5217\u6709\u7528\u7684\u9a71\u52a8\u7a0b\u5e8f\u548c\u5e93\u3002BSP \u57fa\u4e8e STM32Cube HAL \u5e93\uff0c\u517c\u5bb9 STM32H7 \u7cfb\u5217\u5fae\u63a7\u5236\u5668\uff0c\u5982\u679c\u4f60\u613f\u610f\uff0c\u4f60\u53ef\u4ee5\u4fee\u6539\u5b83\u4ee5\u9002\u5e94\u5176\u4ed6\u7cfb\u5217\u3002BSP \u5305\u62ec\u4ee5\u4e0b\u6a21\u5757\uff1a</p> <ul> <li>bsp_init\uff1a\u6240\u6709 BSP \u6a21\u5757\u7684\u63a7\u5236\u6a21\u5757\u3002</li> <li>iled\uff1aLED \u9a71\u52a8\u7a0b\u5e8f\u3002</li> <li>iusart\uff1aUSART \u9a71\u52a8\u7a0b\u5e8f\uff0c\u4e3b\u8981\u7528\u4e8e\u4e32\u884c\u901a\u4fe1\u3002</li> <li>isdram\uff1aSDRAM \u4f4e\u7ea7\u9a71\u52a8\u7a0b\u5e8f\u3002</li> <li>imemory\uff1a\u5185\u5b58\u7ba1\u7406\u6a21\u5757\u3002</li> <li>isdcard\uff1aSD \u5361\u9a71\u52a8\u7a0b\u5e8f\u3002</li> <li>ifile\uff1a\u6587\u4ef6\u7cfb\u7edf\u6a21\u5757\u3002</li> <li>...</li> </ul> <p>\u63d0\u793a</p> <p>\u6559\u7a0b\u662f\u6309\u7167\u9010\u8282\u65b9\u5f0f\u7f16\u5199\u7684\uff0c\u4f46\u5728\u5b9e\u8df5\u4e2d\uff0c\u7528\u6237\u53ef\u4ee5\u5728 STM32CUBEMX \u4e2d\u4e00\u6b21\u6027\u8bbe\u7f6e\u6240\u6709\u6240\u9700\u7684\u914d\u7f6e\uff0c\u7136\u540e\u7ee7\u7eed\u8fdb\u884c Keil \u6216 VSCode \u7f16\u7a0b\u3002\u7528\u6237\u53ef\u4ee5\u4ece\u5e93\u4e2d\u79fb\u690d BSP\uff08\u4e0b\u65b9\u9644\u6709\u94fe\u63a5\uff09\uff0c\u5e76\u76f8\u5e94\u5730\u5c06\u5176\u5408\u5e76\u5230\u5176\u9879\u76ee\u4e2d\u3002</p> <ul> <li> <p> MCU_BSP</p> <p>\u57fa\u4e8e STM32 \u7684 MCU BSP</p> <p>  Github Repo </p> </li> </ul>"},{"location":"zh/MAIN-CONTROL/BSP/bsp/#keil","title":"\u8bbe\u7f6e Keil \u4ee5\u83b7\u5f97\u66f4\u597d\u7684\u4f53\u9a8c","text":"<p>\u6253\u5f00 'Options for Target' \u5e76\u8fdb\u884c\u4ee5\u4e0b\u8bbe\u7f6e\uff1a</p>"},{"location":"zh/MAIN-CONTROL/BSP/bsp/#ac6","title":"\u4f7f\u7528 AC6 \u7f16\u8bd1\u5668","text":"<p>\u7531\u4e8e\u8fd9\u662f\u4e00\u4e2a\u65b0\u9879\u76ee\uff0c\u4e00\u5207\u90fd\u662f\u4ece AC6 \u7f16\u8bd1\u5668\u5f00\u59cb\u7684\u3002\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528 AC6 \u8fdb\u884c\u7f16\u8bd1\u548c\u8c03\u8bd5\uff0c\u8fd9\u6bd4 AC5 \u7f16\u8bd1\u5668\u5feb\u5f97\u591a\u3002</p>"},{"location":"zh/MAIN-CONTROL/BSP/bsp/#_1","title":"\u91cd\u7f6e\u5e76\u8fd0\u884c","text":"<p>\u9009\u62e9 'Debug' \u9009\u9879\u5361\uff0c\u5728\u53f3\u4e0a\u89d2\u9009\u62e9 'Settings'\u3002\u5728 'Flash and Download' \u9009\u9879\u5361\u4e2d\uff0c\u9009\u62e9 'Reset and Run'\uff0c\u4ee5\u5728\u5c06\u7a0b\u5e8f\u4e0b\u8f7d\u5230\u677f\u4e0a\u540e\u81ea\u52a8\u91cd\u7f6e\u5e76\u8fd0\u884c\u7a0b\u5e8f\u3002\u8fd9\u5bf9\u7f16\u7a0b\u548c\u8c03\u8bd5\u975e\u5e38\u65b9\u4fbf\u3002</p>"},{"location":"zh/MAIN-CONTROL/BSP/bsp/#bsp_2","title":"\u5982\u4f55\u5c06 BSP \u96c6\u6210\u5230\u60a8\u7684\u9879\u76ee\u4e2d","text":""},{"location":"zh/MAIN-CONTROL/BSP/bsp/#1-bsp","title":"\u6b65\u9aa4 1\uff1a\u4e0b\u8f7d BSP","text":"<p>\u5c06 BSP git \u4ed3\u5e93\u514b\u9686\u5230\u672c\u5730\u5de5\u4f5c\u7a7a\u95f4\u3002</p> <pre><code>git clone https://github.com/Shuaiwen-Cui/MCU_BSP.git\n</code></pre>"},{"location":"zh/MAIN-CONTROL/BSP/bsp/#2-bsp","title":"\u6b65\u9aa4 2\uff1a\u5c06 BSP \u79fb\u52a8\u5230\u60a8\u7684\u9879\u76ee\u4e2d","text":"<p>\u53ea\u9009\u62e9 ''STM32-HAL-CUBEMX' \u6587\u4ef6\u5939\u5e76\u5c06\u5176\u79fb\u52a8\u5230\u60a8\u7684\u9879\u76ee\u76ee\u5f55\u4e2d\u3002</p>"},{"location":"zh/MAIN-CONTROL/BSP/bsp/#3-bsp","title":"\u6b65\u9aa4 3\uff1a\u5c06 BSP \u5305\u542b\u5230\u60a8\u7684\u9879\u76ee\u4e2d","text":"<p>\u6253\u5f00 Keil\uff0c\u9009\u62e9 'Options for Target' -&gt; 'C/C++' -&gt; 'Include Paths'\uff0c\u5c06 BSP \u6a21\u5757\u7684\u5404\u81ea\u8def\u5f84\u6dfb\u52a0\u5230\u60a8\u7684\u9879\u76ee\u5305\u542b\u8def\u5f84\u4e2d\u3002</p>"},{"location":"zh/MAIN-CONTROL/BSP/bsp/#4-bsp","title":"\u6b65\u9aa4 4\uff1a\u5c06 BSP \u6a21\u5757\u6dfb\u52a0\u5230\u60a8\u7684\u9879\u76ee\u4e2d","text":"<p>\u6253\u5f00 'Manage Project Items'\uff0c\u5c06\u5404\u81ea\u6a21\u5757\u6dfb\u52a0\u5230\u60a8\u7684\u9879\u76ee\u4e2d\u3002</p> <p>\u63d0\u793a</p> <p>\u5f53\u60a8\u6dfb\u52a0\u6587\u4ef6\u65f6\uff0c\u5c06\u6587\u4ef6\u7c7b\u578b\u66f4\u6539\u4e3a 'All Types'\uff0c\u4ee5\u4fbf\u5c06 '.h' \u548c '.c' \u6587\u4ef6\u4e00\u8d77\u5408\u5e76\u5230\u9879\u76ee\u4e2d\uff0c\u4ee5\u65b9\u4fbf\u4f7f\u7528\u3002</p>"},{"location":"zh/MAIN-CONTROL/BSP/bsp/#5-bsp_init-bsp","title":"\u6b65\u9aa4 5\uff1a\u5305\u542b\u5934\u6587\u4ef6\u5e76\u8c03\u7528 BSP_Init() \u51fd\u6570\u4ee5\u521d\u59cb\u5316 BSP","text":"<p>\u5728\u60a8\u7684\u4e3b\u51fd\u6570\u4e2d\u5305\u542b 'bsp_init.h' \u5934\u6587\u4ef6\uff0c\u5e76\u5728\u4e3b\u51fd\u6570\u4e2d\u8c03\u7528 'BSP_Init()' \u51fd\u6570\u4ee5\u521d\u59cb\u5316 BSP\u3002</p> <p>Tip</p> <p>\u5f53\u4fee\u6539\u4ee3\u7801\u7684\u65f6\u5019\uff0c\u8bf7\u5728'USER CODE BEGIN'\u548c'USER CODE END'\u4e4b\u95f4\u8fdb\u884c\u4fee\u6539\uff0c\u4ee5\u907f\u514d\u5728\u91cd\u65b0\u751f\u6210\u4ee3\u7801\u65f6\u4e22\u5931\u60a8\u7684\u4fee\u6539\u3002</p>"},{"location":"zh/MAIN-CONTROL/BSP/bsp/#bsp_3","title":"BSP \u6a21\u5757\u4ecb\u7ecd","text":"<p>Note</p> <p>\u4e3a\u4e86\u9ad8\u6548\u7ba1\u7406BSP\u6a21\u5757\uff0c\u6211\u521b\u5efa\u4e86\u4e00\u4e2a\u540d\u4e3a'bsp_init'\u7684\u63a7\u5236\u6a21\u5757\u3002'bsp_init'\u6a21\u5757\u8d1f\u8d23\u521d\u59cb\u5316\u6240\u6709BSP\u6a21\u5757\u5e76\u8bbe\u7f6e\u5fc5\u8981\u7684\u914d\u7f6e\u3002'bsp_init'\u6a21\u5757\u662f\u4e3b\u51fd\u6570\u4e2d\u7b2c\u4e00\u4e2a\u88ab\u8c03\u7528\u7684\u7528\u6237\u6a21\u5757\u3002</p> <p>\u8ba9\u6211\u4eec\u6765\u770b\u770b'bsp_init'\u6a21\u5757\uff1a</p>"},{"location":"zh/MAIN-CONTROL/BSP/bsp/#bsp_init","title":"BSP_INIT \u6a21\u5757\u8bf4\u660e","text":"<p>\u5982\u60a8\u6240\u89c1\uff0c\u51e0\u4e4e\u6240\u6709\u7684 BSP \u6a21\u5757\u90fd\u5728\u6b64\u6a21\u5757\u4e2d\u8fdb\u884c\u4e86\u914d\u7f6e\u3002\u60a8\u53ef\u4ee5\u901a\u8fc7\u6ce8\u91ca\u76f8\u5e94\u7684\u6a21\u5757\u6765\u51b3\u5b9a\u662f\u5426\u6fc0\u6d3b\u6216\u505c\u7528\u8be5\u6a21\u5757\uff1a</p> <ul> <li>MODULE_ENABLE_LED\uff1a\u542f\u7528 LED \u6a21\u5757\u3002</li> <li>MODULE_ENABLE_KEY\uff1a\u542f\u7528\u6309\u952e\u6a21\u5757\u3002\u6ce8\u610f\uff0c\u8be5\u6a21\u5757\u5728\u672c\u9879\u76ee\u4e2d\u672a\u4f7f\u7528\uff0c\u56e0\u4e3a\u6b64\u5f00\u53d1\u677f\u4e0a\u6ca1\u6709\u53ef\u7f16\u7a0b\u6309\u952e\u3002\u4e0d\u8981\u542f\u7528\u6b64\u6a21\u5757\u3002</li> <li>MODULE_ENABLE_USART1\uff1a\u542f\u7528 USART1 \u6a21\u5757\u8fdb\u884c\u4e32\u884c\u901a\u4fe1\u3002\u5982\u679c\u542f\u7528\u4e86\u6b64\u6a21\u5757\uff0c\u6a21\u5757\u4e2d\u5b9a\u4e49\u7684 printf \u548c scanf \u7684\u91cd\u5b9a\u5411\u51fd\u6570\u5c06\u81ea\u52a8\u6fc0\u6d3b\u3002</li> <li>MODULE_ENABLE_SDRAM\uff1a\u542f\u7528 SDRAM \u6a21\u5757\u4ee5\u4f7f\u7528\u5916\u90e8 RAM \u8fdb\u884c\u8ba1\u7b97\u3002</li> <li>MODULE_ENABLE_MEMORY\uff1a\u542f\u7528\u5185\u5b58\u6a21\u5757\u4ee5\u5728 SDRAM \u4e0a\u8fdb\u884c\u5185\u5b58\u7ba1\u7406\u3002</li> <li>MODULE_ENABLE_SDCARD\uff1a\u542f\u7528 SD \u5361\u6a21\u5757\u6d4b\u8bd5 SD \u5361\u7684\u57fa\u672c IO\u3002\u6ce8\u610f\uff0c\u8be5\u6a21\u5757\u4e0d\u80fd\u4e0e MODULE_ENABLE_FILE \u4e00\u8d77\u4f7f\u7528\u3002</li> <li>MODULE_ENABLE_FILE\uff1a\u542f\u7528\u6587\u4ef6\u6a21\u5757\u6d4b\u8bd5 SD \u5361\u4e0a\u7684\u6587\u4ef6\u64cd\u4f5c\u3002\u6ce8\u610f\uff0c\u8be5\u6a21\u5757\u4e0d\u80fd\u4e0e MODULE_ENABLE_SDCARD \u4e00\u8d77\u4f7f\u7528\u3002</li> </ul>"},{"location":"zh/MAIN-CONTROL/BSP/bsp/#bsp_init_1","title":"BSP_INIT \u6a21\u5757\u914d\u7f6e\u63a8\u8350","text":"<p>\u4ee5\u4e0b\u8868\u683c\u4e3a BSP_INIT \u6a21\u5757\u7684\u63a8\u8350\u914d\u7f6e\uff1a</p> \u6a21\u5757\u540d\u79f0 \u914d\u7f6e MODULE_ENABLE_LED \u2705\u542f\u7528 MODULE_ENABLE_KEY \u274c\u7981\u7528 MODULE_ENABLE_USART1 \u2705\u542f\u7528 MODULE_ENABLE_SDRAM \u2705\u542f\u7528 MODULE_ENABLE_MEMORY \u2705\u542f\u7528 MODULE_ENABLE_SDCARD \u274c\u7981\u7528 MODULE_ENABLE_FILE \u2705\u542f\u7528"},{"location":"zh/MAIN-CONTROL/BSP/bsp/#_2","title":"\u6a21\u5757\u6d4b\u8bd5","text":"<p>\u4e3a\u4e86\u65b9\u4fbf\u8bc4\u4f30\u5df2\u914d\u7f6e\u7684\u6a21\u5757\uff0c\u5728 .h \u6587\u4ef6\u4e2d\u5b9a\u4e49\u4e86\u4e00\u4e2a\u5b8f 'BSP_INIT_TEST'\u3002\u8be5\u6d4b\u8bd5\u7528\u4e8e\u6d4b\u8bd5\u5404\u6a21\u5757\u7684\u521d\u59cb\u5316\u3002\u5982\u679c\u60a8\u60f3\u7981\u7528\u6d4b\u8bd5\u4ee5\u8282\u7701\u65f6\u95f4\uff0c\u53ef\u4ee5\u5728 .h \u6587\u4ef6\u4e2d\u6ce8\u91ca\u6389 'BSP_INIT_TEST'\u3002</p>"},{"location":"zh/MAIN-CONTROL/FILE-SYS/file-sys/","title":"\u6587\u4ef6\u7cfb\u7edf (FILE SYSTEM)","text":"<p>Info</p> <p>\u6587\u4ef6\u7cfb\u7edf\u662f\u4e00\u79cd\u5b58\u50a8\u548c\u7ec4\u7ec7\u8ba1\u7b97\u673a\u6587\u4ef6\u53ca\u5176\u6570\u636e\u7684\u65b9\u6cd5\u3002\u5728\u8fd9\u91cc\uff0c\u6211\u4eec\u5c06\u4f7f\u7528 FatFs \u5e93\u4e0e SD \u5361\u8fdb\u884c\u63a5\u53e3\u3002</p>"},{"location":"zh/MAIN-CONTROL/FILE-SYS/file-sys/#_1","title":"\u6587\u4ef6\u7cfb\u7edf\u4f5c\u4e3a\u4e2d\u95f4\u4ef6","text":"<p>\u5728 STM32CUBEMX\u4e2d\uff0cFATFS\u5df2\u7ecf\u4f5c\u4e3a\u4e2d\u95f4\u4ef6\u96c6\u6210\u5230\u8f6f\u4ef6\u4e2d\u3002\u8981\u542f\u7528FATFS\uff0c\u8bf7\u8f6c\u5230\u201c\u4e2d\u95f4\u4ef6\u201d\u9009\u9879\u5361\uff0c\u5e76\u542f\u7528\u201cFATFS\u201d\u4e2d\u95f4\u4ef6.</p> <p></p> <p>\u5982\u56fe\u6240\u793a\uff0c\u9009\u62e9SD\u5361\u7684FATFS\uff0c\u5e76\u542f\u7528\u957f\u6587\u4ef6\u540d\u652f\u6301\u3002</p> <p></p> <p>\u7136\u540e\uff0c\u5728\u9ad8\u7ea7\u8bbe\u7f6e\u4e0b\uff0c\u4e3aSD\u5361\u9009\u62e9DMA\u6a21\u677f\u3002</p>"},{"location":"zh/MAIN-CONTROL/FILE-SYS/file-sys/#_2","title":"\u751f\u6210\u4e0e\u66f4\u65b0\u4ee3\u7801","text":"<p>\u63a5\u4e0b\u6765\uff0c\u6211\u4eec\u751f\u6210\u4ee3\u7801\u4ee5\u4fdd\u5b58\u5f53\u524d\u8fdb\u5ea6\uff0c\u5e76\u4f7f\u5176\u51c6\u5907\u597d\u8fdb\u884c\u540e\u7eed\u7684\u7f16\u7a0b\u6b65\u9aa4\u3002\u70b9\u51fb\u5c4f\u5e55\u53f3\u4e0a\u89d2\u7684\u201c\u751f\u6210\u4ee3\u7801\u201d\u6309\u94ae\u3002</p>"},{"location":"zh/MAIN-CONTROL/FILE-SYS/file-sys/#keil","title":"\u5728Keil\u4e2d\u7f16\u7a0b","text":""},{"location":"zh/MAIN-CONTROL/FILE-SYS/file-sys/#sd_diskioc","title":"\u4fee\u6539SD_DISKIO.C\u4e2d\u7684\u914d\u7f6e","text":"<p>\u5982\u4e0a\u56fe\u6240\u793a\uff0c\u5728sd_diskio.c\u4e2d\u4fee\u6539\u4ee3\u7801\u4ee5\u914d\u7f6eSD\u5361\u548cFATFS\u3002</p>"},{"location":"zh/MAIN-CONTROL/FILE-SYS/file-sys/#-ifile","title":"\u6574\u5408\u6a21\u5757\u4ee3\u7801 - IFILE","text":"<p>\u6211\u4eec\u5df2\u7ecf\u4ecb\u7ecd\u4e86\u5982\u4f55\u5c06BSP\u4ee3\u7801\u79fb\u690d\u5e76\u6574\u5408\u5230\u9879\u76ee\u4e2d\uff0c\u8fd9\u9002\u7528\u4e8e\u6bcf\u4e2a\u76f8\u5e94\u7684\u6a21\u5757\u3002\u5bf9\u4e8e\u79fb\u690d\uff1a</p> <ol> <li>\u4eceBSP\u9879\u76ee\u4e2d\u590d\u5236\u6a21\u5757\u4ee3\u7801\u5230\u7528\u6237\u9879\u76ee\u4e2d\u3002</li> <li>\u5c06\u6a21\u5757\u4ee3\u7801\u6dfb\u52a0\u5230\u7528\u6237\u9879\u76ee\u7684\u5305\u542b\u8def\u5f84\u4e2d\u3002</li> <li>\u5c06\u6a21\u5757\u4ee3\u7801\u6dfb\u52a0\u5230\u9879\u76ee\u9879\u4e2d\u3002</li> <li>\u5728\u7528\u6237\u9879\u76ee\u4e2d\u5305\u542b\u6a21\u5757\u4ee3\u7801\u7684\u5934\u6587\u4ef6\u3002</li> <li>\u5728\u7528\u6237\u9879\u76ee\u4e2d\u8c03\u7528\u6a21\u5757\u51fd\u6570\u3002</li> </ol> <p>Warning</p> <p>\u56e0\u4e3a\u6211\u4eec\u8fd9\u91cc\u4f7f\u7528\u4e86FATFS\uff0c\u800cFATFS\u5185\u7f6e\u4e86SDCARD\u7684\u9a71\u52a8\u65b9\u5f0f\uff0c\u4f1a\u8ddf\u6211\u4eec\u81ea\u5df1\u5f15\u5165\u7684\u9a71\u52a8isdcard\u51b2\u7a81\uff0c\u6240\u4ee5\u5728bsp_init\u4e2d\uff0c\u5982\u679c\u6211\u4eec\u8981\u4f7f\u7528\u6587\u4ef6\u7cfb\u7edfFATFS\uff0c\u90a3\u4e48\u6211\u4eec\u5c31\u4e0d\u80fd\u5f15\u5165isdcard\u9a71\u52a8\uff0c\u5426\u5219\u4f1a\u5bfc\u81f4\u51b2\u7a81\u3002</p>"},{"location":"zh/MAIN-CONTROL/FILE-SYS/file-sys/#-file-sys","title":"\u4ee3\u7801\u5ba1\u67e5 - FILE-SYS","text":""},{"location":"zh/MAIN-CONTROL/FMC/fmc/","title":"\u7075\u6d3b\u5b58\u50a8\u63a7\u5236\u5668 (FMC)","text":"<p>Info</p> <p>FMC \u662f\u7075\u6d3b\u5b58\u50a8\u63a7\u5236\u5668\u7684\u7f29\u5199\u3002\u5b83\u662f\u4e00\u79cd\u529f\u80fd\uff0c\u5141\u8bb8 MCU \u4e0e\u5916\u90e8\u5b58\u50a8\u8bbe\u5907\uff08\u5982 SDRAM\u3001SRAM \u548c NOR Flash\uff09\u8fdb\u884c\u63a5\u53e3\u3002</p>"},{"location":"zh/MAIN-CONTROL/FMC/fmc/#fmc_1","title":"FMC \u8bbe\u7f6e","text":"<p>\u5982\u56fe\u6240\u793a\uff0c\u5728\u201c\u8fde\u63a5\u201d\u9009\u9879\u5361\u4e2d\uff0c\u542f\u7528 FMC\uff0c\u7136\u540e\u5728 FMC \u914d\u7f6e\u533a\u57df\u4e2d\u542f\u7528 SDRAM \u8bbe\u5907\uff0c\u5e76\u6839\u636e SDRAM \u8bbe\u5907\u7684\u6570\u636e\u8868\u8bbe\u7f6e\u53c2\u6570\u3002</p>"},{"location":"zh/MAIN-CONTROL/FMC/fmc/#sdram","title":"\u540c\u6b65\u52a8\u6001\u968f\u673a\u5b58\u50a8\u5668(SDRAM)","text":"<p>SDRAM \u662f\u4e00\u79cd\u5e38\u89c1\u7684\u5916\u90e8\u5b58\u50a8\u8bbe\u5907\u7c7b\u578b\uff0c\u53ef\u4ee5\u4f7f\u7528 FMC \u4e0e MCU \u8fdb\u884c\u63a5\u53e3\u3002\u5b83\u662f\u4e00\u79cd\u7528\u4e8e\u8ba1\u7b97\u673a\u548c\u5176\u4ed6\u7535\u5b50\u8bbe\u5907\u7684\u6613\u5931\u6027\u5b58\u50a8\u5668\u3002\u5728\u8fd9\u91cc\uff0c\u7531\u4e8e\u5185\u7f6e RAM \u4ec5\u4e3a 1MB\uff0c\u5bf9\u4e8e\u67d0\u4e9b\u5e94\u7528\u7a0b\u5e8f\u6765\u8bf4\u4e0d\u591f\uff0c\u6211\u4eec\u9700\u8981\u4f7f\u7528\u5916\u90e8 SDRAM \u6765\u6269\u5c55\u5185\u5b58\u5bb9\u91cf\u3002</p>"},{"location":"zh/MAIN-CONTROL/FMC/fmc/#_1","title":"\u751f\u6210\u4e0e\u66f4\u65b0\u4ee3\u7801","text":"<p>\u63a5\u4e0b\u6765\uff0c\u6211\u4eec\u751f\u6210\u4ee3\u7801\u4ee5\u4fdd\u5b58\u5f53\u524d\u8fdb\u5ea6\uff0c\u5e76\u4f7f\u5176\u51c6\u5907\u597d\u8fdb\u884c\u540e\u7eed\u7684\u7f16\u7a0b\u6b65\u9aa4\u3002\u70b9\u51fb\u5c4f\u5e55\u53f3\u4e0a\u89d2\u7684\u201c\u751f\u6210\u4ee3\u7801\u201d\u6309\u94ae\u3002</p>"},{"location":"zh/MAIN-CONTROL/LED/led/","title":"\u53d1\u5149\u4e8c\u6781\u7ba1 (LED)","text":""},{"location":"zh/MAIN-CONTROL/LED/led/#led_1","title":"LED\u7535\u8def\u8bbe\u8ba1","text":""},{"location":"zh/MAIN-CONTROL/LED/led/#_1","title":"\u914d\u7f6e\u5f15\u811a","text":""},{"location":"zh/MAIN-CONTROL/LED/led/#_2","title":"\u9009\u62e9\u5e76\u8bbe\u7f6e\u5f15\u811a\u6a21\u5f0f","text":"<p>\u6839\u636e\u7535\u8def\u8bbe\u8ba1\uff0c\u9009\u62e9\u5bf9\u5e94\u7684\u5f15\u811aPH7\uff0c\u5e76\u5c06\u6a21\u5f0f\u8bbe\u7f6e\u4e3a\u201cGPIO\u8f93\u51fa\u201d\u3002</p>"},{"location":"zh/MAIN-CONTROL/LED/led/#gpio","title":"GPIO\u8bbe\u7f6e","text":"<p>\u5728\u6700\u5de6\u4fa7\u7684\u9762\u677f\u4e2d\uff0c\u9009\u62e9\u201cGPIO\u201d\u9009\u9879\u5361\uff0c\u5e76\u6309\u4e0b\u56fe\u6240\u793a\u4e3aPH7\u8bbe\u7f6e\u53c2\u6570\u3002</p> <ul> <li>GPIO\u8f93\u51fa\u7535\u5e73\uff1a\u4f4e</li> </ul> <p>Info</p> <p>\u4ece\u7535\u8def\u8bbe\u8ba1\u53ef\u4ee5\u770b\u51fa\uff0c\u4f4e\u7535\u5e73\u8f93\u51fa\u53ef\u4ee5\u70b9\u4eaeLED\uff0c\u800c\u9ad8\u7535\u5e73\u8f93\u51fa\u53ef\u4ee5\u5173\u95edLED\u3002</p> <ul> <li>GPIO\u6a21\u5f0f\uff1a\u8f93\u51fa</li> </ul> <p>\u5728\u8fd9\u91cc\uff0c\u6211\u4eec\u5c06\u5f15\u811a\u6a21\u5f0f\u8bbe\u7f6e\u4e3a\u201c\u8f93\u51fa\u201d\uff0c\u56e0\u4e3a\u6211\u4eec\u4f7f\u7528\u5b83\u6765\u63a7\u5236LED\u3002</p> <ul> <li>GPIO\u4e0a\u62c9/\u4e0b\u62c9\uff1a\u4e0a\u62c9</li> </ul> <p>Info</p> <p>\u4e0a\u62c9\u7535\u963b\u7528\u4e8e\u786e\u4fdd\u5f15\u811a\u5728\u672a\u8fde\u63a5\u5230\u5730\u65f6\u5904\u4e8e\u9ad8\u7535\u5e73\u72b6\u6001\u3002</p> <ul> <li>GPIO\u901f\u5ea6\uff1a\u975e\u5e38\u9ad8</li> </ul> <p>Info</p> <p>GPIO\u5f15\u811a\u7684\u901f\u5ea6\u662f\u6307\u5f15\u811a\u4ece\u4e00\u79cd\u72b6\u6001\u8f6c\u6362\u5230\u53e6\u4e00\u79cd\u72b6\u6001\u7684\u901f\u5ea6\u3002\u5728\u8fd9\u91cc\uff0c\u6211\u4eec\u5c06\u5176\u8bbe\u7f6e\u4e3a\u201c\u975e\u5e38\u9ad8\u201d\uff0c\u4ee5\u786e\u4fddLED\u80fd\u591f\u5feb\u901f\u6253\u5f00\u548c\u5173\u95ed\u3002LED\u5f15\u811a\u7684\u901f\u5ea6\u8bbe\u7f6e\u6ca1\u6709\u4e25\u683c\u8981\u6c42\uff0c\u4f46\u5efa\u8bae\u8bbe\u7f6e\u4e3a\u201c\u975e\u5e38\u9ad8\u201d\u4ee5\u83b7\u5f97\u66f4\u597d\u7684\u6027\u80fd\u3002</p> <ul> <li>\u7528\u6237\u6807\u7b7e\uff1aLED</li> </ul> <p>Info</p> <p>\u7528\u6237\u6807\u7b7e\u7528\u4e8e\u6807\u8bb0\u5f15\u811a\uff0c\u4ee5\u4fbf\u4e8e\u8bc6\u522b\u3002\u8fd9\u91cc\uff0c\u6211\u4eec\u5c06\u5176\u8bbe\u7f6e\u4e3a\u201cLED\u201d\uff0c\u4ee5\u6307\u793a\u8be5\u5f15\u811a\u7528\u4e8e\u63a7\u5236LED\u3002</p>"},{"location":"zh/MAIN-CONTROL/LED/led/#_3","title":"\u751f\u6210\u4e0e\u66f4\u65b0\u4ee3\u7801","text":"<p>\u63a5\u4e0b\u6765\uff0c\u6211\u4eec\u751f\u6210\u4ee3\u7801\u4ee5\u4fdd\u5b58\u5f53\u524d\u8fdb\u5ea6\uff0c\u5e76\u4f7f\u5176\u51c6\u5907\u597d\u8fdb\u884c\u540e\u7eed\u7684\u7f16\u7a0b\u6b65\u9aa4\u3002\u70b9\u51fb\u5c4f\u5e55\u53f3\u4e0a\u89d2\u7684\u201c\u751f\u6210\u4ee3\u7801\u201d\u6309\u94ae\u3002</p>"},{"location":"zh/MAIN-CONTROL/LED/led/#keil","title":"\u5728Keil\u4e2d\u7f16\u7a0b","text":""},{"location":"zh/MAIN-CONTROL/LED/led/#_4","title":"\u6574\u5408\u6a21\u5757\u4ee3\u7801","text":"<p>\u6211\u4eec\u5df2\u7ecf\u4ecb\u7ecd\u4e86\u5982\u4f55\u5c06BSP\u4ee3\u7801\u79fb\u690d\u5e76\u6574\u5408\u5230\u9879\u76ee\u4e2d\uff0c\u8fd9\u9002\u7528\u4e8e\u6bcf\u4e2a\u76f8\u5e94\u7684\u6a21\u5757\u3002\u5bf9\u4e8e\u79fb\u690d\uff1a</p> <ol> <li>\u4eceBSP\u9879\u76ee\u4e2d\u590d\u5236\u6a21\u5757\u4ee3\u7801\u5230\u7528\u6237\u9879\u76ee\u4e2d\u3002</li> <li>\u5c06\u6a21\u5757\u4ee3\u7801\u6dfb\u52a0\u5230\u7528\u6237\u9879\u76ee\u7684\u5305\u542b\u8def\u5f84\u4e2d\u3002</li> <li>\u5c06\u6a21\u5757\u4ee3\u7801\u6dfb\u52a0\u5230\u9879\u76ee\u9879\u4e2d\u3002</li> <li>\u5728\u7528\u6237\u9879\u76ee\u4e2d\u5305\u542b\u6a21\u5757\u4ee3\u7801\u7684\u5934\u6587\u4ef6\u3002</li> <li>\u5728\u7528\u6237\u9879\u76ee\u4e2d\u8c03\u7528\u6a21\u5757\u51fd\u6570\u3002</li> </ol>"},{"location":"zh/MAIN-CONTROL/LED/led/#-led","title":"\u4ee3\u7801\u5ba1\u67e5 - LED","text":"<p>\u8ba9\u6211\u4eec\u5ba1\u67e5LED\u6a21\u5757\u7684\u4ee3\u7801\u3002\u8fd9\u4e2a\u6a21\u5757\u5b9e\u9645\u4e0a\u975e\u5e38\u7b80\u5355\uff0c\u8bfb\u8005\u53ef\u4ee5\u53c2\u8003\u4e0b\u9762\u7684\u4ee3\u7801\u4e86\u89e3\u8be6\u60c5\u3002</p>"},{"location":"zh/MAIN-CONTROL/MEMORY/memory/","title":"\u5185\u5b58\u7ba1\u7406","text":""},{"location":"zh/MAIN-CONTROL/RTOS/rtos/","title":"\u5b9e\u65f6\u64cd\u4f5c\u7cfb\u7edf (RTOS)","text":"<p>\u5f85\u66f4\u65b0\u3002</p>"},{"location":"zh/MAIN-CONTROL/SDCARD/sdcard/","title":"\u5b89\u5168\u6570\u5b57\u5b58\u50a8\u5361(SDCARD)","text":"<p>Info</p> <p>SDCARD\u662fSecure Digital Memory Card\u7684\u7f29\u5199\u3002\u5b83\u662f\u4e00\u79cd\u7528\u4e8e\u8ba1\u7b97\u673a\u548c\u5176\u4ed6\u7535\u5b50\u8bbe\u5907\u7684\u975e\u6613\u5931\u6027\u5b58\u50a8\u5361\u3002\u5728\u8fd9\u91cc\uff0c\u6211\u4eec\u5c06\u4f7f\u7528SDMMC\u5916\u8bbe\u4e0eSD\u5361\u8fdb\u884c\u63a5\u53e3\u3002</p>"},{"location":"zh/MAIN-CONTROL/SDCARD/sdcard/#sdcard_1","title":"SDCARD\u7535\u8def","text":""},{"location":"zh/MAIN-CONTROL/SDCARD/sdcard/#sdcard_2","title":"SDCARD\u914d\u7f6e","text":"<p>\u8981\u542f\u7528SDCARD\uff0c\u6211\u4eec\u9700\u8981\u4e3a\u6b64\u5f00\u53d1\u677f\u542f\u7528SDMMC\u3002\u5bf9\u4e8e\u5176\u4ed6\u4e00\u4e9b\u5f00\u53d1\u677f\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u542f\u7528SDMMC\u5916\u8bbe\u3002</p> <p>\u5bf9\u4e8eSDMMC\u914d\u7f6e\uff0c\u8bf7\u53c2\u8003SDMMC\u9009\u9879\u5361\u3002</p>"},{"location":"zh/MAIN-CONTROL/SDCARD/sdcard/#sdcard-gpio","title":"SDCARD GPIO","text":"<p>\u5bf9\u4e8eSD\u5361\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u9ed8\u8ba4\u7684GPIO\u5f15\u811a\u3002\u4f46\u662f\uff0c\u60a8\u53ef\u4ee5\u6839\u636e\u81ea\u5df1\u7684\u9700\u6c42\u66f4\u6539GPIO\u5f15\u811a\u3002</p>"},{"location":"zh/MAIN-CONTROL/SDCARD/sdcard/#_1","title":"\u751f\u6210\u4e0e\u66f4\u65b0\u4ee3\u7801","text":"<p>\u63a5\u4e0b\u6765\uff0c\u6211\u4eec\u751f\u6210\u4ee3\u7801\u4ee5\u4fdd\u5b58\u5f53\u524d\u8fdb\u5ea6\uff0c\u5e76\u4f7f\u5176\u51c6\u5907\u597d\u8fdb\u884c\u540e\u7eed\u7684\u7f16\u7a0b\u6b65\u9aa4\u3002\u70b9\u51fb\u5c4f\u5e55\u53f3\u4e0a\u89d2\u7684\u201c\u751f\u6210\u4ee3\u7801\u201d\u6309\u94ae\u3002</p>"},{"location":"zh/MAIN-CONTROL/SDCARD/sdcard/#keil","title":"\u5728Keil\u4e2d\u7f16\u7a0b","text":""},{"location":"zh/MAIN-CONTROL/SDCARD/sdcard/#_2","title":"\u6574\u5408\u6a21\u5757\u4ee3\u7801","text":"<p>\u6211\u4eec\u5df2\u7ecf\u4ecb\u7ecd\u4e86\u5982\u4f55\u5c06BSP\u4ee3\u7801\u79fb\u690d\u5e76\u6574\u5408\u5230\u9879\u76ee\u4e2d\uff0c\u8fd9\u9002\u7528\u4e8e\u6bcf\u4e2a\u76f8\u5e94\u7684\u6a21\u5757\u3002\u5bf9\u4e8e\u79fb\u690d\uff1a</p> <ol> <li>\u4eceBSP\u9879\u76ee\u4e2d\u590d\u5236\u6a21\u5757\u4ee3\u7801\u5230\u7528\u6237\u9879\u76ee\u4e2d\u3002</li> <li>\u5c06\u6a21\u5757\u4ee3\u7801\u6dfb\u52a0\u5230\u7528\u6237\u9879\u76ee\u7684\u5305\u542b\u8def\u5f84\u4e2d\u3002</li> <li>\u5c06\u6a21\u5757\u4ee3\u7801\u6dfb\u52a0\u5230\u9879\u76ee\u9879\u4e2d\u3002</li> <li>\u5728\u7528\u6237\u9879\u76ee\u4e2d\u5305\u542b\u6a21\u5757\u4ee3\u7801\u7684\u5934\u6587\u4ef6\u3002</li> <li>\u5728\u7528\u6237\u9879\u76ee\u4e2d\u8c03\u7528\u6a21\u5757\u51fd\u6570\u3002</li> </ol>"},{"location":"zh/MAIN-CONTROL/SDCARD/sdcard/#-sdcard","title":"\u4ee3\u7801\u5ba1\u67e5 - SDCARD","text":""},{"location":"zh/MAIN-CONTROL/SDMMC/sdmmc/","title":"\u5b89\u5168\u6570\u5b57\u5b58\u50a8\u5361\u63a7\u5236\u5668(SDMMC)","text":"<p>Info</p> <p>SDMMC\u662fSecure Digital Memory Card\u7684\u7f29\u5199\u3002\u5b83\u662f\u4e00\u79cd\u7528\u4e8e\u8ba1\u7b97\u673a\u548c\u5176\u4ed6\u7535\u5b50\u8bbe\u5907\u7684\u975e\u6613\u5931\u6027\u5b58\u50a8\u5361\u3002\u5728\u8fd9\u91cc\uff0c\u6211\u4eec\u5c06\u4f7f\u7528SDMMC\u5916\u8bbe\u4e0eSD\u5361\u8fdb\u884c\u63a5\u53e3\u3002</p>"},{"location":"zh/MAIN-CONTROL/SDMMC/sdmmc/#sdmmc_1","title":"\u542f\u7528SDMMC","text":"<p>\u5982\u56fe\u6240\u793a\uff0c\u5728\u201c\u8fde\u63a5\u201d\u9009\u9879\u5361\u4e2d\uff0c\u542f\u7528SDMMC\u5916\u8bbe\u3002\u8bf7\u6ce8\u610f\uff0c\u5206\u9891\u5668\u8bbe\u7f6e\u4e3a2\u3002\u8bf7\u6ce8\u610f\uff0c\u6b64\u65f6\u60a8\u53ef\u80fd\u9700\u8981\u5728\u201c\u65f6\u949f\u914d\u7f6e\u201d\u9009\u9879\u5361\u4e2d\u91cd\u65b0\u914d\u7f6e\u65f6\u949f\u8bbe\u7f6e\u3002</p>"},{"location":"zh/MAIN-CONTROL/SDMMC/sdmmc/#mdma","title":"\u542f\u7528MDMA","text":"<p>Info</p> <p>MDMA\u662fMemory Direct Memory Access\u7684\u7f29\u5199\u3002\u5b83\u662f\u4e00\u79cd\u7528\u4e8e\u5728\u5b58\u50a8\u5668\u548c\u5b58\u50a8\u5668\u4e4b\u95f4\u4f20\u8f93\u6570\u636e\u7684DMA\u3002\u5728\u8fd9\u91cc\uff0c\u6211\u4eec\u5c06\u4f7f\u7528MDMA\u5728SD\u5361\u548cSDRAM\u4e4b\u95f4\u4f20\u8f93\u6570\u636e\u3002</p>"},{"location":"zh/MAIN-CONTROL/SDMMC/sdmmc/#nvic","title":"\u542f\u7528NVIC","text":"<p>\u5982\u56fe\u6240\u793a\uff0c\u5728\u201cNVIC\u8bbe\u7f6e\u201d\u9009\u9879\u5361\u4e2d\uff0c\u542f\u7528SDMMC\u4e2d\u65ad\u3002</p>"},{"location":"zh/MAIN-CONTROL/SDMMC/sdmmc/#nvic_1","title":"NVIC\u914d\u7f6e","text":"<p>\u5230\u76ee\u524d\u4e3a\u6b62\uff0cNVIC\u8bbe\u7f6e\u5982\u56fe\u6240\u793a\u3002</p>"},{"location":"zh/MAIN-CONTROL/SDMMC/sdmmc/#_1","title":"\u751f\u6210\u4e0e\u66f4\u65b0\u4ee3\u7801","text":"<p>\u63a5\u4e0b\u6765\uff0c\u6211\u4eec\u751f\u6210\u4ee3\u7801\u4ee5\u4fdd\u5b58\u5f53\u524d\u8fdb\u5ea6\uff0c\u5e76\u4f7f\u5176\u51c6\u5907\u597d\u8fdb\u884c\u540e\u7eed\u7684\u7f16\u7a0b\u6b65\u9aa4\u3002\u70b9\u51fb\u5c4f\u5e55\u53f3\u4e0a\u89d2\u7684\u201c\u751f\u6210\u4ee3\u7801\u201d\u6309\u94ae\u3002</p>"},{"location":"zh/MAIN-CONTROL/SDRAM/sdram/","title":"\u540c\u6b65\u52a8\u6001\u968f\u673a\u5b58\u50a8\u5668(SDRAM)","text":"<p>Info</p> <p>SDRAM \u662f\u540c\u6b65\u52a8\u6001\u968f\u673a\u5b58\u50a8\u5668\u7684\u7f29\u5199\u3002\u5b83\u662f\u4e00\u79cd\u7528\u4e8e\u8ba1\u7b97\u673a\u548c\u5176\u4ed6\u7535\u5b50\u8bbe\u5907\u7684\u6613\u5931\u6027\u5b58\u50a8\u5668\u3002\u5728\u8fd9\u91cc\uff0c\u7531\u4e8e\u5185\u7f6e RAM \u4ec5\u4e3a 1MB\uff0c\u5bf9\u4e8e\u67d0\u4e9b\u5e94\u7528\u7a0b\u5e8f\u6765\u8bf4\u4e0d\u591f\uff0c\u6211\u4eec\u9700\u8981\u4f7f\u7528\u5916\u90e8 SDRAM \u6765\u6269\u5c55\u5185\u5b58\u5bb9\u91cf\u3002</p>"},{"location":"zh/MAIN-CONTROL/SDRAM/sdram/#sdram_1","title":"SDRAM \u7535\u8def","text":"<p>\u8bf7\u4ed4\u7ec6\u5c06\u5f15\u811a\u8bbe\u8ba1\u4e0eCUBEMX\u4e2d\u7684\u5f15\u811a\u8bbe\u7f6e\u8fdb\u884c\u6bd4\u8f83\uff0c\u786e\u4fdd\u5f15\u811a\u914d\u7f6e\u4e0e\u786c\u4ef6\u8fde\u63a5\u4e00\u81f4\u3002\u5728\u6211\u4eec\u7684\u6848\u4f8b\u4e2d\uff0c\u53ea\u6709PH2, PH3, PH5\u4e0d\u4e00\u81f4\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u5728\u53f3\u4fa7\u7684\u82af\u7247\u89c6\u56fe\u4e2d\u624b\u52a8\u8bbe\u7f6e\uff0c\u5e76\u6309\u7167\u8bbe\u8ba1\u5c06\u5176\u8bbe\u7f6e\u4e3a\u5404\u81ea\u7684\u529f\u80fd\u3002</p>"},{"location":"zh/MAIN-CONTROL/SDRAM/sdram/#sdram_2","title":"SDRAM \u53c2\u6570","text":"<p>\u6211\u4eec\u4f7f\u7528\u7684 SDRAM \u6a21\u5757\u662f WINBOND W9825G6KH-6I\u3002\u60a8\u53ef\u4ee5\u5728\u8fd9\u91cc\u627e\u5230\u6570\u636e\u8868\u3002\u53c2\u6570\u662f\u6839\u636e\u6570\u636e\u8868\u8ba1\u7b97\u7684\u3002</p>"},{"location":"zh/MAIN-CONTROL/SDRAM/sdram/#gpio","title":"GPIO \u914d\u7f6e","text":"<p>\u68c0\u67e5\u5f15\u811a\u914d\u7f6e\u3002\u5c06 CUBEMX \u4e2d\u7684\u8bbe\u7f6e\u4e0e\u5f15\u811a\u8bbe\u8ba1\u8fdb\u884c\u6bd4\u8f83\u3002</p>"},{"location":"zh/MAIN-CONTROL/SDRAM/sdram/#_1","title":"\u751f\u6210\u4e0e\u66f4\u65b0\u4ee3\u7801","text":"<p>\u63a5\u4e0b\u6765\uff0c\u6211\u4eec\u751f\u6210\u4ee3\u7801\u4ee5\u4fdd\u5b58\u5f53\u524d\u8fdb\u5ea6\uff0c\u5e76\u4f7f\u5176\u51c6\u5907\u597d\u8fdb\u884c\u540e\u7eed\u7684\u7f16\u7a0b\u6b65\u9aa4\u3002\u70b9\u51fb\u5c4f\u5e55\u53f3\u4e0a\u89d2\u7684\u201c\u751f\u6210\u4ee3\u7801\u201d\u6309\u94ae\u3002</p>"},{"location":"zh/MAIN-CONTROL/SDRAM/sdram/#keil","title":"\u5728Keil\u4e2d\u7f16\u7a0b","text":""},{"location":"zh/MAIN-CONTROL/SDRAM/sdram/#_2","title":"\u6574\u5408\u6a21\u5757\u4ee3\u7801","text":"<p>\u6211\u4eec\u5df2\u7ecf\u4ecb\u7ecd\u4e86\u5982\u4f55\u5c06BSP\u4ee3\u7801\u79fb\u690d\u5e76\u6574\u5408\u5230\u9879\u76ee\u4e2d\uff0c\u8fd9\u9002\u7528\u4e8e\u6bcf\u4e2a\u76f8\u5e94\u7684\u6a21\u5757\u3002\u5bf9\u4e8e\u79fb\u690d\uff1a</p> <ol> <li>\u4eceBSP\u9879\u76ee\u4e2d\u590d\u5236\u6a21\u5757\u4ee3\u7801\u5230\u7528\u6237\u9879\u76ee\u4e2d\u3002</li> <li>\u5c06\u6a21\u5757\u4ee3\u7801\u6dfb\u52a0\u5230\u7528\u6237\u9879\u76ee\u7684\u5305\u542b\u8def\u5f84\u4e2d\u3002</li> <li>\u5c06\u6a21\u5757\u4ee3\u7801\u6dfb\u52a0\u5230\u9879\u76ee\u9879\u4e2d\u3002</li> <li>\u5728\u7528\u6237\u9879\u76ee\u4e2d\u5305\u542b\u6a21\u5757\u4ee3\u7801\u7684\u5934\u6587\u4ef6\u3002</li> <li>\u5728\u7528\u6237\u9879\u76ee\u4e2d\u8c03\u7528\u6a21\u5757\u51fd\u6570\u3002</li> </ol>"},{"location":"zh/MAIN-CONTROL/SDRAM/sdram/#-sdram","title":"\u4ee3\u7801\u5ba1\u67e5 - SDRAM","text":""},{"location":"zh/MAIN-CONTROL/SDRAM/sdram/#code-review-sdram","title":"CODE REVIEW - SDRAM","text":"<p>\u8ba9\u6211\u4eec\u5ba1\u67e5 SDRAM \u6a21\u5757\u7684\u4ee3\u7801\u3002</p>"},{"location":"zh/MAIN-CONTROL/SDRAM/sdram/#-","title":"\u4ee3\u7801\u5ba1\u67e5 - \u5185\u5b58\u7ba1\u7406","text":"<p>\u8ba9\u6211\u4eec\u6765\u5ba1\u67e5\u5185\u5b58\u7ba1\u7406\u7684\u4ee3\u7801\u3002</p>"},{"location":"zh/MAIN-CONTROL/SDRAM/sdram/#_3","title":"\u4ee3\u7801\u89e3\u91ca","text":"<p>isdram \u6a21\u5757\u63d0\u4f9b\u4e86\u57fa\u672c\u7684sdram\u5185\u5b58\u4ea4\u4e92\u529f\u80fd\uff0c\u4f46\u662f\u4ec5\u6709\u8fd9\u4e9b\u9a71\u52a8\u662f\u4e0d\u591f\u7684\uff0c\u6211\u4eec\u8fd8\u9700\u8981\u4e00\u4e2a\u5185\u5b58\u7ba1\u7406\u6a21\u5757\u6765\u7ba1\u7406sdram\u7684\u5185\u5b58\u5206\u914d\u548c\u91ca\u653e\u3002imemory \u6a21\u5757\u63d0\u4f9b\u4e86\u5185\u5b58\u7ba1\u7406\u7684\u529f\u80fd\uff0c\u901a\u8fc7\u94fe\u8868\u7684\u65b9\u5f0f\u6765\u7ba1\u7406sdram\u7684\u5185\u5b58\u3002\u8fd9\u6837\u6211\u4eec\u5c31\u53ef\u4ee5\u5728sdram\u4e0a\u5206\u914d\u5185\u5b58\uff0c\u4f7f\u7528\u5185\u5b58\uff0c\u91ca\u653e\u5185\u5b58\uff0c\u800c\u4e0d\u9700\u8981\u5173\u5fc3\u5177\u4f53\u7684\u5730\u5740\uff0c\u8fd9\u6781\u5927\u5730\u65b9\u4fbf\u4e86\u6211\u4eec\u7684\u5f00\u53d1\u3002</p>"},{"location":"zh/MAIN-CONTROL/SETUP/setup/","title":"\u521d\u59cb\u5316\u8bbe\u7f6e","text":"<p>Note</p> <p>'\u521d\u59cb\u5316\u8bbe\u7f6e' \u662f\u8bbe\u7f6e\u4e3b\u63a7\u7cfb\u7edf\u7684\u7b2c\u4e00\u6b65\uff0c\u4f7f\u5f97\u7cfb\u7edf\u80fd\u591f\u8fd0\u884c\u57fa\u672c\u529f\u80fd\u3002 \u672c\u8282\u91cd\u70b9\u4ecb\u7ecd\u4e3b\u63a7\u677f\u7684\u57fa\u672c\u8bbe\u7f6e\u3002</p>"},{"location":"zh/MAIN-CONTROL/SETUP/setup/#_2","title":"\u786c\u4ef6\u51c6\u5907","text":"<p>\u4e3a\u4e86\u7f16\u7a0b\u4e3b\u63a7\u677f\uff0c\u6211\u4eec\u9700\u8981\u4e09\u4e2a\u7ec4\u4ef6\uff1a</p> <ul> <li>\u4e3b\u63a7\u677f - \u5d4c\u5165 MCU \u7684\u5f00\u53d1\u677f</li> <li>USB-TTL \u9002\u914d\u5668 - \u5c06\u4e3b\u63a7\u677f\u8fde\u63a5\u5230\u8ba1\u7b97\u673a</li> <li>\u8c03\u8bd5\u5668\uff08ST-LINK V2\u3001J-LINK \u7b49\uff09 - \u7528\u4e8e\u7f16\u7a0b\u4e3b\u63a7\u677f</li> </ul>"},{"location":"zh/MAIN-CONTROL/SETUP/setup/#1-fanke743","title":"\u7ec4\u4ef6 1 - \u4e3b\u63a7\u677f - FANKE743","text":"<ul> <li> <p> \u4ea7\u54c1\u94fe\u63a5</p> <p>\u4ea7\u54c1\u94fe\u63a5</p> <p>  Purchase Link </p> </li> </ul>"},{"location":"zh/MAIN-CONTROL/SETUP/setup/#2-usb-ttl","title":"\u7ec4\u4ef6 2 - USB-TTL \u9002\u914d\u5668","text":"<ul> <li> <p> \u4ea7\u54c1\u94fe\u63a5</p> <p>\u4ea7\u54c1\u94fe\u63a5</p> <p>  Purchase Link </p> </li> </ul>"},{"location":"zh/MAIN-CONTROL/SETUP/setup/#3-","title":"\u7ec4\u4ef6 3 - \u8c03\u8bd5\u5668","text":"<ul> <li> <p> \u4ea7\u54c1\u94fe\u63a5</p> <p>\u4ea7\u54c1\u94fe\u63a5</p> <p>  Purchase Link </p> </li> </ul> <p>Info</p> <p>CMSIS-DAP, ST-LINK, J-LINK\u7b49\u8c03\u8bd5\u5668\u90fd\u53ef\u4ee5\u7528\u4e8e\u7f16\u7a0b\u4e3b\u63a7\u677f\u3002\u4efb\u4f55\u4e00\u79cd\u8c03\u8bd5\u5668\u90fd\u53ef\u4ee5\u7528\u6765\u5bf9\u4e3b\u63a7\u677f\u8fdb\u884c\u7f16\u7a0b\u3002</p>"},{"location":"zh/MAIN-CONTROL/SETUP/setup/#_3","title":"\u786c\u4ef6\u8fde\u63a5","text":"<p>\u5c06\u4e09\u4e2a\u7ec4\u4ef6\u6309\u7167\u4e0a\u56fe\u6240\u793a\u8fdb\u884c\u8fde\u63a5\u3002\u7136\u540e\u5c06 USB-TTL \u9002\u914d\u5668\u8fde\u63a5\u5230\u8ba1\u7b97\u673a\u7684 USB \u7aef\u53e3\uff0c\u5c06\u8c03\u8bd5\u5668\u8fde\u63a5\u5230\u8ba1\u7b97\u673a\u7684 USB \u7aef\u53e3\u3002</p>"},{"location":"zh/MAIN-CONTROL/SETUP/setup/#_4","title":"\u8f6f\u4ef6\u51c6\u5907","text":""},{"location":"zh/MAIN-CONTROL/SETUP/setup/#stm32cubemx","title":"STM32CUBEMX","text":"<p>STM32CUBEMX \u662f\u4e00\u4e2a\u56fe\u5f62\u5316\u5de5\u5177\uff0c\u5141\u8bb8\u975e\u5e38\u8f7b\u677e\u5730\u914d\u7f6e STM32 \u5fae\u63a7\u5236\u5668\uff0c\u5e76\u901a\u8fc7\u5206\u6b65\u8fc7\u7a0b\u751f\u6210\u76f8\u5e94\u7684\u521d\u59cb\u5316 C \u4ee3\u7801\u3002\u53ef\u4ee5\u4ece \u5b98\u65b9\u7f51\u7ad9 \u4e0b\u8f7d\u5e76\u5b89\u88c5 STM32CubeMX\u3002</p>"},{"location":"zh/MAIN-CONTROL/SETUP/setup/#keil-mdk","title":"KEIL MDK","text":"<p>KEIL MDK \u662f\u4e00\u4e2a\u9002\u7528\u4e8e\u5e7f\u6cdb\u7684 ARM Cortex-M \u7cfb\u5217\u5fae\u63a7\u5236\u5668\u8bbe\u5907\u7684\u5b8c\u6574\u8f6f\u4ef6\u5f00\u53d1\u73af\u5883\u3002\u53ef\u4ee5\u4ece \u5b98\u65b9\u7f51\u7ad9 \u4e0b\u8f7d\u5e76\u5b89\u88c5 KEIL MDK\u3002</p>"},{"location":"zh/MAIN-CONTROL/SETUP/setup/#_5","title":"\u8f6f\u4ef6\u8bbe\u7f6e","text":""},{"location":"zh/MAIN-CONTROL/SETUP/setup/#stm32cubemx_1","title":"\u5728 STM32CUBEMX \u4e2d\u521b\u5efa\u65b0\u9879\u76ee","text":""},{"location":"zh/MAIN-CONTROL/SETUP/setup/#_6","title":"\u65b0\u5efa\u9879\u76ee","text":"<p>\u6253\u5f00 STM32CubeMX\uff0c\u70b9\u51fb\u201c\u6587\u4ef6\u201d\u9009\u9879\u5361\uff0c\u7136\u540e\u9009\u62e9\u201c\u65b0\u5efa\u9879\u76ee\u201d\u9009\u9879\u3002</p>"},{"location":"zh/MAIN-CONTROL/SETUP/setup/#mcu","title":"\u9009\u62e9 MCU \u7cfb\u5217\u548c\u578b\u53f7","text":"<p>\u9009\u62e9 MCU \u7cfb\u5217\u548c MCU \u578b\u53f7\u3002\u7136\u540e\u70b9\u51fb\u201c\u5f00\u59cb\u9879\u76ee\u201d\u3002</p>"},{"location":"zh/MAIN-CONTROL/SETUP/setup/#_7","title":"\u542f\u7528\u5185\u5b58\u4fdd\u62a4\u5355\u5143","text":"<p>\u542f\u7528\u201c\u5185\u5b58\u4fdd\u62a4\u5355\u5143\u201d\uff0c\u5e76\u70b9\u51fb\u201cYES\u201d\u3002</p>"},{"location":"zh/MAIN-CONTROL/SETUP/setup/#_8","title":"\u9879\u76ee\u4fe1\u606f\u548c\u4ee3\u7801\u751f\u6210\u914d\u7f6e","text":"<p>\u9996\u5148\u6309\u7167\u4e0a\u56fe\u6240\u793a\u8bbe\u7f6e\u9879\u76ee\u4fe1\u606f\u548c\u4ee3\u7801\u751f\u6210\u914d\u7f6e\u3002\u7136\u540e\u70b9\u51fb\u201c\u751f\u6210\u4ee3\u7801\u201d\u3002</p>"},{"location":"zh/MAIN-CONTROL/SETUP/setup/#_9","title":"\u7cfb\u7edf\u914d\u7f6e","text":"<p>\u8ba9\u6211\u4eec\u56de\u5230 Pinout &amp; Configuration\uff08\u5f15\u811a\u914d\u7f6e\uff09\u9009\u9879\u5361\uff0c\u5e76\u6309\u7167\u4e0b\u56fe\u914d\u7f6e\u7cfb\u7edf\u3002</p>"},{"location":"zh/MAIN-CONTROL/SETUP/setup/#-sys","title":"\u7cfb\u7edf\u6838\u5fc3 - SYS: \u65f6\u95f4\u57fa\u51c6\u6e90","text":"<p>\u9009\u62e9\u201cSYS\u201d\u9009\u9879\u5361\uff0c\u7136\u540e\u5c06\u201c\u65f6\u95f4\u57fa\u51c6\u6e90\u201d\u9009\u62e9\u4e3a\u201cSysTick\u201d\u3002</p>"},{"location":"zh/MAIN-CONTROL/SETUP/setup/#-rcc-hse-lse","title":"\u7cfb\u7edf\u6838\u5fc3 - RCC: \u9ad8\u901f\u65f6\u949f (HSE) \u548c\u4f4e\u901f\u65f6\u949f (LSE)","text":"<p>\u9009\u62e9\u201cRCC\u201d\u9009\u9879\u5361\uff0c\u5e76\u6309\u7167\u4e0a\u56fe\u914d\u7f6e\u201c\u9ad8\u901f\u65f6\u949f (HSE)\u201d\u548c\u201c\u4f4e\u901f\u65f6\u949f (LSE)\u201d\u3002\u4e24\u8005\u5747\u8bbe\u7f6e\u4e3a\u201c\u6676\u4f53/\u9676\u74f7\u8c10\u632f\u5668\u201d\u3002\u901a\u5e38\u6765\u8bf4\uff0c\u5916\u90e8\u6676\u632f\u6bd4\u5185\u90e8 RC \u632f\u8361\u5668\u66f4\u7cbe\u786e\u3002</p>"},{"location":"zh/MAIN-CONTROL/SETUP/setup/#-coretex_m7-i-cached-cache-mpu","title":"\u7cfb\u7edf\u6838\u5fc3 - CORETEX_M7: \u542f\u7528 I-Cache\u3001D-Cache \u548c MPU","text":"<p>\u9009\u62e9\u201cCORETEX_M7\u201d\u9009\u9879\u5361\uff0c\u5e76\u6309\u7167\u4e0a\u56fe\u542f\u7528\u201cI-Cache\u201d\u3001\u201cD-Cache\u201d\u548c\u201cMPU\u201d\u3002\u67d0\u4e9b\u9ad8\u7ea7\u529f\u80fd\u9700\u8981\u542f\u7528 I-Cache\u3001D-Cache \u548c MPU\uff0c\u4f8b\u5982 X-CUBE-AI\u3002</p>"},{"location":"zh/MAIN-CONTROL/SETUP/setup/#-rtc-rtc","title":"\u5b9a\u65f6\u5668 - RTC: \u542f\u7528 RTC","text":"<p>\u9009\u62e9\u201cRTC\u201d\u9009\u9879\u5361\uff0c\u5e76\u6309\u7167\u4e0a\u56fe\u542f\u7528\u201cRTC\u201d\u3002RTC \u662f\u4e00\u4e2a\u5b9e\u65f6\u65f6\u949f\uff0c\u53ef\u4ee5\u7528\u4e8e\u8ddf\u8e2a\u5f53\u524d\u65f6\u95f4\u548c\u65e5\u671f\u3002\u8fd9\u91cc\u6211\u4eec\u542f\u7528 RTC \u4ee5\u5907\u5c06\u6765\u7684\u5e94\u7528\u3002</p>"},{"location":"zh/MAIN-CONTROL/SETUP/setup/#-debug","title":"\u8ddf\u8e2a\u548c\u8c03\u8bd5 - DEBUG: \u542f\u7528\u4e32\u884c\u7ebf","text":"<p>\u9009\u62e9\u201cDEBUG\u201d\u9009\u9879\u5361\uff0c\u5e76\u6309\u7167\u4e0a\u56fe\u542f\u7528\u201c\u4e32\u884c\u7ebf\u201d\u3002\u4e32\u884c\u7ebf\u662f\u4e00\u79cd\u8c03\u8bd5\u63a5\u53e3\uff0c\u5141\u8bb8\u8c03\u8bd5\u5668\u4e0e MCU \u901a\u4fe1\u3002</p>"},{"location":"zh/MAIN-CONTROL/SETUP/setup/#_10","title":"\u65f6\u949f\u914d\u7f6e","text":"<p>\u6309\u7167\u4e0a\u56fe\u914d\u7f6e\u65f6\u949f\u3002\u65f6\u949f\u914d\u7f6e\u5bf9 MCU \u6b63\u5e38\u8fd0\u884c\u81f3\u5173\u91cd\u8981\u3002</p> <p>Note</p> <p>\u5230\u76ee\u524d\u4e3a\u6b62\uff0c\u6211\u4eec\u5df2\u7ecf\u5b8c\u6210\u4e86MCU\u7684\u57fa\u672c\u914d\u7f6e\uff0c\u53ef\u4ee5\u6700\u540e\u68c0\u67e5\u4e00\u4e0b\u76ee\u524d\u7684\u914d\u7f6e\u7136\u540e\u70b9\u51fb\u201c\u751f\u6210\u4ee3\u7801\u201d\u6309\u94ae\u751f\u6210\u4ee3\u7801\u3002\u6211\u4eec\u4f1a\u5728\u63a5\u4e0b\u6765\u7684\u7ae0\u8282\u4e2d\u7ee7\u7eed\u914d\u7f6e\u8f6f\u4ef6\u73af\u5883\u3002</p> <p>Tip</p> <p>\u7b80\u6d01\u8d77\u89c1\uff0c\u6211\u6ca1\u6709\u5728\u6b64\u5904\u5c55\u793a\u6240\u6709\u7684\u914d\u7f6e\u9009\u9879\u3002\u76f8\u53cd\uff0c\u8fd9\u4e9b\u914d\u7f6e\u6839\u636e\u5404\u81ea\u529f\u80fd\u88ab\u5206\u6210\u4e86\u51e0\u4e2a\u90e8\u5206\u5206\u6563\u5728\u4e0d\u540c\u7ae0\u8282\u4e2d\u3002\u5728\u5b9e\u8df5\u4e2d\uff0c\u53ef\u4ee5\u628a\u6240\u6709\u9700\u8981\u7528\u5230\u7684\u914d\u7f6e\u4e00\u6b21\u6027\u914d\u7f6e\u5b8c\u6210\u3002</p>"},{"location":"zh/MAIN-CONTROL/SETUP/setup/#_11","title":"\u751f\u6210\u4e0e\u66f4\u65b0\u4ee3\u7801","text":"<p>\u63a5\u4e0b\u6765\uff0c\u6211\u4eec\u751f\u6210\u4ee3\u7801\u4ee5\u4fdd\u5b58\u5f53\u524d\u8fdb\u5ea6\uff0c\u5e76\u4f7f\u5176\u51c6\u5907\u597d\u8fdb\u884c\u540e\u7eed\u7684\u7f16\u7a0b\u6b65\u9aa4\u3002\u70b9\u51fb\u5c4f\u5e55\u53f3\u4e0a\u89d2\u7684\u201c\u751f\u6210\u4ee3\u7801\u201d\u6309\u94ae\u3002</p>"},{"location":"zh/MAIN-CONTROL/USART/usart-interactive/","title":"\u901a\u7528\u540c\u6b65/\u5f02\u6b65\u6536\u53d1\u5668\uff08USART\uff09","text":"<p>USART\u53ef\u4ee5\u7528\u4e8e\u591a\u79cd\u4e0d\u540c\u7684\u7528\u9014\uff0c\u76ee\u524d\u6211\u4eec\u53ea\u4f7f\u7528USART1\u8fdb\u884c\u4e32\u884c\u901a\u4fe1\u3002</p> <p>Alert</p> <p>\u6b64\u7248\u672c\u7528\u4e8e\u4ea4\u4e92\u5f0f\u7248\u672c\uff0cUSART1 \u7684\u4e2d\u65ad\u548cDMA\u529f\u80fd\u6ca1\u6709\u542f\u7528\u3002\u56e0\u6b64\uff0c\u4e32\u53e3\u4fe1\u606f\u7684\u8f93\u5165\u548c\u8f93\u51fa\u90fd\u662f\u901a\u8fc7\u963b\u585e\u6a21\u5f0f\u8fdb\u884c\u7684\u3002\u5982\u679c\u9700\u8981\u4f7f\u7528\u4e2d\u65ad\u548cDMA\u529f\u80fd\uff0c\u8bf7\u53c2\u9605\u201c\u975e\u4ea4\u4e92\u5f0f\u201d\u7248\u672c\u3002</p>"},{"location":"zh/MAIN-CONTROL/USART/usart-interactive/#usart1","title":"USART1\u7535\u8def","text":"<p>\u4ece\u7535\u8def\u8bbe\u8ba1\u53ef\u4ee5\u770b\u51fa\uff0cUSART1\u7684RX\u548cTX\u5206\u522b\u662fPA9\u548cPA10\u3002\u7136\u800c\uff0c\u9ed8\u8ba4\u9009\u62e9\u7684\u5f15\u811a\u5e76\u4e0d\u662f\u8fd9\u4e24\u4e2a\uff0c\u56e0\u6b64\u6211\u4eec\u9700\u8981\u5728\u5c4f\u5e55\u53f3\u4fa7\u7684\u5f15\u811a\u914d\u7f6e\u4e2d\u624b\u52a8\u66f4\u6539\u5b83\u4eec\u3002</p>"},{"location":"zh/MAIN-CONTROL/USART/usart-interactive/#usart1_1","title":"USART1\u914d\u7f6e","text":""},{"location":"zh/MAIN-CONTROL/USART/usart-interactive/#_1","title":"\u53c2\u6570\u8bbe\u7f6e","text":"<p>\u9009\u62e9\u201c\u53c2\u6570\u8bbe\u7f6e\u201d\u4ee5\u8bbe\u7f6eUSART1\u7684\u53c2\u6570\u3002\u6211\u4eec\u6682\u65f6\u4fdd\u6301\u9ed8\u8ba4\u8bbe\u7f6e\u3002</p>"},{"location":"zh/MAIN-CONTROL/USART/usart-interactive/#_2","title":"\u751f\u6210\u4e0e\u66f4\u65b0\u4ee3\u7801","text":"<p>\u63a5\u4e0b\u6765\uff0c\u6211\u4eec\u751f\u6210\u4ee3\u7801\u4ee5\u4fdd\u5b58\u5f53\u524d\u8fdb\u5ea6\uff0c\u5e76\u4f7f\u5176\u51c6\u5907\u597d\u8fdb\u884c\u540e\u7eed\u7684\u7f16\u7a0b\u6b65\u9aa4\u3002\u70b9\u51fb\u5c4f\u5e55\u53f3\u4e0a\u89d2\u7684\u201c\u751f\u6210\u4ee3\u7801\u201d\u6309\u94ae\u3002</p>"},{"location":"zh/MAIN-CONTROL/USART/usart-interactive/#keil","title":"\u5728Keil\u4e2d\u7f16\u7a0b","text":""},{"location":"zh/MAIN-CONTROL/USART/usart-interactive/#_3","title":"\u6574\u5408\u6a21\u5757\u4ee3\u7801","text":"<p>\u6211\u4eec\u5df2\u7ecf\u4ecb\u7ecd\u4e86\u5982\u4f55\u5c06BSP\u4ee3\u7801\u79fb\u690d\u5e76\u6574\u5408\u5230\u9879\u76ee\u4e2d\uff0c\u8fd9\u9002\u7528\u4e8e\u6bcf\u4e2a\u76f8\u5e94\u7684\u6a21\u5757\u3002\u5bf9\u4e8e\u79fb\u690d\uff1a</p> <ol> <li>\u4eceBSP\u9879\u76ee\u4e2d\u590d\u5236\u6a21\u5757\u4ee3\u7801\u5230\u7528\u6237\u9879\u76ee\u4e2d\u3002</li> <li>\u5c06\u6a21\u5757\u4ee3\u7801\u6dfb\u52a0\u5230\u7528\u6237\u9879\u76ee\u7684\u5305\u542b\u8def\u5f84\u4e2d\u3002</li> <li>\u5c06\u6a21\u5757\u4ee3\u7801\u6dfb\u52a0\u5230\u9879\u76ee\u9879\u4e2d\u3002</li> <li>\u5728\u7528\u6237\u9879\u76ee\u4e2d\u5305\u542b\u6a21\u5757\u4ee3\u7801\u7684\u5934\u6587\u4ef6\u3002</li> <li>\u5728\u7528\u6237\u9879\u76ee\u4e2d\u8c03\u7528\u6a21\u5757\u51fd\u6570\u3002</li> </ol> <p>Tip</p> <p>\u8bf7\u8bb0\u5f97\u5728\u9b54\u68d2\u5de5\u5177\u4e2d\uff0c\u5728\u76ee\u6807\u9009\u9879\u4e0b\uff0c\u4ee3\u7801\u751f\u6210\u533a\u57df\u4e2d\uff0c\u52fe\u9009\u4f7f\u7528MicroLIB\u3002\u8fd9\u4e2a\u5e93\u4f7f\u5f97\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528printf\u51fd\u6570\u3002</p>"},{"location":"zh/MAIN-CONTROL/USART/usart-interactive/#-usart","title":"\u4ee3\u7801\u5ba1\u67e5 - USART","text":"<p>\u8ba9\u6211\u4eec\u5ba1\u67e5USART\u6a21\u5757\u7684\u4ee3\u7801\u3002</p>"},{"location":"zh/MAIN-CONTROL/USART/usart/","title":"\u901a\u7528\u540c\u6b65/\u5f02\u6b65\u6536\u53d1\u5668\uff08USART\uff09","text":"<p>USART\u53ef\u4ee5\u7528\u4e8e\u591a\u79cd\u4e0d\u540c\u7684\u7528\u9014\uff0c\u76ee\u524d\u6211\u4eec\u53ea\u4f7f\u7528USART1\u8fdb\u884c\u4e32\u884c\u901a\u4fe1\u3002</p> <p>Alert</p> <p>\u6b64\u7248\u672c\u7528\u4e8e\u975e\u4ea4\u4e92\u7248\u672c\uff0c\u7531\u4e8e\u542f\u7528\u4e86\u4e2d\u65ad\u548cDMA\u529f\u80fd\uff0c\u6709\u70b9\u96be\u505a\u4ea4\u4e92\u83dc\u5355\u3002\u5982\u9700\u4e92\u52a8\u7248\u672c\uff0c\u8bf7\u53c2\u9605\u201c\u4ea4\u4e92\u5f0f\u201d\u7248\u672c\u3002</p>"},{"location":"zh/MAIN-CONTROL/USART/usart/#usart1","title":"USART1\u7535\u8def","text":"<p>\u4ece\u7535\u8def\u8bbe\u8ba1\u53ef\u4ee5\u770b\u51fa\uff0cUSART1\u7684RX\u548cTX\u5206\u522b\u662fPA9\u548cPA10\u3002\u7136\u800c\uff0c\u9ed8\u8ba4\u9009\u62e9\u7684\u5f15\u811a\u5e76\u4e0d\u662f\u8fd9\u4e24\u4e2a\uff0c\u56e0\u6b64\u6211\u4eec\u9700\u8981\u5728\u5c4f\u5e55\u53f3\u4fa7\u7684\u5f15\u811a\u914d\u7f6e\u4e2d\u624b\u52a8\u66f4\u6539\u5b83\u4eec\u3002</p>"},{"location":"zh/MAIN-CONTROL/USART/usart/#usart1_1","title":"USART1\u914d\u7f6e","text":""},{"location":"zh/MAIN-CONTROL/USART/usart/#_1","title":"\u53c2\u6570\u8bbe\u7f6e","text":"<p>\u9009\u62e9\u201c\u53c2\u6570\u8bbe\u7f6e\u201d\u4ee5\u8bbe\u7f6eUSART1\u7684\u53c2\u6570\u3002\u6211\u4eec\u6682\u65f6\u4fdd\u6301\u9ed8\u8ba4\u8bbe\u7f6e\u3002</p>"},{"location":"zh/MAIN-CONTROL/USART/usart/#dma","title":"DMA\u8bbe\u7f6e","text":"<p>Info</p> <p>DMA\u4ee3\u8868\u76f4\u63a5\u5b58\u50a8\u5668\u8bbf\u95ee\uff08Direct Memory Access\uff09\u3002\u8fd9\u662f\u4e00\u4e2a\u5141\u8bb8\u5916\u8bbe\u5728\u4e0d\u6d89\u53caCPU\u7684\u60c5\u51b5\u4e0b\u8bbf\u95ee\u5185\u5b58\u7684\u529f\u80fd\u3002\u8fd9\u6837\u53ef\u4ee5\u5927\u5927\u51cf\u5c11CPU\u8d1f\u8f7d\u5e76\u63d0\u9ad8\u7cfb\u7edf\u6027\u80fd\u3002</p> <p></p> <p>\u6211\u4eec\u4e3aUSART1\u521b\u5efa\u4e24\u4e2aDMA\u901a\u9053\uff0c\u4e00\u4e2a\u7528\u4e8e\u53d1\u9001\u6570\u636e\uff0c\u53e6\u4e00\u4e2a\u7528\u4e8e\u63a5\u6536\u6570\u636e\u3002</p>"},{"location":"zh/MAIN-CONTROL/USART/usart/#nvic","title":"NVIC\u8bbe\u7f6e","text":"<p>Info</p> <p>NVIC\u4ee3\u8868\u5d4c\u5957\u5411\u91cf\u4e2d\u65ad\u63a7\u5236\u5668\uff08Nested Vectored Interrupt Controller\uff09\u3002\u8fd9\u662f\u4e00\u4e2a\u5141\u8bb8MCU\u5bf9\u4e2d\u65ad\u8fdb\u884c\u4f18\u5148\u7ea7\u6392\u5e8f\u5e76\u9ad8\u6548\u7ba1\u7406\u7684\u529f\u80fd\u3002</p> <p></p> <p>\u5728\u8fd9\u91cc\uff0c\u6211\u4eec\u542f\u7528USART1\u7684\u5168\u5c40\u4e2d\u65ad\u3002\u8bf7\u6ce8\u610f\uff0c\u5bf9\u4e8eDMA\uff0c\u4e00\u65e6\u542f\u7528DMA\u901a\u9053\uff0c\u4e2d\u65ad\u5c06\u9ed8\u8ba4\u542f\u7528\u3002</p> <p>\u6700\u540e\uff0c\u8ba9\u6211\u4eec\u751f\u6210\u4ee3\u7801\u4ee5\u4fdd\u5b58\u5f53\u524d\u8fdb\u5ea6\uff0c\u5e76\u4e3a\u540e\u7eed\u7f16\u7a0b\u6b65\u9aa4\u505a\u597d\u51c6\u5907\u3002\u5355\u51fb\u5c4f\u5e55\u53f3\u4e0a\u89d2\u7684\u201c\u751f\u6210\u4ee3\u7801\u201d\u6309\u94ae\u3002</p>"},{"location":"zh/MAIN-CONTROL/USART/usart/#_2","title":"\u751f\u6210\u4e0e\u66f4\u65b0\u4ee3\u7801","text":"<p>\u63a5\u4e0b\u6765\uff0c\u6211\u4eec\u751f\u6210\u4ee3\u7801\u4ee5\u4fdd\u5b58\u5f53\u524d\u8fdb\u5ea6\uff0c\u5e76\u4f7f\u5176\u51c6\u5907\u597d\u8fdb\u884c\u540e\u7eed\u7684\u7f16\u7a0b\u6b65\u9aa4\u3002\u70b9\u51fb\u5c4f\u5e55\u53f3\u4e0a\u89d2\u7684\u201c\u751f\u6210\u4ee3\u7801\u201d\u6309\u94ae\u3002</p>"},{"location":"zh/MAIN-CONTROL/USART/usart/#keil","title":"\u5728Keil\u4e2d\u7f16\u7a0b","text":""},{"location":"zh/MAIN-CONTROL/USART/usart/#_3","title":"\u6574\u5408\u6a21\u5757\u4ee3\u7801","text":"<p>\u6211\u4eec\u5df2\u7ecf\u4ecb\u7ecd\u4e86\u5982\u4f55\u5c06BSP\u4ee3\u7801\u79fb\u690d\u5e76\u6574\u5408\u5230\u9879\u76ee\u4e2d\uff0c\u8fd9\u9002\u7528\u4e8e\u6bcf\u4e2a\u76f8\u5e94\u7684\u6a21\u5757\u3002\u5bf9\u4e8e\u79fb\u690d\uff1a</p> <ol> <li>\u4eceBSP\u9879\u76ee\u4e2d\u590d\u5236\u6a21\u5757\u4ee3\u7801\u5230\u7528\u6237\u9879\u76ee\u4e2d\u3002</li> <li>\u5c06\u6a21\u5757\u4ee3\u7801\u6dfb\u52a0\u5230\u7528\u6237\u9879\u76ee\u7684\u5305\u542b\u8def\u5f84\u4e2d\u3002</li> <li>\u5c06\u6a21\u5757\u4ee3\u7801\u6dfb\u52a0\u5230\u9879\u76ee\u9879\u4e2d\u3002</li> <li>\u5728\u7528\u6237\u9879\u76ee\u4e2d\u5305\u542b\u6a21\u5757\u4ee3\u7801\u7684\u5934\u6587\u4ef6\u3002</li> <li>\u5728\u7528\u6237\u9879\u76ee\u4e2d\u8c03\u7528\u6a21\u5757\u51fd\u6570\u3002</li> </ol> <p>Tip</p> <p>\u8bf7\u8bb0\u5f97\u5728\u9b54\u68d2\u5de5\u5177\u4e2d\uff0c\u5728\u76ee\u6807\u9009\u9879\u4e0b\uff0c\u4ee3\u7801\u751f\u6210\u533a\u57df\u4e2d\uff0c\u52fe\u9009\u4f7f\u7528MicroLIB\u3002\u8fd9\u4e2a\u5e93\u4f7f\u5f97\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528printf\u51fd\u6570\u3002</p>"},{"location":"zh/MAIN-CONTROL/USART/usart/#-usart","title":"\u4ee3\u7801\u5ba1\u67e5 - USART","text":"<p>\u8ba9\u6211\u4eec\u5ba1\u67e5USART\u6a21\u5757\u7684\u4ee3\u7801\u3002</p>"},{"location":"zh/MAIN-CONTROL/USART/usart/#_4","title":"\u4ee3\u7801\u89e3\u91ca","text":"<p>Tip</p> <p>\u6709\u65f6\u5019'MCU_printf'\u4e0d\u80fd\u6b63\u5e38\u5de5\u4f5c\uff0c\u4f46\u662f'printf'\u53ef\u4ee5\uff0c\u6240\u4ee5\u5927\u591a\u6570\u65f6\u5019\u6211\u4eec\u90fd\u662f\u76f4\u63a5\u4f7f\u7528printf\u800c\u4e0d\u662fMCU_printf\u3002</p>"},{"location":"zh/PERCEPTION/perception/","title":"\u611f\u77e5","text":"<p>\u66f4\u591a\u4fe1\u606f\uff0c\u8bf7\u67e5\u770b\u4e0b\u5c5e\u5b50\u7ae0\u8282\u3002</p>"},{"location":"zh/PERCEPTION/ADXL355/adxl355/","title":"ADXL355 \u52a0\u901f\u5ea6\u4f20\u611f\u5668","text":""},{"location":"zh/PERCEPTION/ADXL355/adxl355/#adxl355_1","title":"ADXL355 \u7b80\u4ecb","text":"<p>ADXL355 \u662fAnalog Devices\u7684\u4e00\u6b3e\u9ad8\u7cbe\u5ea6\u3001\u4f4e\u566a\u58f0\u7684\u4e09\u8f74MEMS\u52a0\u901f\u5ea6\u8ba1\uff0c\u9002\u7528\u4e8e\u9700\u8981\u9ad8\u7cbe\u5ea6\u548c\u4f4e\u566a\u58f0\u7684\u5e94\u7528\u573a\u666f\uff0c\u5982\u5730\u9707\u76d1\u6d4b\u3001\u503e\u659c\u611f\u5e94\u548c\u632f\u52a8\u5206\u6790\u3002ADXL355 \u5177\u6709\u51fa\u8272\u7684\u7a33\u5b9a\u6027\uff0c\u968f\u65f6\u95f4\u548c\u6e29\u5ea6\u53d8\u5316\u7684\u6f02\u79fb\u6781\u4f4e\uff0c\u975e\u5e38\u9002\u5408\u957f\u671f\u76d1\u6d4b\u5e94\u7528\u3002</p> <p>\u8be5\u52a0\u901f\u5ea6\u8ba1\u63d0\u4f9b\u53ef\u9009\u7684\u6d4b\u91cf\u8303\u56f4\uff1a\u00b12g\u3001\u00b14g\u6216\u00b18g\uff0c\u5e76\u4e14\u63d0\u4f9b20\u4f4d\u7684\u8f93\u51fa\u5206\u8fa8\u7387\u3002\u5176\u566a\u58f0\u5bc6\u5ea6\u4f4e\u81f325 \u00b5g/\u221aHz\uff0c\u540c\u65f6\u5728\u6d4b\u91cf\u6a21\u5f0f\u4e0b\u7684\u529f\u8017\u975e\u5e38\u4f4e\uff0c\u901a\u5e38\u7ea6\u4e3a200 \u00b5A\u3002ADXL355 \u652f\u6301\u901a\u8fc7SPI\u6216I\u00b2C\u63a5\u53e3\u8fdb\u884c\u901a\u4fe1\uff0c\u5e76\u5305\u62ec\u6570\u5b57\u6e29\u5ea6\u4f20\u611f\u5668\u3001FIFO\u7f13\u51b2\u533a\u548c\u53ef\u914d\u7f6e\u5e26\u5bbd\u7b49\u529f\u80fd\u3002\u5176\u575a\u56fa\u7684\u8bbe\u8ba1\u786e\u4fdd\u4e86\u5728\u6076\u52a3\u73af\u5883\u4e2d\u7684\u53ef\u9760\u6027\uff0c\u4f7f\u5176\u975e\u5e38\u9002\u5408\u5de5\u4e1a\u548c\u79d1\u5b66\u5e94\u7528\u3002</p> <p> </p> <ul> <li> <p> product link on Taobao</p> <p>Product link on Taobao</p> <p>  Purchase Link </p> </li> </ul>"},{"location":"zh/PERCEPTION/ADXL355/adxl355/#_1","title":"\u5173\u952e\u53c2\u6570","text":"\u53c2\u6570 \u503c \u5de5\u4f5c\u7535\u6d41 200 \u00b5A (\u6d4b\u91cf\u6a21\u5f0f) \u6d4b\u91cf\u8303\u56f4 \u00b12g, \u00b14g, \u00b18g \u5206\u8fa8\u7387 20\u4f4d \u566a\u58f0\u5bc6\u5ea6 25 \u00b5g/\u221aHz \u901a\u4fe1\u63a5\u53e3 SPI, I\u00b2C \u7535\u6e90\u7535\u538b\u8303\u56f4 2.0V \u81f3 3.6V \u5185\u7f6e\u529f\u80fd \u6570\u5b57\u6e29\u5ea6\u4f20\u611f\u5668, FIFO\u7f13\u51b2\u533a \u7a33\u5b9a\u6027 \u4f4e\u6f02\u79fb\uff08\u968f\u65f6\u95f4\u548c\u6e29\u5ea6\u53d8\u5316\uff09"},{"location":"zh/PERCEPTION/ADXL355/adxl355/#_2","title":"\u5f00\u53d1\u53c2\u8003","text":"<ul> <li> <p> SPI</p> <p>  Portal </p> </li> </ul>"},{"location":"zh/PERCEPTION/ADXL362/adxl362/","title":"ADXL362 \u52a0\u901f\u5ea6\u4f20\u611f\u5668","text":""},{"location":"zh/PERCEPTION/ADXL362/adxl362/#adxl362_1","title":"ADXL362 \u7b80\u4ecb","text":"<p>ADXL362 \u662f\u6765\u81eaAnalog Devices\u7684\u4e00\u6b3e\u8d85\u4f4e\u529f\u8017\u4e09\u8f74\u6570\u5b57\u52a0\u901f\u5ea6\u8ba1\uff0c\u4e13\u4e3a\u9700\u8981\u6781\u4f4e\u529f\u8017\u7684\u5e94\u7528\u800c\u8bbe\u8ba1\uff0c\u4f8b\u5982\u53ef\u7a7f\u6234\u8bbe\u5907\u3001\u4fbf\u643a\u5f0f\u7535\u5b50\u4ea7\u54c1\u548c\u65e0\u7ebf\u4f20\u611f\u7f51\u7edc\u3002ADXL362 \u5728\u6d4b\u91cf\u6a21\u5f0f\u4e0b\u7684\u5de5\u4f5c\u7535\u6d41\u4ec5\u4e3a1.8 \u00b5A\uff0c\u5f85\u673a\u6a21\u5f0f\u4e0b\u5219\u4ec5\u4e3a270 nA\uff0c\u56e0\u6b64\u975e\u5e38\u8282\u80fd\u3002</p> <p>\u8be5\u4f20\u611f\u5668\u63d0\u4f9b\u4e86\u4ece\u00b12g\u5230\u00b18g\u7684\u5bbd\u6d4b\u91cf\u8303\u56f4\uff0c\u5e76\u4e14\u5177\u670912\u4f4d\u7684\u9ad8\u5206\u8fa8\u7387\u8f93\u51fa\u3002\u5b83\u901a\u8fc7SPI\u63a5\u53e3\u8fdb\u884c\u901a\u4fe1\uff0c\u5177\u5907\u53ef\u7f16\u7a0b\u7684\u6d3b\u52a8/\u975e\u6d3b\u52a8\u68c0\u6d4b\u3001\u5524\u9192\u529f\u80fd\uff0c\u4ee5\u53ca\u5185\u7f6e\u7684\u6e29\u5ea6\u4f20\u611f\u5668\u3002ADXL362 \u8fd8\u4ee5\u5176\u51fa\u8272\u7684\u566a\u58f0\u6027\u80fd\u8457\u79f0\uff0c\u80fd\u591f\u5728\u4f4e\u529f\u8017\u5e94\u7528\u4e2d\u63d0\u4f9b\u7cbe\u786e\u53ef\u9760\u7684\u8fd0\u52a8\u68c0\u6d4b\u3002</p> <p> </p> <ul> <li> <p> product link on Taobao</p> <p>Product link on Taobao</p> <p>  Purchase Link </p> </li> </ul>"},{"location":"zh/PERCEPTION/ADXL362/adxl362/#_1","title":"\u5173\u952e\u53c2\u6570","text":"\u53c2\u6570 \u503c \u5de5\u4f5c\u7535\u6d41 1.8 \u00b5A (\u6d4b\u91cf\u6a21\u5f0f) \u5f85\u673a\u7535\u6d41 270 nA \u6d4b\u91cf\u8303\u56f4 \u00b12g, \u00b14g, \u00b18g \u5206\u8fa8\u7387 12\u4f4d \u901a\u4fe1\u63a5\u53e3 SPI \u7535\u6e90\u7535\u538b\u8303\u56f4 1.6V \u81f3 3.5V \u566a\u58f0\u6027\u80fd 550 \u00b5g/\u221aHz (\u5178\u578b\u503c) \u5185\u7f6e\u529f\u80fd \u6d3b\u52a8/\u975e\u6d3b\u52a8\u68c0\u6d4b\uff0c\u6e29\u5ea6\u4f20\u611f\u5668"},{"location":"zh/PERCEPTION/ADXL362/adxl362/#_2","title":"\u5f00\u53d1\u53c2\u8003","text":"<ul> <li> <p> STM32 ADXL362</p> <p>  Portal </p> </li> </ul>"},{"location":"zh/PERCEPTION/ADXL362/adxl362/#_3","title":"\u5f00\u53d1\u6d41\u7a0b","text":""},{"location":"zh/POWER/power/","title":"\u7535\u6e90","text":"<p>\u521d\u6b65\u5f00\u53d1\u9636\u6bb5\uff0c\u6211\u4eec\u4f7f\u7528USB\u6570\u636e\u7ebf\u6765\u4e3aMCU\u4f9b\u7535\u3002\u5728\u5c06\u6765\u7684\u5f00\u53d1\u4e2d\uff0c\u5c06\u4f7f\u7528\u7535\u6c60\u4f9b\u7535\u5e76\u6574\u5408\u7535\u6e90\u7ba1\u7406\u3002</p>"},{"location":"zh/RELEASES/releases/","title":"\u53d1\u5e03","text":"<p>\u4ee5\u4e0b\u662f\u8be5\u9879\u76ee\u63d0\u4f9b\u7684\u4e0d\u540c\u7248\u672c\uff0c\u4ee5\u6ee1\u8db3\u4e0d\u540c\u7684\u4f7f\u7528\u573a\u666f\u3002\u4e0b\u8868\u5217\u51fa\u4e86\u53ef\u7528\u7684\u7248\u672c\u53ca\u5176\u76f8\u5e94\u7684\u529f\u80fd\u3002</p> \u7248\u672c\uff08\u6587\u4ef6\u5939\u540d\u79f0\uff09 \u63cf\u8ff0 \u529f\u80fd \u72b6\u6001 \u5907\u6ce8 NODE-CORE-BUILDING \u8be5\u7248\u672c\u4e13\u6ce8\u4e8e\u8ba1\u7b97\u6838\u5fc3\u7684\u5f00\u53d1\uff0c\u5c55\u793a\u6838\u5fc3\u7ec4\u4ef6\u7684\u5f00\u53d1\u8fdb\u5ea6\u3002 \u8ba1\u7b97\u6838\u5fc3\u5f00\u53d1 - \u8fc7\u7a0b\u89c6\u89d2 \u2705 \u5c31\u7eea \u7406\u8bba\u4e0a\u6765\u8bf4\u4e0eNODE-CORE-BUILT\u7b49\u4ef7\uff0c\u53ea\u662f\u6ca1\u6709\u7ecf\u8fc7\u5145\u5206\u6d4b\u8bd5 NODE-CORE-BUILT \u8be5\u7248\u672c\u4e13\u6ce8\u4e8e\u8ba1\u7b97\u6838\u5fc3\u7684\u5f00\u53d1\uff0c\u5c55\u793a\u5df2\u7ecf\u5f00\u53d1\u597d\u7684\u8ba1\u7b97\u6838\u5fc3\u3002 \u8ba1\u7b97\u6838\u5fc3\u5f00\u53d1 - \u5b8c\u6210\u89c6\u89d2 \u2705 \u7a33\u5b9a \ud83c\udfc6 \u63a8\u8350 NODE-CORE-INTERACTION-BUILT \u8be5\u7248\u672c\u4e13\u6ce8\u4e8e\u8ba1\u7b97\u6838\u5fc3\u7684\u5f00\u53d1\uff0c\u5c55\u793a\u5df2\u7ecf\u5f00\u53d1\u597d\u7684\u8ba1\u7b97\u6838\u5fc3\u3002\u76f8\u6bd4\u8f83\u4e0e\u975e\u4ea4\u4e92\u5f0f\u7248\u672c\uff0c\u8fd9\u4e00\u7248\u79fb\u9664\u4e86\u4e32\u53e3\u7684\u4e2d\u65ad\u548cDMA\u529f\u80fd\uff0c\u53ea\u4fdd\u7559\u57fa\u672c\u7684\u4e32\u53e3\u8f93\u5165\u8f93\u51fa\uff0c\u652f\u6301\u7528\u6237\u8f93\u5165\uff08\u5355\u5b57\u7b26\uff09\uff0c\u7528\u4e8e\u4ea4\u4e92\u5f0f\u83dc\u5355\u529f\u80fd\u3002 \u8ba1\u7b97\u6838\u5fc3\u5f00\u53d1 - \u4ea4\u4e92\u89c6\u89d2 \u2705 \u7a33\u5b9a \ud83c\udfc6 \u63a8\u8350"}]}